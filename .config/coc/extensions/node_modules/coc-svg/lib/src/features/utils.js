"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
// cover cb type async function to promise
function pcb(cb) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return new Promise(function (resolve) {
            cb.apply(void 0, args.concat([function (error) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    resolve([error].concat(args));
                }]));
        });
    };
}
exports.pcb = pcb;
/**
 * 通过 lineDelta 和 characterDelta 和 position 返回新的 position
 */
function translateRange(p, lineDelta, characterDelta) {
    if (lineDelta === void 0) { lineDelta = 0; }
    if (characterDelta === void 0) { characterDelta = 0; }
    return {
        line: p.line + lineDelta,
        character: p.character + characterDelta
    };
}
exports.translateRange = translateRange;
/**
 * 判断 range.start 是否和 range.end 相等
 */
function isRangeEmpty(range) {
    var start = range.start, end = range.end;
    return start.line === end.line && start.character === end.character;
}
exports.isRangeEmpty = isRangeEmpty;
/**
 * 判断两个 position 是否相等
 */
function positionEqual(pre, next) {
    return pre.line === next.line && pre.character === next.character;
}
exports.positionEqual = positionEqual;
/**
 * 判断 pre 是否在 next 前面
 */
function positionIsBefore(pre, next) {
    return pre.line < next.line || (pre.line === next.line && pre.character < next.character);
}
exports.positionIsBefore = positionIsBefore;
function createHover(contents, range) {
    return {
        contents: contents,
        range: range
    };
}
exports.createHover = createHover;
/**
 * 从数组删除一个成员
 * @param {Array<T>} array 要删除成员的数组。
 * @param {T} item 要删除的成员。
 * @returns {number} 如果删除成功，返回成员原来在数组中的索引，否则返回 -1。
 */
function removeItem(array, item) {
    var idx = array.indexOf(item);
    if (idx > -1) {
        array.splice(idx, 1);
    }
    return idx;
}
exports.removeItem = removeItem;
/**
 * 返回上一个 XML 标签的位置和名称，它可能是一个开始标签、结束标签。
 * @param {TextDocument} document 当前文档。
 * @param {Position} position 相对位置
 */
function getPrevTag(document, position) {
    var doc = document.getText();
    return getPrevTagFromOffset(doc, document.offsetAt(position));
}
exports.getPrevTag = getPrevTag;
/**
 * 返回上一个 XML 标签的位置和名称，它可能是一个开始标签、结束标签。
 * @param {TextDocument} document 当前文档。
 * @param {Position} position 相对位置
 */
function getPrevTagFromOffset(body, offset) {
    var doc = body.substr(0, offset);
    var match = /<([\/\!\?]?[\w\-]*)(\s*[^>]*)>[^>]*?$/gi.exec(doc);
    if (match && match.length > 1) {
        var attrs = match[2];
        return {
            index: match.index,
            tagName: match[1],
            tagAttrs: attrs,
            simple: attrs && attrs.endsWith('/')
        };
    }
    return undefined;
}
exports.getPrevTagFromOffset = getPrevTagFromOffset;
function getNextTagFromOffset(body, offset) {
    var doc = body.substr(offset);
    var match = /(^[^<]*?)<([\/\!\?]?[\w\-]*)(\s*[^>]*)>/gi.exec(doc);
    if (match && match.length > 1) {
        var attrs = match[3];
        return {
            index: match[1].length + offset,
            tagName: match[2],
            tagAttrs: attrs,
            simple: attrs && attrs.endsWith('/')
        };
    }
    return undefined;
}
exports.getNextTagFromOffset = getNextTagFromOffset;
/**
 * 返回父级 XML 标签的位置和名称。
 */
function getParentTag(token, document, position) {
    var doc = document.getText();
    return getParentTagFromOffset(token, doc, document.offsetAt(position));
}
exports.getParentTag = getParentTag;
/**
 * 返回父级 XML 标签的位置和名称。
 */
function getParentTagFromOffset(token, body, offset) {
    var stack = [];
    var tag = null;
    while (tag = getPrevTagFromOffset(body, offset)) {
        if (token.isCancellationRequested) {
            return undefined;
        }
        offset = tag.index;
        if (tag.simple === true) {
            continue;
        }
        else if (tag.tagName[0] == '/') {
            stack.push(tag.tagName.substr(1));
        }
        else if (stack.length == 0) {
            return tag;
        }
        else {
            stack.pop();
        }
    }
    return undefined;
}
exports.getParentTagFromOffset = getParentTagFromOffset;
/**
 * 如果当前在一个标签头内，返回 XML 标签信息，否则返回 undefined。
 */
function getInStartTag(token, doc, position) {
    return getInStartTagFromOffset(token, doc.getText(), doc.offsetAt(position));
}
exports.getInStartTag = getInStartTag;
/**
 * 如果当前在一个标签头内，返回 XML 标签信息，否则返回 undefined。
 */
function getInStartTagFromOffset(token, body, offset) {
    var doc = body.substr(0, offset);
    var match = /<([\/\!\?]?[\w\-]*)(\s*[^>]*?)$/gi.exec(doc);
    if (match && match.length > 1) {
        var attrs = match[2];
        return {
            index: match.index,
            tagName: match[1],
            tagAttrs: attrs,
            simple: attrs && attrs.endsWith('/')
        };
    }
    return undefined;
}
exports.getInStartTagFromOffset = getInStartTagFromOffset;
/**
 * 如果当前的标签在一个属性值信息内（有或没有开头双引号），返回 XML 标签属性信息，否则返回 undefined。
 */
function getInAttirubte(token, doc, position) {
    return getInAttirubteFromOffset(token, doc.getText(), doc.offsetAt(position));
}
exports.getInAttirubte = getInAttirubte;
/**
 * 如果当前的标签在一个属性值信息内（有或没有开头双引号），返回 XML 标签属性信息，否则返回 undefined。
 */
function getInAttirubteFromOffset(token, body, offset) {
    var tagMatchInfo = getInStartTagFromOffset(token, body, offset);
    if (tagMatchInfo && tagMatchInfo.tagAttrs) {
        var attrMatch = /([\w\-\:]*)=("[^"]*)$/gi.exec(tagMatchInfo.tagAttrs);
        if (attrMatch.length) {
            var attrValueStart = tagMatchInfo.index + tagMatchInfo.tagName.length + 1 + attrMatch.index + attrMatch[1].length + 1;
            return {
                index: tagMatchInfo.index,
                tagName: tagMatchInfo.tagName,
                tagAttrs: tagMatchInfo.tagAttrs,
                simple: tagMatchInfo.simple,
                attrName: attrMatch[1],
                attrValue: attrMatch[2],
                attrValueRange: [attrValueStart, attrValueStart + attrMatch[2].length]
            };
        }
    }
    return undefined;
}
exports.getInAttirubteFromOffset = getInAttirubteFromOffset;
function getOffsetString(doc, position, offset) {
    if (typeof offset != 'number') {
        offset = 1;
    }
    var curOffset = doc.offsetAt(position);
    curOffset += offset;
    var newPosition = doc.positionAt(curOffset);
    if (positionEqual(newPosition, position)) {
        return undefined;
    }
    if (positionIsBefore(newPosition, position)) {
        return doc.getText(vscode_languageserver_protocol_1.Range.create(newPosition, position));
    }
    else {
        return doc.getText(vscode_languageserver_protocol_1.Range.create(position, newPosition));
    }
}
exports.getOffsetString = getOffsetString;
//# sourceMappingURL=utils.js.map