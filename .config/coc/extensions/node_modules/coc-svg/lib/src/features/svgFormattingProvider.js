"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var fs_1 = require("fs");
var path_1 = require("path");
var coc_nvim_1 = require("coc.nvim");
var vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
var vscode_uri_1 = tslib_1.__importDefault(require("vscode-uri"));
var svgo_1 = tslib_1.__importDefault(require("svgo"));
var SvgFormattingProvider = /** @class */ (function () {
    function SvgFormattingProvider() {
        var _this = this;
        this.disableFormatOnSave = false;
        this._lastKnownFormatTime = 0;
        this._lastKnownFormatChanged = false;
        var pluginDirs = path_1.join(__dirname, '..', '..', '..', 'node_modules', 'svgo', 'plugins');
        this._plugins = fs_1.readdirSync(pluginDirs)
            .map(function (file) { return file.replace(path_1.extname(file), ''); });
        coc_nvim_1.workspace.onDidChangeConfiguration(function () {
            _this.updateConfiguration();
        });
        this.updateConfiguration();
        coc_nvim_1.workspace.onWillSaveTextDocument(function (e) {
            var uri = vscode_uri_1.default.parse(e.document.uri);
            if (_this.disableFormatOnSave &&
                _this._lastKnownFormatChanged &&
                uri.fsPath == _this._lastKnownFormatDocument &&
                _this._lastKnownFormatTime + 50 > new Date().getTime()) {
                // In Save Format.
                _this.restoreUnformatDocument(e);
            }
        }, this);
    }
    SvgFormattingProvider.prototype.updateConfiguration = function () {
        var svgConf = coc_nvim_1.workspace.getConfiguration('svg');
        this.disableFormatOnSave = svgConf.get("disableFormatOnSave");
    };
    SvgFormattingProvider.prototype.restoreUnformatDocument = function (e) {
        coc_nvim_1.commands.executeCommand('default:undo');
    };
    SvgFormattingProvider.prototype.provideDocumentFormattingEdits = function (document, options, token) {
        var _this = this;
        var config = coc_nvim_1.workspace.getConfiguration('svg.format.plugins');
        var plugins = this._plugins
            .map(function (configName) {
            var plugin = {};
            plugin[configName] = config[configName] || false;
            return plugin;
        });
        var formatter = new svgo_1.default({
            plugins: plugins,
            js2svg: { pretty: true }
        });
        return new Promise(function (resolve) {
            var oldText = document.getText();
            var p = formatter.optimize(oldText);
            p.then(function (result) {
                var textEdit = {
                    range: vscode_languageserver_protocol_1.Range.create(vscode_languageserver_protocol_1.Position.create(0, 0), vscode_languageserver_protocol_1.Position.create(document.lineCount, 0)),
                    newText: result.data
                };
                resolve([textEdit]);
                _this._lastKnownFormatChanged = (oldText != result.data);
                _this._lastKnownFormatDocument = vscode_uri_1.default.parse(document.uri).fsPath;
                _this._lastKnownFormatTime = new Date().getTime();
            }).catch(function (err) {
                coc_nvim_1.workspace.showMessage("Unable to format because of an error: " + (err.message || err).replace(/\r?\n/g, ' '));
                resolve(null);
            });
        });
    };
    return SvgFormattingProvider;
}());
exports.SvgFormattingProvider = SvgFormattingProvider;
//# sourceMappingURL=svgFormattingProvider.js.map