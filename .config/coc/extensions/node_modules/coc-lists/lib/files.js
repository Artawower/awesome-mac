"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const coc_nvim_1 = require("coc.nvim");
const events_1 = require("events");
const fs_1 = __importDefault(require("fs"));
const minimatch_1 = __importDefault(require("minimatch"));
const path_1 = __importDefault(require("path"));
const readline_1 = __importDefault(require("readline"));
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const util_1 = require("./util");
class Task extends events_1.EventEmitter {
    constructor() {
        super(...arguments);
        this.processes = [];
    }
    start(cmd, args, cwds, patterns) {
        let remain = cwds.length;
        for (let cwd of cwds) {
            let process = child_process_1.spawn(cmd, args, { cwd });
            this.processes.push(process);
            process.on('error', e => {
                this.emit('error', e.message);
            });
            const rl = readline_1.default.createInterface(process.stdout);
            const range = vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0);
            let hasPattern = patterns.length > 0;
            process.stderr.on('data', chunk => {
                console.error(chunk.toString('utf8')); // tslint:disable-line
            });
            rl.on('line', line => {
                let file = line;
                if (file.indexOf(cwd) < 0) {
                    file = path_1.default.join(cwd, line);
                }
                if (hasPattern && patterns.some(p => minimatch_1.default(file, p)))
                    return;
                let location = vscode_languageserver_protocol_1.Location.create(coc_nvim_1.Uri.file(file).toString(), range);
                this.emit('data', {
                    label: line,
                    location
                });
            });
            rl.on('close', () => {
                remain = remain - 1;
                if (remain == 0) {
                    this.emit('end');
                }
            });
        }
    }
    dispose() {
        for (let process of this.processes) {
            if (!process.killed) {
                process.kill();
            }
        }
    }
}
class FilesList extends coc_nvim_1.BasicList {
    constructor(nvim) {
        super(nvim);
        this.name = 'files';
        this.defaultAction = 'open';
        this.description = 'Search files by rg or ag';
        this.detail = `Install ripgrep in your $PATH to have best experience.
Files is searched from current cwd by default.
Provide directory names as arguments to search other directories.
Use 'list.source.files.command' configuration for custom search command.
Use 'list.source.files.args' configuration for custom command arguments.
Note that rg ignore hidden files by default.`;
        this.options = [{
                name: '-F, -folder',
                description: 'Search files from current workspace folder instead of cwd.'
            }, {
                name: '-W, -workspace',
                description: 'Search files from all workspace folders instead of cwd.'
            }];
        this.addLocationActions();
    }
    getArgs(args, defaultArgs) {
        return args.length ? args : defaultArgs;
    }
    getCommand() {
        let config = coc_nvim_1.workspace.getConfiguration('list.source.files');
        let cmd = config.get('command', '');
        let args = config.get('args', []);
        if (!cmd) {
            if (util_1.executable('rg')) {
                return { cmd: 'rg', args: this.getArgs(args, ['--color', 'never', '--files']) };
            }
            else if (util_1.executable('ag')) {
                return { cmd: 'ag', args: this.getArgs(args, ['-f', '-g', '.', '--nocolor']) };
            }
            else if (process.platform == 'win32') {
                return { cmd: 'dir', args: this.getArgs(args, ['/a-D', '/S', '/B']) };
            }
            else if (util_1.executable('find')) {
                return { cmd: 'find', args: this.getArgs(args, ['.', '-type', 'f']) };
            }
            else {
                throw new Error('Unable to find command for files list.');
                return null;
            }
        }
        else {
            return { cmd, args };
        }
    }
    async loadItems(context) {
        let { nvim } = this;
        let { window, args } = context;
        let options = this.parseArguments(args);
        let res = this.getCommand();
        if (!res)
            return null;
        let used = res.args.concat(['-F', '-folder', '-W', '-workspace']);
        let extraArgs = args.filter(s => used.indexOf(s) == -1);
        let cwds;
        let dirArgs = [];
        let searchArgs = [];
        if (options.folder) {
            cwds = [coc_nvim_1.workspace.rootPath];
        }
        else if (options.workspace) {
            cwds = coc_nvim_1.workspace.workspaceFolders.map(f => coc_nvim_1.Uri.parse(f.uri).fsPath);
        }
        else {
            if (extraArgs.length > 0) {
                // tslint:disable-next-line: prefer-for-of
                for (let i = 0; i < extraArgs.length; i++) {
                    let d = await nvim.call('expand', extraArgs[i]);
                    try {
                        if (fs_1.default.lstatSync(d).isDirectory()) {
                            dirArgs.push(d);
                        }
                        else {
                            searchArgs.push(d);
                        }
                    }
                    catch (e) {
                        searchArgs.push(d);
                    }
                }
            }
            if (dirArgs.length > 0) {
                cwds = dirArgs;
            }
            else {
                let valid = await window.valid;
                if (valid) {
                    cwds = [await nvim.call('getcwd', window.id)];
                }
                else {
                    cwds = [await nvim.call('getcwd')];
                }
            }
        }
        let task = new Task();
        let excludePatterns = this.getConfig().get('excludePatterns', []);
        task.start(res.cmd, res.args.concat(searchArgs), cwds, excludePatterns);
        return task;
    }
}
exports.default = FilesList;
//# sourceMappingURL=files.js.map