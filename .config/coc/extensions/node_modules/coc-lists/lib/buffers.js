"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const coc_nvim_1 = require("coc.nvim");
const safe_1 = __importDefault(require("colors/safe"));
const regex = /^\s*(\d+)(.+?)"(.+?)".*/;
class BufferList extends coc_nvim_1.BasicList {
    constructor(nvim) {
        super(nvim);
        this.name = 'buffers';
        this.defaultAction = 'open';
        this.description = 'get buffer list';
        this.addAction('open', async (item) => {
            let { bufnr } = item.data;
            await nvim.command(`buffer ${bufnr}`);
        });
        this.addAction('drop', async (item) => {
            let { bufnr, visible } = item.data;
            if (visible) {
                let info = await nvim.call('getbufinfo', bufnr);
                if (info.length && info[0].windows.length) {
                    let winid = info[0].windows[0];
                    await nvim.call('win_gotoid', winid);
                    return;
                }
            }
            await nvim.command(`buffer ${bufnr}`);
        });
        this.addAction('split', async (item) => {
            let { bufnr } = item.data;
            await nvim.command(`sb ${bufnr}`);
        });
        this.addAction('tabe', async (item) => {
            let { bufname } = item.data;
            let escaped = await nvim.call('fnameescape', bufname);
            await nvim.command(`tabe ${escaped}`);
        });
        this.addAction('vsplit', async (item) => {
            let { bufname } = item.data;
            let escaped = await nvim.call('fnameescape', bufname);
            await nvim.command(`vs ${escaped}`);
        });
        // unload buffer
        this.addAction('delete', async (item) => {
            let { bufnr } = item.data;
            await nvim.command(`bdelete ${bufnr}`);
        }, { persist: true, reload: true });
        this.addAction('wipe', async (item) => {
            let { bufnr } = item.data;
            await nvim.command(`bwipeout ${bufnr}`);
        }, { persist: true, reload: true });
        this.addAction('preview', async (item, context) => {
            let { nvim } = this;
            let { bufname, bufnr } = item.data;
            let info = await nvim.call('getbufinfo', bufnr);
            if (bufname.startsWith('term://'))
                return;
            let height = this.previewHeight;
            let mod = context.options.position == 'top' ? 'below' : '';
            let winid = context.listWindow.id;
            nvim.pauseNotification();
            nvim.command('pclose', true);
            nvim.call('coc#util#open_file', [`${mod} ${height}sp +setl\\ previewwindow`, bufname], true);
            nvim.command('setl winfixheight', true);
            nvim.command(`exe ${info.lnum}`, true);
            nvim.command('normal! zt', true);
            nvim.call('win_gotoid', [winid], true);
            await nvim.resumeNotification();
        });
    }
    async loadItems(_context) {
        const { nvim } = this;
        const bufnrAlt = Number(await nvim.call('bufnr', '#'));
        const content = await nvim.call('execute', 'ls');
        return content.split(/\n/).reduce((res, line) => {
            const ms = line.match(regex);
            if (!ms)
                return res;
            const bufnr = Number(ms[1]);
            const item = {
                label: ` ${safe_1.default.magenta(ms[1])}${safe_1.default.america(ms[2])}${ms[3]}`,
                filterText: ms[3],
                data: {
                    bufnr,
                    bufname: ms[3],
                    visible: ms[2].indexOf('a') !== -1
                }
            };
            return bufnr === bufnrAlt
                ? [item, ...res]
                : [...res, item];
        }, []);
    }
}
exports.default = BufferList;
//# sourceMappingURL=buffers.js.map