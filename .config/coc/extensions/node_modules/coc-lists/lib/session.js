"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const coc_nvim_1 = require("coc.nvim");
const fs_1 = __importDefault(require("fs"));
const mkdirp_1 = __importDefault(require("mkdirp"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const util_1 = require("util");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
class SessionList extends coc_nvim_1.BasicList {
    constructor(nvim, extensionPath) {
        super(nvim);
        this.extensionPath = extensionPath;
        this.name = 'sessions';
        this.defaultAction = 'load';
        this.description = 'session list';
        this.detail = `After session load, coc service would be restarted.`;
        this.mru = coc_nvim_1.workspace.createMru('sessions');
        this.addLocationActions();
        this.addAction('delete', async (item) => {
            let filepath = item.data.filepath;
            await this.mru.remove(filepath);
            await util_1.promisify(fs_1.default.unlink)(filepath);
        }, { reload: true, persist: true });
        this.addAction('load', async (item, _context) => {
            let filepath = item.data.filepath;
            await this.loadSession(filepath);
        });
        this.disposables.push(coc_nvim_1.commands.registerCommand('session.save', async (name) => {
            if (!name) {
                name = await nvim.getVvar('this_session');
                if (!name) {
                    let defaultValue = path_1.default.basename(coc_nvim_1.workspace.rootPath);
                    name = await coc_nvim_1.workspace.requestInput('session name', defaultValue);
                    if (!name)
                        return;
                }
            }
            if (!name.endsWith('.vim'))
                name = name + '.vim';
            let escaped;
            if (!path_1.default.isAbsolute(name)) {
                let folder = await this.getSessionFolder();
                escaped = await nvim.call('fnameescape', [path_1.default.join(folder, name)]);
            }
            else {
                escaped = await nvim.call('fnameescape', [name]);
                name = path_1.default.basename(name, '.vim');
            }
            await nvim.command(`silent mksession! ${escaped}`);
            coc_nvim_1.workspace.showMessage(`Saved session: ${name}`, 'more');
        }));
        this.disposables.push(coc_nvim_1.commands.registerCommand('session.load', async (name) => {
            if (!name) {
                let folder = await this.getSessionFolder();
                let files = await util_1.promisify(fs_1.default.readdir)(folder, { encoding: 'utf8' });
                files = files.filter(p => p.endsWith('.vim'));
                files = files.map(p => path_1.default.basename(p, '.vim'));
                let idx = await coc_nvim_1.workspace.showQuickpick(files, 'choose session:');
                if (idx == -1)
                    return;
                name = files[idx];
            }
            let filepath;
            if (path_1.default.isAbsolute(name)) {
                filepath = name;
            }
            else {
                let folder = await this.getSessionFolder();
                filepath = path_1.default.join(folder, name.endsWith('.vim') ? name : `${name}.vim`);
            }
            setTimeout(async () => {
                await this.loadSession(filepath);
            }, 30);
        }));
        this.disposables.push(coc_nvim_1.commands.registerCommand('session.restart', async () => {
            if (!coc_nvim_1.workspace.isNvim || process.env.TERM_PROGRAM != 'iTerm.app') {
                coc_nvim_1.workspace.showMessage('Sorry, restart support iTerm and neovim only.', 'warning');
                return;
            }
            let filepath = await this.nvim.getVvar('this_session');
            if (!filepath) {
                let folder = await this.getSessionFolder();
                filepath = path_1.default.join(folder, 'default.vim');
            }
            await nvim.command(`silent mksession! ${filepath}`);
            let cwd = await nvim.call('getcwd');
            let cmd = `${path_1.default.join(this.extensionPath, 'nvimstart')} ${filepath} ${cwd}`;
            nvim.call('jobstart', [cmd, { detach: 1 }], true);
            nvim.command('silent! wa | silent quitall!', true);
        }));
        let cfg = coc_nvim_1.workspace.getConfiguration('session');
        let automake = cfg.get('saveOnVimLeave', true);
        if (automake) {
            this.disposables.push(coc_nvim_1.workspace.registerAutocmd({
                event: 'VimLeavePre',
                request: true,
                callback: async () => {
                    let curr = await this.nvim.getVvar('this_session');
                    if (!curr) {
                        let folder = await this.getSessionFolder();
                        curr = path_1.default.join(folder, 'default.vim');
                    }
                    await nvim.command(`silent mksession! ${curr}`);
                }
            }));
        }
    }
    async loadSession(filepath) {
        let { nvim } = this;
        let config = coc_nvim_1.workspace.getConfiguration('session');
        let restart = config.get('restartOnSessionLoad', false);
        if (restart && coc_nvim_1.workspace.isNvim && process.env.TERM_PROGRAM.startsWith('iTerm.app')) {
            let content = await util_1.promisify(fs_1.default.readFile)(filepath, 'utf8');
            let line = content.split(/\r?\n/).find(s => s.startsWith('cd '));
            let cwd = line.replace(/^cd\s+/, '');
            let cmd = `${path_1.default.join(this.extensionPath, 'nvimstart')} ${filepath} ${cwd}`;
            nvim.call('jobstart', [cmd, { detach: 1 }], true);
            nvim.command('silent! wa | silent quitall!', true);
        }
        else {
            await this.mru.add(filepath);
            let escaped = await nvim.call('fnameescape', [filepath]);
            nvim.pauseNotification();
            nvim.command('noautocmd silent! %bwipeout!', true);
            nvim.command(`silent! source ${escaped}`, true);
            nvim.command('CocRestart', true);
            await nvim.resumeNotification(false, true);
        }
    }
    async getSessionFolder() {
        let config = coc_nvim_1.workspace.getConfiguration('session');
        let directory = config.get('directory', '');
        directory = directory.replace(/^~/, os_1.default.homedir());
        const isWin = process.platform === 'win32';
        if (!directory) {
            const folder = isWin ? 'vimfiles/sessions' : '.vim/sessions';
            directory = path_1.default.join(os_1.default.homedir(), folder);
        }
        if (!fs_1.default.existsSync(directory)) {
            mkdirp_1.default.sync(directory);
            if (isWin) {
                let folder = path_1.default.join(os_1.default.homedir(), '.vim/sessions');
                if (fs_1.default.existsSync(folder)) {
                    let stat = fs_1.default.lstatSync(folder);
                    if (stat && stat.isDirectory()) {
                        let files = fs_1.default.readdirSync(folder);
                        for (let file of files) {
                            if (file.endsWith('.vim')) {
                                let dest = path_1.default.join(os_1.default.homedir(), 'vimfiles/sessions', file);
                                fs_1.default.copyFileSync(path_1.default.join(folder, file), dest);
                            }
                        }
                    }
                }
            }
        }
        return directory;
    }
    async loadItems(_context) {
        let folder = await this.getSessionFolder();
        let files = await util_1.promisify(fs_1.default.readdir)(folder, { encoding: 'utf8' });
        files = files.filter(p => p.endsWith('.vim'));
        let range = vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0);
        let curr = await this.nvim.getVvar('this_session');
        let arr = await Promise.all(files.map(file => {
            let filepath = path_1.default.join(folder, file);
            return util_1.promisify(fs_1.default.stat)(filepath).then(stat => {
                return {
                    atime: stat.atime,
                    filepath
                };
            });
        }));
        arr.sort((a, b) => {
            return a.atime.getTime() - b.atime.getTime();
        });
        files = arr.map(o => o.filepath);
        return files.map(filepath => {
            let uri = coc_nvim_1.Uri.file(filepath).toString();
            let location = vscode_languageserver_protocol_1.Location.create(uri, range);
            let name = path_1.default.basename(filepath, '.vim');
            let active = curr && curr == filepath;
            return {
                label: `${active ? '*' : ' '} ${name}\t${filepath}`,
                data: { filepath },
                location
            };
        });
    }
    doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command('syntax match CocSessionsActivited /\\v^\\*/ contained containedin=CocSessionsLine', true);
        nvim.command('syntax match CocSessionsName /\\v%3c\\S+/ contained containedin=CocSessionsLine', true);
        nvim.command('syntax match CocSessionsRoot /\\v\\t[^\\t]*$/ contained containedin=CocSessionsLine', true);
        nvim.command('highlight default link CocSessionsActivited Special', true);
        nvim.command('highlight default link CocSessionsName Type', true);
        nvim.command('highlight default link CocSessionsRoot Comment', true);
        nvim.resumeNotification().catch(_e => {
            // noop
        });
    }
}
exports.default = SessionList;
//# sourceMappingURL=session.js.map