"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const coc_nvim_1 = require("coc.nvim");
const readline_1 = __importDefault(require("readline"));
const vscode_uri_1 = require("vscode-uri");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const util_1 = require("./util");
class Helptags extends coc_nvim_1.BasicList {
    constructor(nvim) {
        super(nvim);
        this.name = 'tags';
        this.description = 'search from tags';
        this.defaultAction = 'open';
        this.addLocationActions();
        this.disposables.push(coc_nvim_1.commands.registerCommand('tags.generate', async () => {
            let config = coc_nvim_1.workspace.getConfiguration('list.source.tags');
            let cmd = config.get('command', 'ctags -R .');
            let res = await coc_nvim_1.workspace.runTerminalCommand(cmd);
            if (res.success)
                coc_nvim_1.workspace.showMessage('tagfile generated');
        }));
    }
    async loadItems(_context) {
        let { nvim } = this;
        let cwd = await nvim.call('getcwd');
        let tagfiles = await nvim.call('tagfiles');
        if (!tagfiles || tagfiles.length == 0) {
            throw new Error('no tag files found, use ":CocCommand tags.generate" to generate tagfile.');
        }
        let result = [];
        await Promise.all(tagfiles.map(file => {
            return new Promise(resolve => {
                let filepath = path_1.default.isAbsolute(file) ? file : path_1.default.join(cwd, file);
                let dirname = path_1.default.dirname(filepath);
                const rl = readline_1.default.createInterface({
                    input: fs_1.default.createReadStream(filepath, { encoding: 'utf8' }),
                });
                rl.on('line', line => {
                    if (line.startsWith('!'))
                        return;
                    let [name, file, pattern] = line.split('\t');
                    if (!pattern)
                        return;
                    let fullpath = path_1.default.join(dirname, file);
                    let uri = vscode_uri_1.URI.file(fullpath).toString();
                    let relativeFile = util_1.isParentFolder(cwd, fullpath) ? path_1.default.relative(cwd, fullpath) : fullpath;
                    result.push({
                        label: `${name}\t${relativeFile}`,
                        filterText: name,
                        location: {
                            uri,
                            line: pattern.replace(/^\/\^/, '').replace(/\$\/;?"?$/, ''),
                            text: name
                        }
                    });
                });
                rl.on('error', e => {
                    nvim.errWrite(`Read file ${file} error: ${e.message}`);
                    resolve();
                });
                rl.on('close', () => {
                    resolve();
                });
            });
        }));
        return result;
    }
    doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command('syntax match CocTagsName /\\v^[^\\t]+/ contained containedin=CocTagsLine', true);
        nvim.command('syntax match CocTagsFile /\\t.*$/ contained containedin=CocTagsLine', true);
        nvim.command('highlight default link CocTagsName Identifier', true);
        nvim.command('highlight default link CocTagsFile Comment', true);
        nvim.resumeNotification(false, true).catch(_e => {
            // noop
        });
    }
}
exports.default = Helptags;
//# sourceMappingURL=tags.js.map