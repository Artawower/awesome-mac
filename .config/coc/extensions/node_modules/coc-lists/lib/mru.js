"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const coc_nvim_1 = require("coc.nvim");
const fs_1 = __importDefault(require("fs"));
const minimatch_1 = __importDefault(require("minimatch"));
const path_1 = __importDefault(require("path"));
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const vscode_uri_1 = require("vscode-uri");
const util_1 = require("./util");
class MruList extends coc_nvim_1.BasicList {
    constructor(nvim) {
        super(nvim);
        this.name = 'mru';
        this.defaultAction = 'open';
        this.description = 'most recent used files in current cwd';
        this.detail = `Use command 'mru.validate' to remove files that not exists any more.`;
        this.options = [{
                name: '-A',
                description: 'Show all recent files instead of filter by cwd.'
            }];
        this.promise = Promise.resolve(undefined);
        this.mru = coc_nvim_1.workspace.createMru('mru');
        this.addLocationActions();
        this.addAction('delete', async (item, _context) => {
            let filepath = vscode_uri_1.URI.parse(item.data.uri).fsPath;
            await this.mru.remove(filepath);
        }, { reload: true, persist: true });
        this.addAction('clean', async () => {
            await this.mru.clean();
        }, { reload: true, persist: true });
        this.disposables.push(coc_nvim_1.commands.registerCommand('mru.validate', async () => {
            let files = await this.mru.load();
            for (let file of files) {
                if (!fs_1.default.existsSync(file)) {
                    await this.mru.remove(file);
                }
            }
        }));
        for (let doc of coc_nvim_1.workspace.documents) {
            this.addRecentFile(doc);
        }
        coc_nvim_1.workspace.onDidOpenTextDocument(async (textDocument) => {
            await util_1.wait(50);
            let doc = coc_nvim_1.workspace.getDocument(textDocument.uri);
            if (doc)
                this.addRecentFile(doc);
        }, null, this.disposables);
        coc_nvim_1.events.on('BufEnter', bufnr => {
            let doc = coc_nvim_1.workspace.getDocument(bufnr);
            if (doc)
                this.addRecentFile(doc);
        }, null, this.disposables);
    }
    addRecentFile(doc) {
        this.promise = this.promise.then(() => {
            return this._addRecentFile(doc);
        }, () => {
            return this._addRecentFile(doc);
        });
    }
    async _addRecentFile(doc) {
        let uri = vscode_uri_1.URI.parse(doc.uri);
        if (uri.scheme !== 'file' || doc.buftype != '')
            return;
        if (doc.filetype == 'netrw')
            return;
        if (doc.uri.indexOf('NERD_tree') !== -1)
            return;
        let parts = uri.fsPath.split(path_1.default.sep);
        if (parts.indexOf('.git') !== -1 || parts.length == 0)
            return;
        let preview = await this.nvim.eval(`getwinvar(bufwinnr(${doc.bufnr}), '&previewwindow')`);
        if (preview == 1)
            return;
        let filepath = uri.fsPath;
        let patterns = this.config.get('source.mru.excludePatterns', []);
        let ignoreGitIgnore = this.config.get('source.mru.ignoreGitIgnore', false);
        if (ignoreGitIgnore && doc.isIgnored)
            return;
        if (patterns.some(p => minimatch_1.default(filepath, p)))
            return;
        await this.mru.add(filepath);
    }
    async loadItems(context) {
        let cwd = context.cwd;
        let findAll = context.args.indexOf('-A') !== -1;
        let files = await this.mru.load();
        const range = vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0);
        if (!findAll)
            files = files.filter(file => util_1.isParentFolder(cwd, file));
        return files.map(file => {
            let uri = vscode_uri_1.URI.file(file).toString();
            let location = vscode_languageserver_protocol_1.Location.create(uri.toString(), range);
            return {
                label: findAll ? file : path_1.default.relative(cwd, file),
                data: { uri },
                location
            };
        });
    }
}
exports.default = MruList;
//# sourceMappingURL=mru.js.map