"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const safe_1 = __importDefault(require("colors/safe"));
const fs_1 = __importDefault(require("fs"));
const util_1 = __importDefault(require("util"));
const index_1 = require("./util/index");
const regex = /^\|:(\S+)\|\t(\S+)\t(.*)$/;
class Commands {
    constructor(nvim) {
        this.nvim = nvim;
        this.name = 'vimcommands';
        this.description = 'command list';
        this.defaultAction = 'execute';
        this.actions = [];
        this.actions.push({
            name: 'execute',
            execute: async (item) => {
                if (Array.isArray(item))
                    return;
                let { command, shabang, hasArgs } = item.data;
                if (!hasArgs) {
                    nvim.command(command, true);
                }
                else {
                    const feedableCommand = `:${command}${shabang ? '' : ' '}`;
                    const mode = await nvim.call('mode');
                    const isInsertMode = mode.startsWith('i');
                    if (isInsertMode) {
                        // For some reason `nvim.feedkeys` doesn't support CSI escapes, even though the
                        // docs say it should. So we force the escape here with double backslashes.
                        nvim.command(`call feedkeys("\\<C-O>${feedableCommand}", 'n')`, true);
                    }
                    else {
                        await nvim.feedKeys(feedableCommand, 'n', true);
                    }
                }
            }
        });
        this.actions.push({
            name: 'open',
            execute: async (item) => {
                if (Array.isArray(item))
                    return;
                let { command } = item.data;
                if (!/^[A-Z]/.test(command))
                    return;
                let res = await nvim.eval(`split(execute("verbose command ${command}"),"\n")[-1]`);
                if (/Last\sset\sfrom/.test(res)) {
                    let filepath = res.replace(/^\s+Last\sset\sfrom\s+/, '');
                    nvim.command(`edit +/${command} ${filepath}`, true);
                }
            }
        });
    }
    async loadItems(_context) {
        let { nvim } = this;
        let list = await nvim.eval('split(execute("command"),"\n")');
        list = list.slice(1);
        let res = [];
        for (let str of list) {
            let name = str.slice(4).match(/\S+/)[0];
            let end = str.slice(4 + name.length);
            res.push({
                label: str.slice(0, 4) + safe_1.default.magenta(name) + end,
                filterText: name,
                data: {
                    command: name,
                    shabang: str.startsWith('!'),
                    hasArgs: !end.match(/^\s*0\s/)
                }
            });
        }
        let help = await nvim.eval(`globpath($VIMRUNTIME, 'doc/index.txt')`);
        if (help && fs_1.default.existsSync(help)) {
            let content = await util_1.default.promisify(fs_1.default.readFile)(help, 'utf8');
            for (let line of content.split(/\r?\n/)) {
                let ms = line.match(regex);
                if (ms) {
                    let [, cmd, chars, description] = ms;
                    res.push({
                        label: `    ${safe_1.default.magenta(cmd)}${index_1.pad(cmd, 20)}${chars}${index_1.pad(chars, 30)}${description}`,
                        filterText: cmd,
                        data: {
                            command: cmd,
                            shabang: false,
                            hasArgs: true
                        }
                    });
                }
            }
        }
        return res;
    }
}
exports.default = Commands;
//# sourceMappingURL=commands.js.map