"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const coc_nvim_1 = require("coc.nvim");
const vscode_uri_1 = require("vscode-uri");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const util_1 = require("./util");
class Helptags extends coc_nvim_1.BasicList {
    constructor(nvim) {
        super(nvim);
        this.name = 'helptags';
        this.description = 'helptags of vim';
        this.defaultAction = 'show';
        this.addAction('show', item => {
            nvim.command(`help ${item.data.name}`, true);
        });
        this.addLocationActions();
    }
    async loadItems(_context) {
        let rtp = coc_nvim_1.workspace.env.runtimepath;
        if (!rtp)
            return [];
        let folders = rtp.split(',');
        let result = [];
        let cwd = await this.nvim.call('getcwd');
        await Promise.all(folders.map(folder => {
            return new Promise(resolve => {
                let file = path_1.default.join(folder, 'doc/tags');
                fs_1.default.readFile(file, 'utf8', (err, content) => {
                    if (err)
                        return resolve();
                    let lines = content.split(/\r?\n/);
                    for (let line of lines) {
                        if (line) {
                            let [name, filepath, regex] = line.split('\t');
                            let fullpath = path_1.default.join(folder, 'doc', filepath);
                            let uri = vscode_uri_1.URI.file(fullpath).toString();
                            let file = util_1.isParentFolder(cwd, fullpath) ? path_1.default.relative(cwd, fullpath) : fullpath;
                            result.push({
                                label: `${name}\t${file}`,
                                filterText: name,
                                location: {
                                    uri,
                                    line: regex.replace(/^\//, '').replace(/\$\//, ''),
                                    text: name
                                },
                                data: { name }
                            });
                        }
                    }
                    resolve();
                });
            });
        }));
        return result;
    }
    doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command('syntax match CocHelptagsName /\\v^[^\\t]+/ contained containedin=CocHelptagsLine', true);
        nvim.command('syntax match CocHelptagsFile /\\t.*$/ contained containedin=CocHelptagsLine', true);
        nvim.command('highlight default link CocHelptagsName Identifier', true);
        nvim.command('highlight default link CocHelptagsFile Comment', true);
        nvim.resumeNotification(false, true).catch(_e => {
            // noop
        });
    }
}
exports.default = Helptags;
//# sourceMappingURL=helptags.js.map