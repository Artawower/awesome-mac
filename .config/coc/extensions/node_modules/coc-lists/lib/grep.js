"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const coc_nvim_1 = require("coc.nvim");
const events_1 = require("events");
const minimatch_1 = __importDefault(require("minimatch"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const readline_1 = __importDefault(require("readline"));
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const vscode_uri_1 = require("vscode-uri");
const util_1 = require("./util");
const ansiparse_1 = require("./util/ansiparse");
const option_1 = require("./util/option");
const lineRegex = /^(.+):(\d+):(\d+):(.*)/;
const controlCode = '\x1b';
class Task extends events_1.EventEmitter {
    constructor(interactive) {
        super();
        this.interactive = interactive;
        this.processes = [];
    }
    start(cmd, args, cwds, patterns) {
        for (let cwd of cwds) {
            let remain = cwds.length;
            let process = child_process_1.spawn(cmd, args, { cwd });
            process.on('error', e => {
                this.emit('error', e.message);
            });
            process.stderr.on('data', chunk => {
                console.error(chunk.toString('utf8')); // tslint:disable-line
            });
            const rl = readline_1.default.createInterface(process.stdout);
            let hasPattern = patterns.length > 0;
            rl.on('line', line => {
                let ms;
                let escaped;
                if (line.indexOf(controlCode) !== -1) {
                    let parts = ansiparse_1.ansiparse(line);
                    escaped = parts.reduce((s, curr) => s + curr.text, '');
                    ms = escaped.match(lineRegex);
                }
                else {
                    ms = line.match(lineRegex);
                    escaped = line;
                }
                if (!ms)
                    return;
                let file = path_1.default.join(cwd, ms[1]);
                if (hasPattern && patterns.some(p => minimatch_1.default(file, p)))
                    return;
                let pos = vscode_languageserver_protocol_1.Position.create(Number(ms[2]) - 1, byteSlice(ms[4], 0, Number(ms[3]) - 1).length);
                let location = vscode_languageserver_protocol_1.Location.create(vscode_uri_1.URI.file(file).toString(), vscode_languageserver_protocol_1.Range.create(pos, pos));
                this.emit('data', {
                    label: line,
                    filterText: this.interactive ? '' : escaped,
                    location
                });
            });
            rl.on('close', () => {
                remain = remain - 1;
                if (remain == 0) {
                    this.emit('end');
                }
            });
        }
    }
    dispose() {
        for (let process of this.processes) {
            if (!process.killed) {
                process.kill();
            }
        }
    }
}
class GrepList extends coc_nvim_1.BasicList {
    constructor(nvim) {
        super(nvim);
        this.interactive = true;
        this.description = 'grep text by rg or ag';
        this.name = 'grep';
        this.defaultAction = 'open';
        this.detail = `Literal match is used by default.
To use interactive mode, add '-I' or '--interactive' to LIST OPTIONS.
To change colors, checkout 'man rg' or 'man ag'.
To search from workspace folders instead of cwd, use '-folder' or '-workspace' argument.
Grep source provide some uniformed options to ease differences between rg and ag.`;
        this.options = [{
                name: '-S, -smartcase',
                description: 'Use smartcase match.'
            }, {
                name: '-i, -ignorecase',
                description: 'Use ignorecase match.'
            }, {
                name: '-l, -literal',
                description: 'Treat the pattern as a literal string, used when -regex is not used.'
            }, {
                name: '-w, -word',
                description: 'Use word match.'
            }, {
                name: '-e, -regex',
                description: 'Use regex match.'
            }, {
                name: '-u, -skip-vcs-ignores',
                description: 'Don\'t respect version control ignore files(.gitignore, etc.)'
            }, {
                name: '-t, -extension EXTENSION',
                description: 'Grep files with specified extension only, could be used multiple times.',
                hasValue: true
            }, {
                name: '-F, -folder',
                description: 'Grep files from current workspace folder instead of cwd.'
            }, {
                name: '-W, -workspace',
                description: 'Grep files from all workspace folders instead of cwd.'
            }];
        this.addLocationActions();
    }
    async loadItems(context) {
        let { nvim } = this;
        let { interactive } = context.options;
        let config = coc_nvim_1.workspace.getConfiguration('list.source.grep');
        let cmd = config.get('command', 'rg');
        let args = config.get('args', []).slice();
        let useLiteral = config.get('useLiteral', true);
        if (cmd == 'rg') {
            let maxColumns = config.get('maxColumns', 300);
            args.push('--color', 'always', '--max-columns', maxColumns.toString(), '--vimgrep', '--colors', 'path:fg:white');
        }
        else if (cmd == 'ag') {
            args.push('--color', '--vimgrep');
        }
        if (!util_1.executable(cmd))
            throw new Error(`Command '${cmd}' not found on $PATH`);
        if (interactive && !context.input)
            return [];
        args.push(...context.args);
        if (context.input) {
            if (interactive && context.input.indexOf(' ') != -1) {
                let input = context.input.split(/\s+/).join('.*');
                if (!args.includes('-regex') && !args.includes('-e')) {
                    args.push('-regex');
                }
                args.push(input);
            }
            else {
                args.push(context.input);
            }
        }
        let patterns = config.get('excludePatterns', []);
        let { window } = context;
        let cwds;
        if (args.indexOf('-F') != -1 || args.indexOf('-folder') != -1) {
            cwds = [coc_nvim_1.workspace.rootPath];
        }
        else if (args.indexOf('-W') != -1 || args.indexOf('-workspace') != -1) {
            cwds = coc_nvim_1.workspace.workspaceFolders.map(f => vscode_uri_1.URI.parse(f.uri).fsPath);
        }
        else {
            let valid = await window.valid;
            if (valid) {
                cwds = [await nvim.call('getcwd', window.id)];
            }
            else {
                cwds = [await nvim.call('getcwd')];
            }
        }
        let task = new Task(interactive);
        if (cmd == 'rg' || cmd == 'ag') {
            args = option_1.convertOptions(args, cmd, useLiteral);
            args = args.filter(s => ['-F', '-folder', '-W', '-workspace'].indexOf(s) == -1);
        }
        if (os_1.default.platform() == 'win32') {
            args.push('--', './');
        }
        task.start(cmd, args, cwds, patterns);
        return task;
    }
}
exports.default = GrepList;
function byteSlice(content, start, end) {
    let buf = Buffer.from(content, 'utf8');
    return buf.slice(start, end).toString('utf8');
}
//# sourceMappingURL=grep.js.map