"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cp = require("child_process");
const fs = require("fs");
const minimatch = require("minimatch");
const path_1 = require("path");
const util = require("util");
const server = require("vscode-languageserver");
const mruCache_1 = require("./mruCache");
function toPackageManager(manager) {
    switch (manager && manager.toLowerCase()) {
        case 'npm': return 'npm';
        case 'pnpm': return 'pnpm';
        case 'yarn': return 'yarn';
        default: return undefined;
    }
}
exports.toPackageManager = toPackageManager;
class ConfigCache {
    constructor() {
        this.filePath = undefined;
        this.configuration = undefined;
    }
    set(filePath, configuration) {
        this.filePath = filePath;
        this.configuration = configuration;
    }
    get(forPath) {
        return forPath === this.filePath ? this.configuration : undefined;
    }
    isDefaultLinterConfig() {
        return !!(this.configuration && this.configuration.isDefaultLinterConfig);
    }
    flush() {
        this.filePath = undefined;
        this.configuration = undefined;
    }
}
const emptyLintResult = {
    errorCount: 0,
    warningCount: 0,
    failures: [],
    fixes: [],
    format: '',
    output: '',
};
const emptyResult = {
    lintResult: emptyLintResult,
    warnings: [],
};
class TsLintRunner {
    constructor(trace) {
        this.trace = trace;
        this.tslintPath2Library = new Map();
        this.document2LibraryCache = new mruCache_1.MruCache(100);
        // map stores undefined values to represent failed resolutions
        this.globalPackageManagerPath = new Map();
        this.configCache = new ConfigCache();
    }
    runTsLint(filePath, contents, configuration) {
        this.traceMethod('runTsLint', 'start');
        const warnings = [];
        if (!this.document2LibraryCache.has(filePath)) {
            this.loadLibrary(filePath, configuration, warnings);
        }
        this.traceMethod('runTsLint', 'Loaded tslint library');
        if (!this.document2LibraryCache.has(filePath)) {
            return emptyResult;
        }
        const library = this.document2LibraryCache.get(filePath)();
        if (!library) {
            return {
                lintResult: emptyLintResult,
                warnings: [
                    getInstallFailureMessage(filePath, configuration.packageManager || 'npm'),
                ],
            };
        }
        this.traceMethod('runTsLint', 'About to validate ' + filePath);
        return this.doRun(filePath, contents, library, configuration, warnings);
    }
    onConfigFileChange(_tsLintFilePath) {
        this.configCache.flush();
    }
    traceMethod(method, message) {
        this.trace(`(${method}) ${message}`);
    }
    loadLibrary(filePath, configuration, warningsOutput) {
        this.traceMethod('loadLibrary', `trying to load ${filePath}`);
        const getGlobalPath = () => this.getGlobalPackageManagerPath(configuration.packageManager);
        const directory = path_1.dirname(filePath);
        let np;
        if (configuration && configuration.nodePath) {
            const exists = fs.existsSync(configuration.nodePath);
            if (exists) {
                np = configuration.nodePath;
            }
            else {
                warningsOutput.push(`The setting 'tslint.nodePath' refers to '${configuration.nodePath}', but this path does not exist. The setting will be ignored.`);
            }
        }
        let tsLintPath;
        if (np) {
            try {
                tsLintPath = this.resolveTsLint(np, np);
                if (tsLintPath.length === 0) {
                    tsLintPath = this.resolveTsLint(getGlobalPath(), directory);
                }
            }
            catch (_a) {
                tsLintPath = this.resolveTsLint(getGlobalPath(), directory);
            }
        }
        else {
            try {
                tsLintPath = this.resolveTsLint(undefined, directory);
                if (tsLintPath.length === 0) {
                    tsLintPath = this.resolveTsLint(getGlobalPath(), directory);
                }
            }
            catch (_b) {
                tsLintPath = this.resolveTsLint(getGlobalPath(), directory);
            }
        }
        this.traceMethod('loadLibrary', `Resolved tslint to ${tsLintPath}`);
        this.document2LibraryCache.set(filePath, () => {
            let library;
            if (!this.tslintPath2Library.has(tsLintPath)) {
                try {
                    library = require(tsLintPath);
                }
                catch (e) {
                    this.tslintPath2Library.set(tsLintPath, undefined);
                    return;
                }
                this.tslintPath2Library.set(tsLintPath, library);
            }
            return this.tslintPath2Library.get(tsLintPath);
        });
    }
    getGlobalPackageManagerPath(packageManager = 'npm') {
        this.traceMethod('getGlobalPackageManagerPath', `Begin - Resolve Global Package Manager Path for: ${packageManager}`);
        if (!this.globalPackageManagerPath.has(packageManager)) {
            let path;
            if (packageManager === 'npm') {
                path = server.Files.resolveGlobalNodePath(this.trace);
            }
            else if (packageManager === 'yarn') {
                path = server.Files.resolveGlobalYarnPath(this.trace);
            }
            else if (packageManager === 'pnpm') {
                path = cp.execSync('pnpm root -g').toString().trim();
            }
            this.globalPackageManagerPath.set(packageManager, path);
        }
        this.traceMethod('getGlobalPackageManagerPath', `Done - Resolve Global Package Manager Path for: ${packageManager}`);
        return this.globalPackageManagerPath.get(packageManager);
    }
    doRun(filePath, contents, library, configuration, warnings) {
        this.traceMethod('doRun', `starting validation for ${filePath}`);
        let cwd = configuration.workspaceFolderPath;
        if (!cwd && typeof contents === "object") {
            cwd = contents.getCurrentDirectory();
        }
        if (this.fileIsExcluded(configuration, filePath, cwd)) {
            this.traceMethod('doRun', `No linting: file ${filePath} is excluded`);
            return emptyResult;
        }
        if (cwd) {
            this.traceMethod('doRun', `Changed directory to ${cwd}`);
            process.chdir(cwd);
        }
        const configFile = configuration.configFile || null;
        let linterConfiguration;
        this.traceMethod('doRun', 'About to getConfiguration');
        try {
            linterConfiguration = this.getConfiguration(filePath, filePath, library, configFile);
        }
        catch (err) {
            this.traceMethod('doRun', `No linting: exception when getting tslint configuration for ${filePath}, configFile= ${configFile}`);
            warnings.push(getConfigurationFailureMessage(err));
            return {
                lintResult: emptyLintResult,
                warnings,
            };
        }
        if (!linterConfiguration) {
            this.traceMethod('doRun', `No linting: no tslint configuration`);
            return emptyResult;
        }
        this.traceMethod('doRun', 'Configuration fetched');
        if (isJsDocument(filePath) && !configuration.jsEnable) {
            this.traceMethod('doRun', `No linting: a JS document, but js linting is disabled`);
            return emptyResult;
        }
        if (configuration.validateWithDefaultConfig === false && this.configCache.configuration.isDefaultLinterConfig) {
            this.traceMethod('doRun', `No linting: linting with default tslint configuration is disabled`);
            return emptyResult;
        }
        if (isExcludedFromLinterOptions(linterConfiguration.linterConfiguration, filePath)) {
            this.traceMethod('doRun', `No linting: file is excluded using linterOptions.exclude`);
            return emptyResult;
        }
        let result;
        const options = {
            formatter: "json",
            fix: false,
            rulesDirectory: configuration.rulesDirectory || undefined,
            formattersDirectory: undefined,
        };
        if (configuration.traceLevel && configuration.traceLevel === 'verbose') {
            this.traceConfigurationFile(linterConfiguration.linterConfiguration);
        }
        // tslint writes warnings using console.warn, capture these warnings and send them to the client
        const originalConsoleWarn = console.warn;
        const captureWarnings = (message) => {
            warnings.push(message);
            originalConsoleWarn(message);
        };
        console.warn = captureWarnings;
        try { // clean up if tslint crashes
            const linter = new library.Linter(options, typeof contents === 'string' ? undefined : contents);
            this.traceMethod('doRun', `Linting: start linting`);
            linter.lint(filePath, typeof contents === 'string' ? contents : '', linterConfiguration.linterConfiguration);
            result = linter.getResult();
            this.traceMethod('doRun', `Linting: ended linting`);
        }
        finally {
            console.warn = originalConsoleWarn;
        }
        return {
            lintResult: result,
            warnings,
            workspaceFolderPath: configuration.workspaceFolderPath,
            configFilePath: linterConfiguration.path,
        };
    }
    getConfiguration(uri, filePath, library, configFileName) {
        this.traceMethod('getConfiguration', `Starting for ${uri}`);
        const config = this.configCache.get(filePath);
        if (config) {
            return config;
        }
        let isDefaultConfig = false;
        let linterConfiguration;
        const linter = library.Linter;
        if (linter.findConfigurationPath) {
            isDefaultConfig = linter.findConfigurationPath(configFileName, filePath) === undefined;
        }
        const configurationResult = linter.findConfiguration(configFileName, filePath);
        linterConfiguration = configurationResult.results;
        // In tslint version 5 the 'no-unused-variable' rules breaks the TypeScript language service plugin.
        // See https://github.com/Microsoft/TypeScript/issues/15344
        // Therefore we remove the rule from the configuration.
        if (linterConfiguration) {
            if (linterConfiguration.rules) {
                linterConfiguration.rules.delete('no-unused-variable');
            }
            if (linterConfiguration.jsRules) {
                linterConfiguration.jsRules.delete('no-unused-variable');
            }
        }
        const configuration = {
            isDefaultLinterConfig: isDefaultConfig,
            linterConfiguration,
            path: configurationResult.path,
        };
        this.configCache.set(filePath, configuration);
        return this.configCache.configuration;
    }
    fileIsExcluded(settings, filePath, cwd) {
        if (settings.ignoreDefinitionFiles && filePath.endsWith('.d.ts')) {
            return true;
        }
        return settings.exclude.some(pattern => testForExclusionPattern(filePath, pattern, cwd));
    }
    traceConfigurationFile(configuration) {
        if (!configuration) {
            this.trace("no tslint configuration");
            return;
        }
        this.trace("tslint configuration:" + util.inspect(configuration, undefined, 4));
    }
    resolveTsLint(nodePath, cwd) {
        const nodePathKey = 'NODE_PATH';
        const app = [
            "console.log(require.resolve('tslint'));",
        ].join('');
        const env = process.env;
        const newEnv = Object.create(null);
        Object.keys(env).forEach(key => newEnv[key] = env[key]);
        if (nodePath) {
            if (newEnv[nodePathKey]) {
                newEnv[nodePathKey] = nodePath + path_1.delimiter + newEnv[nodePathKey];
            }
            else {
                newEnv[nodePathKey] = nodePath;
            }
            this.traceMethod('resolveTsLint', `NODE_PATH value is: ${newEnv[nodePathKey]}`);
        }
        newEnv.ELECTRON_RUN_AS_NODE = '1';
        const spanwResults = cp.spawnSync(process.argv0, ['-e', app], { cwd, env: newEnv });
        return spanwResults.stdout.toString().trim();
    }
}
exports.TsLintRunner = TsLintRunner;
function testForExclusionPattern(filePath, pattern, cwd) {
    if (cwd) {
        // try first as relative
        const relPath = path_1.relative(cwd, filePath);
        if (minimatch(relPath, pattern, { dot: true })) {
            return true;
        }
        if (relPath === filePath) {
            return false;
        }
    }
    return minimatch(filePath, pattern, { dot: true });
}
function getInstallFailureMessage(filePath, packageManager) {
    const localCommands = {
        npm: 'npm install tslint',
        pnpm: 'pnpm install tslint',
        yarn: 'yarn add tslint',
    };
    const globalCommands = {
        npm: 'npm install -g tslint',
        pnpm: 'pnpm install -g tslint',
        yarn: 'yarn global add tslint',
    };
    return [
        `Failed to load the TSLint library for '${filePath}'`,
        `To use TSLint, please install tslint using \'${localCommands[packageManager]}\' or globally using \'${globalCommands[packageManager]}\'.`,
        'Be sure to restart your editor after installing tslint.',
    ].join('\n');
}
function isJsDocument(filePath) {
    return /\.(jsx?|mjs)$/i.test(filePath);
}
function isExcludedFromLinterOptions(config, fileName) {
    if (config === undefined || config.linterOptions === undefined || config.linterOptions.exclude === undefined) {
        return false;
    }
    return config.linterOptions.exclude.some(pattern => testForExclusionPattern(fileName, pattern, undefined));
}
function getConfigurationFailureMessage(err) {
    let errorMessage = `unknown error`;
    if (typeof err.message === 'string' || err.message instanceof String) {
        errorMessage = err.message;
    }
    return `Cannot read tslint configuration - '${errorMessage}'`;
}
//# sourceMappingURL=index.js.map