"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const coc_nvim_1 = require("coc.nvim");
const fs_1 = require("fs");
const path = tslib_1.__importStar(require("path"));
const errorHandler_1 = require("./errorHandler");
const utils_1 = require("./utils");
const ignore = require('ignore');
const nullIgnorer = { ignores: () => false };
/**
 * Create an ignore file handler. Will lazily read ignore files on a per-resource
 * basis, and cache the contents until it changes.
 */
function ignoreFileHandler(disposables) {
    const ignorers = new Map();
    disposables.push({ dispose: () => ignorers.clear() });
    return {
        fileIsIgnored(filePath) {
            const { ignorer, ignoreFilePath } = getIgnorerForFile(filePath);
            return ignorer.ignores(path.relative(path.dirname(ignoreFilePath), filePath));
        },
    };
    function getIgnorerForFile(fsPath) {
        const absolutePath = getIgnorePathForFile(fsPath, utils_1.getConfig(coc_nvim_1.Uri.file(fsPath)).ignorePath);
        if (!absolutePath) {
            return { ignoreFilePath: '', ignorer: nullIgnorer };
        }
        if (!ignorers.has(absolutePath)) {
            loadIgnorer(coc_nvim_1.Uri.file(absolutePath));
        }
        if (!fs_1.existsSync(absolutePath)) {
            // Don't log default value.
            const ignorePath = utils_1.getConfig(coc_nvim_1.Uri.file(fsPath)).ignorePath;
            if (ignorePath !== '.prettierignore') {
                errorHandler_1.addToOutput(`Wrong prettier.ignorePath provided in your settings. The path (${ignorePath}) does not exist.`, 'Warning');
            }
            return { ignoreFilePath: '', ignorer: nullIgnorer };
        }
        return {
            ignoreFilePath: absolutePath,
            ignorer: ignorers.get(absolutePath),
        };
    }
    function loadIgnorer(ignoreUri) {
        let ignorer = nullIgnorer;
        if (!ignorers.has(ignoreUri.fsPath)) {
            const fileWatcher = coc_nvim_1.workspace.createFileSystemWatcher(ignoreUri.fsPath);
            disposables.push(fileWatcher);
            fileWatcher.onDidCreate(loadIgnorer, null, disposables);
            fileWatcher.onDidChange(loadIgnorer, null, disposables);
            fileWatcher.onDidDelete(unloadIgnorer, null, disposables);
        }
        if (fs_1.existsSync(ignoreUri.fsPath)) {
            const ignoreFileContents = fs_1.readFileSync(ignoreUri.fsPath, 'utf8');
            ignorer = ignore().add(ignoreFileContents);
        }
        ignorers.set(ignoreUri.fsPath, ignorer);
    }
    function unloadIgnorer(ignoreUri) {
        ignorers.set(ignoreUri.fsPath, nullIgnorer);
    }
}
function getIgnorePathForFile(_filePath, ignorePath) {
    // Configuration `prettier.ignorePath` is set to `null`
    if (!ignorePath) {
        return null;
    }
    if (coc_nvim_1.workspace.workspaceFolder) {
        const folder = coc_nvim_1.workspace.workspaceFolder;
        return folder ? getPath(ignorePath, coc_nvim_1.Uri.parse(folder.uri).fsPath) : null;
    }
    return null;
}
function getPath(fsPath, relativeTo) {
    return path.isAbsolute(fsPath) ? fsPath : path.join(relativeTo, fsPath);
}
exports.default = ignoreFileHandler;
//# sourceMappingURL=ignoreFileHandler.js.map