"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const coc_nvim_1 = require("coc.nvim");
const path_1 = tslib_1.__importDefault(require("path"));
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const errorHandler_1 = require("./errorHandler");
const requirePkg_1 = require("./requirePkg");
const utils_1 = require("./utils");
/**
 * HOLD style parsers (for stylelint integration)
 */
const STYLE_PARSERS = ['postcss', 'css', 'less', 'scss'];
/**
 * Resolves the prettierconfig for the given file.
 *
 * @param filePath file's path
 */
function resolveConfig(filePath, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const localPrettier = (yield requirePkg_1.requireLocalPkg(path_1.default.dirname(filePath), 'prettier', { silent: true, ignoreBundled: true }));
            let prettierInstance = localPrettier;
            if (!prettierInstance && !options.onlyUseLocalVersion) {
                prettierInstance = require('prettier');
            }
            const config = yield prettierInstance.resolveConfig(filePath, options);
            return { config };
        }
        catch (error) {
            return { config: null, error };
        }
    });
}
/**
 * Define which config should be used.
 * If a prettierconfig exists, it returns itself.
 * It merges prettierconfig into vscode's config (editorconfig).
 * Priority:
 * - additionalConfig
 * - prettierConfig
 * - vscodeConfig
 * @param hasPrettierConfig a prettierconfig exists
 * @param additionalConfig config we really want to see in. (range)
 * @param prettierConfig prettier's file config
 * @param vscodeConfig our config
 */
function mergeConfig(hasPrettierConfig, additionalConfig, prettierConfig, vscodeConfig) {
    return hasPrettierConfig
        ? Object.assign({ parser: vscodeConfig.parser }, // always merge our inferred parser in
        prettierConfig, additionalConfig)
        : Object.assign(vscodeConfig, prettierConfig, additionalConfig);
}
/**
 * Format the given text with user's configuration.
 * @param text Text to format
 * @param path formatting file's path
 * @returns {string} formatted text
 */
function format(text, { languageId, uri }, customOptions) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let u = coc_nvim_1.Uri.parse(uri);
        const isUntitled = u.scheme == 'untitled';
        const fileName = u.fsPath;
        const vscodeConfig = utils_1.getConfig(u);
        const localOnly = vscodeConfig.onlyUseLocalVersion;
        const resolvedPrettier = yield utils_1.getPrettierInstance();
        if (!resolvedPrettier) {
            errorHandler_1.addToOutput(`Prettier module not found, prettier.onlyUseLocalVersion: ${vscodeConfig.onlyUseLocalVersion}`, 'Error');
        }
        let supportedLanguages = utils_1.allLanguages(resolvedPrettier);
        if (supportedLanguages.indexOf(languageId) == -1) {
            coc_nvim_1.workspace.showMessage(`${languageId} not supported by prettier`, 'error');
            return;
        }
        const dynamicParsers = utils_1.getParsersFromLanguageId(languageId, resolvedPrettier, isUntitled ? undefined : fileName);
        let useBundled = false;
        let parser;
        if (!dynamicParsers.length) {
            const bundledParsers = utils_1.getParsersFromLanguageId(languageId, require('prettier'), isUntitled ? undefined : fileName);
            parser = bundledParsers[0] || 'babylon';
            useBundled = true;
        }
        else if (dynamicParsers.includes(vscodeConfig.parser)) {
            // handle deprecated parser option (parser: "flow")
            parser = vscodeConfig.parser;
        }
        else {
            parser = dynamicParsers[0];
        }
        const doesParserSupportEslint = [
            'javascript',
            'javascriptreact',
            'typescript',
            'typescriptreact',
            'vue',
        ].includes(languageId);
        const { config: fileOptions, error } = yield resolveConfig(fileName, {
            editorconfig: true,
            onlyUseLocalVersion: localOnly,
            requireConfig: vscodeConfig.requireConfig,
        });
        const hasConfig = fileOptions != null;
        if (!hasConfig && vscodeConfig.requireConfig) {
            return text;
        }
        if (error) {
            errorHandler_1.addToOutput(`Failed to resolve config for ${fileName}. Falling back to the default config settings.`, 'Error');
        }
        const prettierOptions = mergeConfig(hasConfig, customOptions, fileOptions || {}, {
            printWidth: vscodeConfig.printWidth,
            tabWidth: vscodeConfig.tabWidth,
            singleQuote: vscodeConfig.singleQuote,
            jsxSingleQuote: vscodeConfig.jsxSingleQuote,
            trailingComma: vscodeConfig.trailingComma,
            bracketSpacing: vscodeConfig.bracketSpacing,
            jsxBracketSameLine: vscodeConfig.jsxBracketSameLine,
            parser,
            semi: vscodeConfig.semi,
            useTabs: vscodeConfig.useTabs,
            proseWrap: vscodeConfig.proseWrap,
            arrowParens: vscodeConfig.arrowParens,
        });
        if (vscodeConfig.tslintIntegration && parser === 'typescript') {
            return errorHandler_1.safeExecution(() => {
                const prettierTslint = requirePkg_1.requireLocalPkg(u.fsPath, 'prettier-tslint')
                    .format;
                // setUsedModule('prettier-tslint', 'Unknown', true)
                return prettierTslint({
                    text,
                    filePath: fileName,
                    fallbackPrettierOptions: prettierOptions,
                });
            }, text, fileName);
        }
        if (vscodeConfig.eslintIntegration && doesParserSupportEslint) {
            return errorHandler_1.safeExecution(() => {
                const prettierEslint = requirePkg_1.requireLocalPkg(u.fsPath, 'prettier-eslint');
                // setUsedModule('prettier-eslint', 'Unknown', true)
                return prettierEslint({
                    text,
                    filePath: fileName,
                    fallbackPrettierOptions: prettierOptions,
                });
            }, text, fileName);
        }
        if (vscodeConfig.stylelintIntegration && STYLE_PARSERS.includes(parser)) {
            const prettierStylelint = requirePkg_1.requireLocalPkg(u.fsPath, 'prettier-stylelint');
            return errorHandler_1.safeExecution(prettierStylelint.format({
                text,
                filePath: fileName,
                prettierOptions,
            }), text, fileName);
        }
        if (!doesParserSupportEslint && useBundled) {
            let bundledPrettier = require('prettier');
            return errorHandler_1.safeExecution(() => {
                const warningMessage = `prettier@${bundledPrettier.version} doesn't support ${languageId}. ` +
                    `Falling back to bundled prettier@${bundledPrettier.version}.`;
                errorHandler_1.addToOutput(warningMessage, 'Warning');
                // setUsedModule('prettier', bundledPrettier.version, true)
                return bundledPrettier.format(text, prettierOptions);
            }, text, fileName);
        }
        // setUsedModule('prettier', localPrettier.version, false)
        return errorHandler_1.safeExecution(() => resolvedPrettier.format(text, prettierOptions), text, fileName);
    });
}
exports.format = format;
function fullDocumentRange(document) {
    const lastLineId = document.lineCount - 1;
    let doc = coc_nvim_1.workspace.getDocument(document.uri);
    return vscode_languageserver_protocol_1.Range.create({ character: 0, line: 0 }, { character: doc.getline(lastLineId).length, line: lastLineId });
}
exports.fullDocumentRange = fullDocumentRange;
class PrettierEditProvider {
    constructor(_fileIsIgnored) {
        this._fileIsIgnored = _fileIsIgnored;
    }
    provideDocumentRangeFormattingEdits(document, range, _options, _token) {
        return this._provideEdits(document, {
            rangeStart: document.offsetAt(range.start),
            rangeEnd: document.offsetAt(range.end),
        });
    }
    provideDocumentFormattingEdits(document, _options, _token) {
        return this._provideEdits(document, {});
    }
    _provideEdits(document, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let fileName = coc_nvim_1.Uri.parse(document.uri).fsPath;
            if (!document.uri.startsWith('untitled') && this._fileIsIgnored(fileName)) {
                return Promise.resolve([]);
            }
            const code = yield format(document.getText(), document, options);
            const edits = [yield vscode_languageserver_protocol_1.TextEdit.replace(fullDocumentRange(document), code)];
            const { disableSuccessMessage } = utils_1.getConfig();
            if (edits && edits.length && !disableSuccessMessage) {
                coc_nvim_1.workspace.showMessage('Formatted by prettier');
            }
            errorHandler_1.addToOutput(`Formatted file: ${document.uri}`);
            errorHandler_1.addToOutput(`Prettier format edits: ${JSON.stringify(edits, null, 2)}`);
            return edits;
        });
    }
}
exports.default = PrettierEditProvider;
//# sourceMappingURL=PrettierEditProvider.js.map