"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.installTools = exports.installImpl = exports.installGoplay = exports.installGotests = exports.installGomodifytags = exports.checkGopls = exports.installGopls = exports.version = void 0;
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const coc_nvim_1 = require("coc.nvim");
const tools_1 = require("./utils/tools");
const checktag_1 = tslib_1.__importDefault(require("./utils/checktag"));
const binaries_1 = require("./binaries");
const versions_1 = require("./utils/versions");
async function version() {
    const v1 = await pkgVersion();
    const v2 = await goplsVersion() || 'unknown';
    coc_nvim_1.workspace.showMessage(`Version: coc-go ${v1}; gopls ${v2}`, 'more');
}
exports.version = version;
async function installGopls(client) {
    await tools_1.installGoBin(binaries_1.GOPLS, true);
    if (client.needsStop()) {
        await client.stop();
        client.restart();
    }
}
exports.installGopls = installGopls;
async function checkGopls(client, mode) {
    const [current, latest] = await Promise.all([
        goplsVersion(),
        checktag_1.default("golang/tools", /^gopls\//),
    ]);
    try {
        let install = false;
        switch (versions_1.compareVersions(latest, current)) {
            case 0:
                coc_nvim_1.workspace.showMessage(`[gopls] up-to-date: ${current}`, 'more');
                break;
            case 1:
                switch (mode) {
                    case 'install':
                        install = true;
                        break;
                    case 'ask':
                        install = await coc_nvim_1.workspace.showPrompt(`[gopls] Install update? ${current} => ${latest}`);
                        break;
                    case 'inform':
                        coc_nvim_1.workspace.showMessage(`[gopls] update available: ${current} => ${latest}`);
                        break;
                }
                break;
            case -1:
                coc_nvim_1.workspace.showMessage(`[gopls] current: ${current} | latest: ${latest}`, 'more');
                break;
        }
        if (install) {
            await installGopls(client);
        }
    }
    catch (e) {
        coc_nvim_1.workspace.showMessage(e.toString(), 'error');
    }
}
exports.checkGopls = checkGopls;
async function pkgVersion() {
    try {
        const pkgPath = path_1.default.resolve(__dirname, '..', 'package.json');
        const pkgContent = await fs_1.default.promises.readFile(pkgPath, 'utf8');
        return JSON.parse(pkgContent).version;
    }
    catch (err) {
        console.error(err);
    }
    return '';
}
async function goplsVersion() {
    const [, versionOut] = await tools_1.runGoTool("gopls", ["version"]);
    const m = versionOut.trim().match(/^golang\.org\/x\/tools\/gopls (v?\d+\.\d+\.\d+)/);
    if (m && versions_1.isValidVersion(m[1])) {
        return m[1].replace(/^v/, '');
    }
    return '';
}
async function installGomodifytags() {
    await tools_1.installGoBin(binaries_1.GOMODIFYTAGS, true);
}
exports.installGomodifytags = installGomodifytags;
async function installGotests() {
    await tools_1.installGoBin(binaries_1.GOTESTS, true);
}
exports.installGotests = installGotests;
async function installGoplay() {
    await tools_1.installGoBin(binaries_1.GOPLAY, true);
}
exports.installGoplay = installGoplay;
async function installImpl() {
    await tools_1.installGoBin(binaries_1.IMPL, true);
}
exports.installImpl = installImpl;
async function installTools() {
    for (const tool of binaries_1.TOOLS) {
        await tools_1.installGoBin(tool, true);
    }
}
exports.installTools = installTools;
//# sourceMappingURL=commands.js.map