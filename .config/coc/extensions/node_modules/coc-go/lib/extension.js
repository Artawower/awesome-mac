"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.activate = void 0;
const coc_nvim_1 = require("coc.nvim");
const child_process_1 = require("child_process");
const tools_1 = require("./utils/tools");
const commands_1 = require("./commands");
const modify_tags_1 = require("./utils/modify-tags");
const config_1 = require("./utils/config");
const editor_1 = require("./editor");
const binaries_1 = require("./binaries");
const tests_1 = require("./utils/tests");
const playground_1 = require("./utils/playground");
const impl_1 = require("./utils/impl");
const restartConfigs = [
    'go.goplsArgs',
    'go.goplsOptions',
    'go.goplsPath',
    'go.goplsUseDaemon',
];
async function activate(context) {
    config_1.setStoragePath(context.storagePath);
    if (config_1.getConfig().enable === false) {
        return;
    }
    registerGeneral(context);
    registerGopls(context);
    registerTest(context);
    registerTags(context);
    registerPlaygroud(context);
    registerGoImpl(context);
    registerTools(context);
}
exports.activate = activate;
async function registerGeneral(context) {
    context.subscriptions.push(coc_nvim_1.commands.registerCommand("go.version", () => commands_1.version()));
}
async function registerGopls(context) {
    const config = config_1.getConfig();
    const command = await goplsPath(config.goplsPath);
    if (!command) {
        return;
    }
    const args = config.goplsArgs ? [...config.goplsArgs] : [];
    if (config.goplsUseDaemon !== false && !args.find(arg => arg.startsWith('-remote'))) {
        // Use daemon by default
        args.push('-remote=auto');
    }
    // TMPDIR needs to be resetted, because its altered by coc.nvim, which breaks
    // the automatic deamon launching of gopls.
    // See: https://github.com/neoclide/coc.nvim/commit/bdd9a9e1401fe6fdd57a9bd078e3651ecf1e0202
    const tmpdir = await coc_nvim_1.workspace.nvim.eval('$TMPDIR');
    const server = () => {
        return new Promise(resolve => {
            resolve(child_process_1.spawn(command, args, {
                cwd: coc_nvim_1.workspace.cwd,
                env: Object.assign(Object.assign(Object.assign({}, process.env), { TMPDIR: tmpdir }), config.goplsEnv),
            }));
        });
    };
    // https://github.com/neoclide/coc.nvim/blob/master/src/language-client/client.ts#L684
    const clientOptions = {
        documentSelector: ['go', 'gomod'],
        initializationOptions: () => config_1.getConfig().goplsOptions,
        disableWorkspaceFolders: config.disable.workspaceFolders,
        disableDiagnostics: config.disable.diagnostics,
        disableCompletion: config.disable.completion,
    };
    const client = new coc_nvim_1.LanguageClient('go', 'gopls', server, clientOptions);
    if (config.checkForUpdates !== 'disabled' && !config.goplsPath) {
        await commands_1.checkGopls(client, config.checkForUpdates);
    }
    context.subscriptions.push(coc_nvim_1.services.registLanguageClient(client), 
    // restart gopls if options changed
    coc_nvim_1.workspace.onDidChangeConfiguration(async (e) => {
        if (restartConfigs.find(k => e.affectsConfiguration(k))) {
            await client.stop();
            client.restart();
        }
    }), coc_nvim_1.commands.registerCommand("go.install.gopls", () => commands_1.installGopls(client)));
}
async function goplsPath(goplsPath) {
    if (goplsPath) {
        if (!await tools_1.commandExists(goplsPath)) {
            coc_nvim_1.workspace.showMessage(`goplsPath is configured ("${goplsPath}"), but does not exist!`, 'error');
            return null;
        }
        return goplsPath;
    }
    if (!await tools_1.installGoBin(binaries_1.GOPLS)) {
        return;
    }
    return tools_1.goBinPath(binaries_1.GOPLS);
}
async function registerGoImpl(context) {
    context.subscriptions.push(coc_nvim_1.commands.registerCommand("go.install.impl", () => commands_1.installImpl()), coc_nvim_1.commands.registerCommand("go.impl.cursor", async () => impl_1.generateImplStubs(await editor_1.activeTextDocument())));
}
async function registerTest(context) {
    context.subscriptions.push(coc_nvim_1.commands.registerCommand("go.install.gotests", () => commands_1.installGotests()), coc_nvim_1.commands.registerCommand("go.test.generate.file", async () => tests_1.generateTestsAll(await editor_1.activeTextDocument())), coc_nvim_1.commands.registerCommand("go.test.generate.exported", async () => tests_1.generateTestsExported(await editor_1.activeTextDocument())), coc_nvim_1.commands.registerCommand("go.test.generate.function", async () => tests_1.generateTestsFunction(await editor_1.activeTextDocument())), coc_nvim_1.commands.registerCommand("go.test.toggle", async () => tests_1.toogleTests(await editor_1.activeTextDocument())));
}
async function registerTags(context) {
    context.subscriptions.push(coc_nvim_1.commands.registerCommand("go.install.gomodifytags", () => commands_1.installGomodifytags()), coc_nvim_1.commands.registerCommand("go.tags.add", async (...tags) => modify_tags_1.addTags(await editor_1.activeTextDocument(), { tags })), coc_nvim_1.commands.registerCommand("go.tags.add.line", async (...tags) => modify_tags_1.addTags(await editor_1.activeTextDocument(), { tags, selection: "line" })), coc_nvim_1.commands.registerCommand("go.tags.add.prompt", async () => modify_tags_1.addTags(await editor_1.activeTextDocument(), { prompt: true })), coc_nvim_1.commands.registerCommand("go.tags.remove", async (...tags) => modify_tags_1.removeTags(await editor_1.activeTextDocument(), { tags })), coc_nvim_1.commands.registerCommand("go.tags.remove.line", async (...tags) => modify_tags_1.removeTags(await editor_1.activeTextDocument(), { tags, selection: "line" })), coc_nvim_1.commands.registerCommand("go.tags.remove.prompt", async () => modify_tags_1.removeTags(await editor_1.activeTextDocument(), { prompt: true })), coc_nvim_1.commands.registerCommand("go.tags.clear", async () => modify_tags_1.clearTags(await editor_1.activeTextDocument())), coc_nvim_1.commands.registerCommand("go.tags.clear.line", async () => modify_tags_1.clearTags(await editor_1.activeTextDocument(), { selection: "line" })));
}
async function registerPlaygroud(context) {
    context.subscriptions.push(coc_nvim_1.commands.registerCommand("go.install.goplay", () => commands_1.installGoplay()), coc_nvim_1.commands.registerCommand("go.playground", async () => playground_1.openPlayground(await editor_1.activeTextDocument())));
}
async function registerTools(context) {
    context.subscriptions.push(coc_nvim_1.commands.registerCommand("go.install.tools", () => commands_1.installTools()));
}
//# sourceMappingURL=extension.js.map