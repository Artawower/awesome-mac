/**
 * @license Angular v10.0.14
 * Copyright Google LLC All Rights Reserved.
 * License: MIT
 */

let $deferred;
function define(modules, callback) {
  $deferred = {modules, callback};
}
module.exports = function(provided) {
  const ts = provided['typescript'];
  if (!ts) {
    throw new Error('Caller does not provide typescript module');
  }
  const results = {};
  const resolvedModules = $deferred.modules.map(m => {
    if (m === 'exports') {
      return results;
    }
    if (m === 'typescript' || m === 'typescript/lib/tsserverlibrary') {
      return ts;
    }
    return require(m);
  });
  $deferred.callback(...resolvedModules);
  return results;
};

define(['exports', 'os', 'typescript', 'fs', 'constants', 'stream', 'util', 'assert', 'path', 'typescript/lib/tsserverlibrary'], function (exports, os, ts, fs$2, constants, stream, util, assert, path, ts$1) { 'use strict';

    var os__default = 'default' in os ? os['default'] : os;
    var fs$2__default = 'default' in fs$2 ? fs$2['default'] : fs$2;
    constants = constants && Object.prototype.hasOwnProperty.call(constants, 'default') ? constants['default'] : constants;
    stream = stream && Object.prototype.hasOwnProperty.call(stream, 'default') ? stream['default'] : stream;
    util = util && Object.prototype.hasOwnProperty.call(util, 'default') ? util['default'] : util;
    assert = assert && Object.prototype.hasOwnProperty.call(assert, 'default') ? assert['default'] : assert;
    var path__default = 'default' in path ? path['default'] : path;

    /**
     * The default `FileSystem` that will always fail.
     *
     * This is a way of ensuring that the developer consciously chooses and
     * configures the `FileSystem` before using it; particularly important when
     * considering static functions like `absoluteFrom()` which rely on
     * the `FileSystem` under the hood.
     */
    class InvalidFileSystem {
        exists(path) {
            throw makeError();
        }
        readFile(path) {
            throw makeError();
        }
        readFileBuffer(path) {
            throw makeError();
        }
        writeFile(path, data, exclusive) {
            throw makeError();
        }
        removeFile(path) {
            throw makeError();
        }
        symlink(target, path) {
            throw makeError();
        }
        readdir(path) {
            throw makeError();
        }
        lstat(path) {
            throw makeError();
        }
        stat(path) {
            throw makeError();
        }
        pwd() {
            throw makeError();
        }
        chdir(path) {
            throw makeError();
        }
        extname(path) {
            throw makeError();
        }
        copyFile(from, to) {
            throw makeError();
        }
        moveFile(from, to) {
            throw makeError();
        }
        ensureDir(path) {
            throw makeError();
        }
        removeDeep(path) {
            throw makeError();
        }
        isCaseSensitive() {
            throw makeError();
        }
        resolve(...paths) {
            throw makeError();
        }
        dirname(file) {
            throw makeError();
        }
        join(basePath, ...paths) {
            throw makeError();
        }
        isRoot(path) {
            throw makeError();
        }
        isRooted(path) {
            throw makeError();
        }
        relative(from, to) {
            throw makeError();
        }
        basename(filePath, extension) {
            throw makeError();
        }
        realpath(filePath) {
            throw makeError();
        }
        getDefaultLibLocation() {
            throw makeError();
        }
        normalize(path) {
            throw makeError();
        }
    }
    function makeError() {
        return new Error('FileSystem has not been configured. Please call `setFileSystem()` before calling this method.');
    }

    const TS_DTS_JS_EXTENSION = /(?:\.d)?\.ts$|\.js$/;
    /**
     * Remove a .ts, .d.ts, or .js extension from a file name.
     */
    function stripExtension(path) {
        return path.replace(TS_DTS_JS_EXTENSION, '');
    }
    function getSourceFileOrError(program, fileName) {
        const sf = program.getSourceFile(fileName);
        if (sf === undefined) {
            throw new Error(`Program does not contain "${fileName}" - available files are ${program.getSourceFiles().map(sf => sf.fileName).join(', ')}`);
        }
        return sf;
    }

    let fs = new InvalidFileSystem();
    function setFileSystem(fileSystem) {
        fs = fileSystem;
    }
    /**
     * Convert the path `path` to an `AbsoluteFsPath`, throwing an error if it's not an absolute path.
     */
    function absoluteFrom(path) {
        if (!fs.isRooted(path)) {
            throw new Error(`Internal Error: absoluteFrom(${path}): path is not absolute`);
        }
        return fs.resolve(path);
    }
    /**
     * Extract an `AbsoluteFsPath` from a `ts.SourceFile`.
     */
    function absoluteFromSourceFile(sf) {
        return fs.resolve(sf.fileName);
    }
    /**
     * Static access to `dirname`.
     */
    function dirname(file) {
        return fs.dirname(file);
    }
    /**
     * Static access to `join`.
     */
    function join(basePath, ...paths) {
        return fs.join(basePath, ...paths);
    }
    /**
     * Static access to `resolve`s.
     */
    function resolve(basePath, ...paths) {
        return fs.resolve(basePath, ...paths);
    }
    /**
     * Static access to `isRooted`.
     */
    function isRooted(path) {
        return fs.isRooted(path);
    }
    /**
     * Static access to `relative`.
     */
    function relative(from, to) {
        return fs.relative(from, to);
    }
    /**
     * Returns true if the given path is locally relative.
     *
     * This is used to work out if the given path is relative (i.e. not absolute) but also is not
     * escaping the current directory.
     */
    function isLocalRelativePath(relativePath) {
        return !isRooted(relativePath) && !relativePath.startsWith('..');
    }
    /**
     * Converts a path to a form suitable for use as a relative module import specifier.
     *
     * In other words it adds the `./` to the path if it is locally relative.
     */
    function toRelativeImport(relativePath) {
        return isLocalRelativePath(relativePath) ? `./${relativePath}` : relativePath;
    }

    const LogicalProjectPath = {
        /**
         * Get the relative path between two `LogicalProjectPath`s.
         *
         * This will return a `PathSegment` which would be a valid module specifier to use in `from` when
         * importing from `to`.
         */
        relativePathBetween: function (from, to) {
            const relativePath = relative(dirname(resolve(from)), resolve(to));
            return toRelativeImport(relativePath);
        },
    };
    /**
     * A utility class which can translate absolute paths to source files into logical paths in
     * TypeScript's logical file system, based on the root directories of the project.
     */
    class LogicalFileSystem {
        constructor(rootDirs, compilerHost) {
            this.compilerHost = compilerHost;
            /**
             * A cache of file paths to project paths, because computation of these paths is slightly
             * expensive.
             */
            this.cache = new Map();
            // Make a copy and sort it by length in reverse order (longest first). This speeds up lookups,
            // since there's no need to keep going through the array once a match is found.
            this.rootDirs = rootDirs.concat([]).sort((a, b) => b.length - a.length);
            this.canonicalRootDirs =
                this.rootDirs.map(dir => this.compilerHost.getCanonicalFileName(dir));
        }
        /**
         * Get the logical path in the project of a `ts.SourceFile`.
         *
         * This method is provided as a convenient alternative to calling
         * `logicalPathOfFile(absoluteFromSourceFile(sf))`.
         */
        logicalPathOfSf(sf) {
            return this.logicalPathOfFile(absoluteFrom(sf.fileName));
        }
        /**
         * Get the logical path in the project of a source file.
         *
         * @returns A `LogicalProjectPath` to the source file, or `null` if the source file is not in any
         * of the TS project's root directories.
         */
        logicalPathOfFile(physicalFile) {
            const canonicalFilePath = this.compilerHost.getCanonicalFileName(physicalFile);
            if (!this.cache.has(canonicalFilePath)) {
                let logicalFile = null;
                for (let i = 0; i < this.rootDirs.length; i++) {
                    const rootDir = this.rootDirs[i];
                    const canonicalRootDir = this.canonicalRootDirs[i];
                    if (isWithinBasePath(canonicalRootDir, canonicalFilePath)) {
                        // Note that we match against canonical paths but then create the logical path from
                        // original paths.
                        logicalFile = this.createLogicalProjectPath(physicalFile, rootDir);
                        // The logical project does not include any special "node_modules" nested directories.
                        if (logicalFile.indexOf('/node_modules/') !== -1) {
                            logicalFile = null;
                        }
                        else {
                            break;
                        }
                    }
                }
                this.cache.set(canonicalFilePath, logicalFile);
            }
            return this.cache.get(canonicalFilePath);
        }
        createLogicalProjectPath(file, rootDir) {
            const logicalPath = stripExtension(file.substr(rootDir.length));
            return (logicalPath.startsWith('/') ? logicalPath : '/' + logicalPath);
        }
    }
    /**
     * Is the `path` a descendant of the `base`?
     * E.g. `foo/bar/zee` is within `foo/bar` but not within `foo/car`.
     */
    function isWithinBasePath(base, path) {
        return isLocalRelativePath(relative(base, path));
    }

    // simple mutable assign
    function assign () {
      const args = [].slice.call(arguments).filter(i => i);
      const dest = args.shift();
      args.forEach(src => {
        Object.keys(src).forEach(key => {
          dest[key] = src[key];
        });
      });

      return dest
    }

    var assign_1 = assign;

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var fromCallback = function (fn) {
      return Object.defineProperty(function () {
        if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments);
        else {
          return new Promise((resolve, reject) => {
            arguments[arguments.length] = (err, res) => {
              if (err) return reject(err)
              resolve(res);
            };
            arguments.length++;
            fn.apply(this, arguments);
          })
        }
      }, 'name', { value: fn.name })
    };

    var fromPromise = function (fn) {
      return Object.defineProperty(function () {
        const cb = arguments[arguments.length - 1];
        if (typeof cb !== 'function') return fn.apply(this, arguments)
        else fn.apply(this, arguments).then(r => cb(null, r), cb);
      }, 'name', { value: fn.name })
    };

    var universalify = {
    	fromCallback: fromCallback,
    	fromPromise: fromPromise
    };

    var origCwd = process.cwd;
    var cwd = null;

    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;

    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd
    };
    try {
      process.cwd();
    } catch (er) {}

    var chdir = process.chdir;
    process.chdir = function(d) {
      cwd = null;
      chdir.call(process, d);
    };

    var polyfills = patch;

    function patch (fs) {
      // (re-)implement some things that are known busted or missing.

      // lchmod, broken prior to 0.6.2
      // back-port the fix here.
      if (constants.hasOwnProperty('O_SYMLINK') &&
          process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs);
      }

      // lutimes implementation, or no-op
      if (!fs.lutimes) {
        patchLutimes(fs);
      }

      // https://github.com/isaacs/node-graceful-fs/issues/4
      // Chown should not fail on einval or eperm if non-root.
      // It should not fail on enosys ever, as this just indicates
      // that a fs doesn't support the intended operation.

      fs.chown = chownFix(fs.chown);
      fs.fchown = chownFix(fs.fchown);
      fs.lchown = chownFix(fs.lchown);

      fs.chmod = chmodFix(fs.chmod);
      fs.fchmod = chmodFix(fs.fchmod);
      fs.lchmod = chmodFix(fs.lchmod);

      fs.chownSync = chownFixSync(fs.chownSync);
      fs.fchownSync = chownFixSync(fs.fchownSync);
      fs.lchownSync = chownFixSync(fs.lchownSync);

      fs.chmodSync = chmodFixSync(fs.chmodSync);
      fs.fchmodSync = chmodFixSync(fs.fchmodSync);
      fs.lchmodSync = chmodFixSync(fs.lchmodSync);

      fs.stat = statFix(fs.stat);
      fs.fstat = statFix(fs.fstat);
      fs.lstat = statFix(fs.lstat);

      fs.statSync = statFixSync(fs.statSync);
      fs.fstatSync = statFixSync(fs.fstatSync);
      fs.lstatSync = statFixSync(fs.lstatSync);

      // if lchmod/lchown do not exist, then make them no-ops
      if (!fs.lchmod) {
        fs.lchmod = function (path, mode, cb) {
          if (cb) process.nextTick(cb);
        };
        fs.lchmodSync = function () {};
      }
      if (!fs.lchown) {
        fs.lchown = function (path, uid, gid, cb) {
          if (cb) process.nextTick(cb);
        };
        fs.lchownSync = function () {};
      }

      // on Windows, A/V software can lock the directory, causing this
      // to fail with an EACCES or EPERM if the directory contains newly
      // created files.  Try again on failure, for up to 60 seconds.

      // Set the timeout this long because some Windows Anti-Virus, such as Parity
      // bit9, may lock files for up to a minute, causing npm package install
      // failures. Also, take care to yield the scheduler. Windows scheduling gives
      // CPU to a busy looping process, which can cause the program causing the lock
      // contention to be starved of CPU by node, so the contention doesn't resolve.
      if (platform === "win32") {
        fs.rename = (function (fs$rename) { return function (from, to, cb) {
          var start = Date.now();
          var backoff = 0;
          fs$rename(from, to, function CB (er) {
            if (er
                && (er.code === "EACCES" || er.code === "EPERM")
                && Date.now() - start < 60000) {
              setTimeout(function() {
                fs.stat(to, function (stater, st) {
                  if (stater && stater.code === "ENOENT")
                    fs$rename(from, to, CB);
                  else
                    cb(er);
                });
              }, backoff);
              if (backoff < 100)
                backoff += 10;
              return;
            }
            if (cb) cb(er);
          });
        }})(fs.rename);
      }

      // if read() returns EAGAIN, then just try it again.
      fs.read = (function (fs$read) {
        function read (fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === 'function') {
            var eagCounter = 0;
            callback = function (er, _, __) {
              if (er && er.code === 'EAGAIN' && eagCounter < 10) {
                eagCounter ++;
                return fs$read.call(fs, fd, buffer, offset, length, position, callback)
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs, fd, buffer, offset, length, position, callback)
        }

        // This ensures `util.promisify` works as it does for native `fs.read`.
        read.__proto__ = fs$read;
        return read
      })(fs.read);

      fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {
        var eagCounter = 0;
        while (true) {
          try {
            return fs$readSync.call(fs, fd, buffer, offset, length, position)
          } catch (er) {
            if (er.code === 'EAGAIN' && eagCounter < 10) {
              eagCounter ++;
              continue
            }
            throw er
          }
        }
      }})(fs.readSync);

      function patchLchmod (fs) {
        fs.lchmod = function (path, mode, callback) {
          fs.open( path
                 , constants.O_WRONLY | constants.O_SYMLINK
                 , mode
                 , function (err, fd) {
            if (err) {
              if (callback) callback(err);
              return
            }
            // prefer to return the chmod error, if one occurs,
            // but still try to close, and report closing errors if they occur.
            fs.fchmod(fd, mode, function (err) {
              fs.close(fd, function(err2) {
                if (callback) callback(err || err2);
              });
            });
          });
        };

        fs.lchmodSync = function (path, mode) {
          var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);

          // prefer to return the chmod error, if one occurs,
          // but still try to close, and report closing errors if they occur.
          var threw = true;
          var ret;
          try {
            ret = fs.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs.closeSync(fd);
              } catch (er) {}
            } else {
              fs.closeSync(fd);
            }
          }
          return ret
        };
      }

      function patchLutimes (fs) {
        if (constants.hasOwnProperty("O_SYMLINK")) {
          fs.lutimes = function (path, at, mt, cb) {
            fs.open(path, constants.O_SYMLINK, function (er, fd) {
              if (er) {
                if (cb) cb(er);
                return
              }
              fs.futimes(fd, at, mt, function (er) {
                fs.close(fd, function (er2) {
                  if (cb) cb(er || er2);
                });
              });
            });
          };

          fs.lutimesSync = function (path, at, mt) {
            var fd = fs.openSync(path, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs.closeSync(fd);
                } catch (er) {}
              } else {
                fs.closeSync(fd);
              }
            }
            return ret
          };

        } else {
          fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb); };
          fs.lutimesSync = function () {};
        }
      }

      function chmodFix (orig) {
        if (!orig) return orig
        return function (target, mode, cb) {
          return orig.call(fs, target, mode, function (er) {
            if (chownErOk(er)) er = null;
            if (cb) cb.apply(this, arguments);
          })
        }
      }

      function chmodFixSync (orig) {
        if (!orig) return orig
        return function (target, mode) {
          try {
            return orig.call(fs, target, mode)
          } catch (er) {
            if (!chownErOk(er)) throw er
          }
        }
      }


      function chownFix (orig) {
        if (!orig) return orig
        return function (target, uid, gid, cb) {
          return orig.call(fs, target, uid, gid, function (er) {
            if (chownErOk(er)) er = null;
            if (cb) cb.apply(this, arguments);
          })
        }
      }

      function chownFixSync (orig) {
        if (!orig) return orig
        return function (target, uid, gid) {
          try {
            return orig.call(fs, target, uid, gid)
          } catch (er) {
            if (!chownErOk(er)) throw er
          }
        }
      }

      function statFix (orig) {
        if (!orig) return orig
        // Older versions of Node erroneously returned signed integers for
        // uid + gid.
        return function (target, options, cb) {
          if (typeof options === 'function') {
            cb = options;
            options = null;
          }
          function callback (er, stats) {
            if (stats) {
              if (stats.uid < 0) stats.uid += 0x100000000;
              if (stats.gid < 0) stats.gid += 0x100000000;
            }
            if (cb) cb.apply(this, arguments);
          }
          return options ? orig.call(fs, target, options, callback)
            : orig.call(fs, target, callback)
        }
      }

      function statFixSync (orig) {
        if (!orig) return orig
        // Older versions of Node erroneously returned signed integers for
        // uid + gid.
        return function (target, options) {
          var stats = options ? orig.call(fs, target, options)
            : orig.call(fs, target);
          if (stats.uid < 0) stats.uid += 0x100000000;
          if (stats.gid < 0) stats.gid += 0x100000000;
          return stats;
        }
      }

      // ENOSYS means that the fs doesn't support the op. Just ignore
      // that, because it doesn't matter.
      //
      // if there's no getuid, or if getuid() is something other
      // than 0, and the error is EINVAL or EPERM, then just ignore
      // it.
      //
      // This specific case is a silent failure in cp, install, tar,
      // and most other unix tools that manage permissions.
      //
      // When running as root, or if other types of errors are
      // encountered, then it's strict.
      function chownErOk (er) {
        if (!er)
          return true

        if (er.code === "ENOSYS")
          return true

        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true
        }

        return false
      }
    }

    var Stream = stream.Stream;

    var legacyStreams = legacy;

    function legacy (fs) {
      return {
        ReadStream: ReadStream,
        WriteStream: WriteStream
      }

      function ReadStream (path, options) {
        if (!(this instanceof ReadStream)) return new ReadStream(path, options);

        Stream.call(this);

        var self = this;

        this.path = path;
        this.fd = null;
        this.readable = true;
        this.paused = false;

        this.flags = 'r';
        this.mode = 438; /*=0666*/
        this.bufferSize = 64 * 1024;

        options = options || {};

        // Mixin options into this
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }

        if (this.encoding) this.setEncoding(this.encoding);

        if (this.start !== undefined) {
          if ('number' !== typeof this.start) {
            throw TypeError('start must be a Number');
          }
          if (this.end === undefined) {
            this.end = Infinity;
          } else if ('number' !== typeof this.end) {
            throw TypeError('end must be a Number');
          }

          if (this.start > this.end) {
            throw new Error('start must be <= end');
          }

          this.pos = this.start;
        }

        if (this.fd !== null) {
          process.nextTick(function() {
            self._read();
          });
          return;
        }

        fs.open(this.path, this.flags, this.mode, function (err, fd) {
          if (err) {
            self.emit('error', err);
            self.readable = false;
            return;
          }

          self.fd = fd;
          self.emit('open', fd);
          self._read();
        });
      }

      function WriteStream (path, options) {
        if (!(this instanceof WriteStream)) return new WriteStream(path, options);

        Stream.call(this);

        this.path = path;
        this.fd = null;
        this.writable = true;

        this.flags = 'w';
        this.encoding = 'binary';
        this.mode = 438; /*=0666*/
        this.bytesWritten = 0;

        options = options || {};

        // Mixin options into this
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }

        if (this.start !== undefined) {
          if ('number' !== typeof this.start) {
            throw TypeError('start must be a Number');
          }
          if (this.start < 0) {
            throw new Error('start must be >= zero');
          }

          this.pos = this.start;
        }

        this.busy = false;
        this._queue = [];

        if (this.fd === null) {
          this._open = fs.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
          this.flush();
        }
      }
    }

    var clone_1 = clone;

    function clone (obj) {
      if (obj === null || typeof obj !== 'object')
        return obj

      if (obj instanceof Object)
        var copy = { __proto__: obj.__proto__ };
      else
        var copy = Object.create(null);

      Object.getOwnPropertyNames(obj).forEach(function (key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });

      return copy
    }

    var gracefulFs = createCommonjsModule(function (module) {
    /* istanbul ignore next - node 0.x polyfill */
    var gracefulQueue;
    var previousSymbol;

    /* istanbul ignore else - node 0.x polyfill */
    if (typeof Symbol === 'function' && typeof Symbol.for === 'function') {
      gracefulQueue = Symbol.for('graceful-fs.queue');
      // This is used in testing by future versions
      previousSymbol = Symbol.for('graceful-fs.previous');
    } else {
      gracefulQueue = '___graceful-fs.queue';
      previousSymbol = '___graceful-fs.previous';
    }

    function noop () {}

    var debug = noop;
    if (util.debuglog)
      debug = util.debuglog('gfs4');
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ''))
      debug = function() {
        var m = util.format.apply(util, arguments);
        m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ');
        console.error(m);
      };

    // Once time initialization
    if (!global[gracefulQueue]) {
      // This queue can be shared by multiple loaded instances
      var queue = [];
      Object.defineProperty(global, gracefulQueue, {
        get: function() {
          return queue
        }
      });

      // Patch fs.close/closeSync to shared queue version, because we need
      // to retry() whenever a close happens *anywhere* in the program.
      // This is essential when multiple graceful-fs instances are
      // in play at the same time.
      fs$2__default.close = (function (fs$close) {
        function close (fd, cb) {
          return fs$close.call(fs$2__default, fd, function (err) {
            // This function uses the graceful-fs shared queue
            if (!err) {
              retry();
            }

            if (typeof cb === 'function')
              cb.apply(this, arguments);
          })
        }

        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close
      })(fs$2__default.close);

      fs$2__default.closeSync = (function (fs$closeSync) {
        function closeSync (fd) {
          // This function uses the graceful-fs shared queue
          fs$closeSync.apply(fs$2__default, arguments);
          retry();
        }

        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync
      })(fs$2__default.closeSync);

      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
        process.on('exit', function() {
          debug(global[gracefulQueue]);
          assert.equal(global[gracefulQueue].length, 0);
        });
      }
    }

    module.exports = patch(clone_1(fs$2__default));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs$2__default.__patched) {
        module.exports = patch(fs$2__default);
        fs$2__default.__patched = true;
    }

    function patch (fs) {
      // Everything that references the open() function needs to be in here
      polyfills(fs);
      fs.gracefulify = patch;

      fs.createReadStream = createReadStream;
      fs.createWriteStream = createWriteStream;
      var fs$readFile = fs.readFile;
      fs.readFile = readFile;
      function readFile (path, options, cb) {
        if (typeof options === 'function')
          cb = options, options = null;

        return go$readFile(path, options, cb)

        function go$readFile (path, options, cb) {
          return fs$readFile(path, options, function (err) {
            if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
              enqueue([go$readFile, [path, options, cb]]);
            else {
              if (typeof cb === 'function')
                cb.apply(this, arguments);
              retry();
            }
          })
        }
      }

      var fs$writeFile = fs.writeFile;
      fs.writeFile = writeFile;
      function writeFile (path, data, options, cb) {
        if (typeof options === 'function')
          cb = options, options = null;

        return go$writeFile(path, data, options, cb)

        function go$writeFile (path, data, options, cb) {
          return fs$writeFile(path, data, options, function (err) {
            if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
              enqueue([go$writeFile, [path, data, options, cb]]);
            else {
              if (typeof cb === 'function')
                cb.apply(this, arguments);
              retry();
            }
          })
        }
      }

      var fs$appendFile = fs.appendFile;
      if (fs$appendFile)
        fs.appendFile = appendFile;
      function appendFile (path, data, options, cb) {
        if (typeof options === 'function')
          cb = options, options = null;

        return go$appendFile(path, data, options, cb)

        function go$appendFile (path, data, options, cb) {
          return fs$appendFile(path, data, options, function (err) {
            if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
              enqueue([go$appendFile, [path, data, options, cb]]);
            else {
              if (typeof cb === 'function')
                cb.apply(this, arguments);
              retry();
            }
          })
        }
      }

      var fs$readdir = fs.readdir;
      fs.readdir = readdir;
      function readdir (path, options, cb) {
        var args = [path];
        if (typeof options !== 'function') {
          args.push(options);
        } else {
          cb = options;
        }
        args.push(go$readdir$cb);

        return go$readdir(args)

        function go$readdir$cb (err, files) {
          if (files && files.sort)
            files.sort();

          if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
            enqueue([go$readdir, [args]]);

          else {
            if (typeof cb === 'function')
              cb.apply(this, arguments);
            retry();
          }
        }
      }

      function go$readdir (args) {
        return fs$readdir.apply(fs, args)
      }

      if (process.version.substr(0, 4) === 'v0.8') {
        var legStreams = legacyStreams(fs);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }

      var fs$ReadStream = fs.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }

      var fs$WriteStream = fs.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }

      Object.defineProperty(fs, 'ReadStream', {
        get: function () {
          return ReadStream
        },
        set: function (val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs, 'WriteStream', {
        get: function () {
          return WriteStream
        },
        set: function (val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });

      // legacy names
      Object.defineProperty(fs, 'FileReadStream', {
        get: function () {
          return ReadStream
        },
        set: function (val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs, 'FileWriteStream', {
        get: function () {
          return WriteStream
        },
        set: function (val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });

      function ReadStream (path, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
      }

      function ReadStream$open () {
        var that = this;
        open(that.path, that.flags, that.mode, function (err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();

            that.emit('error', err);
          } else {
            that.fd = fd;
            that.emit('open', fd);
            that.read();
          }
        });
      }

      function WriteStream (path, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
      }

      function WriteStream$open () {
        var that = this;
        open(that.path, that.flags, that.mode, function (err, fd) {
          if (err) {
            that.destroy();
            that.emit('error', err);
          } else {
            that.fd = fd;
            that.emit('open', fd);
          }
        });
      }

      function createReadStream (path, options) {
        return new fs.ReadStream(path, options)
      }

      function createWriteStream (path, options) {
        return new fs.WriteStream(path, options)
      }

      var fs$open = fs.open;
      fs.open = open;
      function open (path, flags, mode, cb) {
        if (typeof mode === 'function')
          cb = mode, mode = null;

        return go$open(path, flags, mode, cb)

        function go$open (path, flags, mode, cb) {
          return fs$open(path, flags, mode, function (err, fd) {
            if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
              enqueue([go$open, [path, flags, mode, cb]]);
            else {
              if (typeof cb === 'function')
                cb.apply(this, arguments);
              retry();
            }
          })
        }
      }

      return fs
    }

    function enqueue (elem) {
      debug('ENQUEUE', elem[0].name, elem[1]);
      global[gracefulQueue].push(elem);
    }

    function retry () {
      var elem = global[gracefulQueue].shift();
      if (elem) {
        debug('RETRY', elem[0].name, elem[1]);
        elem[0].apply(null, elem[1]);
      }
    }
    });

    var fs_1 = createCommonjsModule(function (module, exports) {
    // This is adapted from https://github.com/normalize/mz
    // Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors
    const u = universalify.fromCallback;


    const api = [
      'access',
      'appendFile',
      'chmod',
      'chown',
      'close',
      'fchmod',
      'fchown',
      'fdatasync',
      'fstat',
      'fsync',
      'ftruncate',
      'futimes',
      'lchown',
      'link',
      'lstat',
      'mkdir',
      'open',
      'readFile',
      'readdir',
      'readlink',
      'realpath',
      'rename',
      'rmdir',
      'stat',
      'symlink',
      'truncate',
      'unlink',
      'utimes',
      'writeFile'
    ];
    // Add methods that are only in some Node.js versions
    // fs.copyFile was added in Node.js v8.5.0
    typeof gracefulFs.copyFile === 'function' && api.push('copyFile');
    // fs.mkdtemp() was added in Node.js v5.10.0
    typeof gracefulFs.mkdtemp === 'function' && api.push('mkdtemp');

    // Export all keys:
    Object.keys(gracefulFs).forEach(key => {
      exports[key] = gracefulFs[key];
    });

    // Universalify async methods:
    api.forEach(method => {
      exports[method] = u(gracefulFs[method]);
    });

    // We differ from mz/fs in that we still ship the old, broken, fs.exists()
    // since we are a drop-in replacement for the native module
    exports.exists = function (filename, callback) {
      if (typeof callback === 'function') {
        return gracefulFs.exists(filename, callback)
      }
      return new Promise(resolve => {
        return gracefulFs.exists(filename, resolve)
      })
    };

    // fs.read() & fs.write need special treatment due to multiple callback args

    exports.read = function (fd, buffer, offset, length, position, callback) {
      if (typeof callback === 'function') {
        return gracefulFs.read(fd, buffer, offset, length, position, callback)
      }
      return new Promise((resolve, reject) => {
        gracefulFs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {
          if (err) return reject(err)
          resolve({ bytesRead, buffer });
        });
      })
    };

    // Function signature can be
    // fs.write(fd, buffer[, offset[, length[, position]]], callback)
    // OR
    // fs.write(fd, string[, position[, encoding]], callback)
    // so we need to handle both cases
    exports.write = function (fd, buffer, a, b, c, callback) {
      if (typeof arguments[arguments.length - 1] === 'function') {
        return gracefulFs.write(fd, buffer, a, b, c, callback)
      }

      // Check for old, depricated fs.write(fd, string[, position[, encoding]], callback)
      if (typeof buffer === 'string') {
        return new Promise((resolve, reject) => {
          gracefulFs.write(fd, buffer, a, b, (err, bytesWritten, buffer) => {
            if (err) return reject(err)
            resolve({ bytesWritten, buffer });
          });
        })
      }

      return new Promise((resolve, reject) => {
        gracefulFs.write(fd, buffer, a, b, c, (err, bytesWritten, buffer) => {
          if (err) return reject(err)
          resolve({ bytesWritten, buffer });
        });
      })
    };
    });
    var fs_2 = fs_1.exists;
    var fs_3 = fs_1.read;
    var fs_4 = fs_1.write;

    // HFS, ext{2,3}, FAT do not, Node.js v0.10 does not
    function hasMillisResSync () {
      let tmpfile = path__default.join('millis-test-sync' + Date.now().toString() + Math.random().toString().slice(2));
      tmpfile = path__default.join(os__default.tmpdir(), tmpfile);

      // 550 millis past UNIX epoch
      const d = new Date(1435410243862);
      gracefulFs.writeFileSync(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141');
      const fd = gracefulFs.openSync(tmpfile, 'r+');
      gracefulFs.futimesSync(fd, d, d);
      gracefulFs.closeSync(fd);
      return gracefulFs.statSync(tmpfile).mtime > 1435410243000
    }

    function hasMillisRes (callback) {
      let tmpfile = path__default.join('millis-test' + Date.now().toString() + Math.random().toString().slice(2));
      tmpfile = path__default.join(os__default.tmpdir(), tmpfile);

      // 550 millis past UNIX epoch
      const d = new Date(1435410243862);
      gracefulFs.writeFile(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141', err => {
        if (err) return callback(err)
        gracefulFs.open(tmpfile, 'r+', (err, fd) => {
          if (err) return callback(err)
          gracefulFs.futimes(fd, d, d, err => {
            if (err) return callback(err)
            gracefulFs.close(fd, err => {
              if (err) return callback(err)
              gracefulFs.stat(tmpfile, (err, stats) => {
                if (err) return callback(err)
                callback(null, stats.mtime > 1435410243000);
              });
            });
          });
        });
      });
    }

    function timeRemoveMillis (timestamp) {
      if (typeof timestamp === 'number') {
        return Math.floor(timestamp / 1000) * 1000
      } else if (timestamp instanceof Date) {
        return new Date(Math.floor(timestamp.getTime() / 1000) * 1000)
      } else {
        throw new Error('fs-extra: timeRemoveMillis() unknown parameter type')
      }
    }

    function utimesMillis (path, atime, mtime, callback) {
      // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)
      gracefulFs.open(path, 'r+', (err, fd) => {
        if (err) return callback(err)
        gracefulFs.futimes(fd, atime, mtime, futimesErr => {
          gracefulFs.close(fd, closeErr => {
            if (callback) callback(futimesErr || closeErr);
          });
        });
      });
    }

    var utimes = {
      hasMillisRes,
      hasMillisResSync,
      timeRemoveMillis,
      utimesMillis
    };

    // imported from ncp (this is temporary, will rewrite)





    function ncp (source, dest, options, callback) {
      if (!callback) {
        callback = options;
        options = {};
      }

      var basePath = process.cwd();
      var currentPath = path__default.resolve(basePath, source);
      var targetPath = path__default.resolve(basePath, dest);

      var filter = options.filter;
      var transform = options.transform;
      var overwrite = options.overwrite;
      // If overwrite is undefined, use clobber, otherwise default to true:
      if (overwrite === undefined) overwrite = options.clobber;
      if (overwrite === undefined) overwrite = true;
      var errorOnExist = options.errorOnExist;
      var dereference = options.dereference;
      var preserveTimestamps = options.preserveTimestamps === true;

      var started = 0;
      var finished = 0;
      var running = 0;

      var errored = false;

      startCopy(currentPath);

      function startCopy (source) {
        started++;
        if (filter) {
          if (filter instanceof RegExp) {
            console.warn('Warning: fs-extra: Passing a RegExp filter is deprecated, use a function');
            if (!filter.test(source)) {
              return doneOne(true)
            }
          } else if (typeof filter === 'function') {
            if (!filter(source, dest)) {
              return doneOne(true)
            }
          }
        }
        return getStats(source)
      }

      function getStats (source) {
        var stat = dereference ? gracefulFs.stat : gracefulFs.lstat;
        running++;
        stat(source, function (err, stats) {
          if (err) return onError(err)

          // We need to get the mode from the stats object and preserve it.
          var item = {
            name: source,
            mode: stats.mode,
            mtime: stats.mtime, // modified time
            atime: stats.atime, // access time
            stats: stats // temporary
          };

          if (stats.isDirectory()) {
            return onDir(item)
          } else if (stats.isFile() || stats.isCharacterDevice() || stats.isBlockDevice()) {
            return onFile(item)
          } else if (stats.isSymbolicLink()) {
            // Symlinks don't really need to know about the mode.
            return onLink(source)
          }
        });
      }

      function onFile (file) {
        var target = file.name.replace(currentPath, targetPath.replace('$', '$$$$')); // escapes '$' with '$$'
        isWritable(target, function (writable) {
          if (writable) {
            copyFile(file, target);
          } else {
            if (overwrite) {
              rmFile(target, function () {
                copyFile(file, target);
              });
            } else if (errorOnExist) {
              onError(new Error(target + ' already exists'));
            } else {
              doneOne();
            }
          }
        });
      }

      function copyFile (file, target) {
        var readStream = gracefulFs.createReadStream(file.name);
        var writeStream = gracefulFs.createWriteStream(target, { mode: file.mode });

        readStream.on('error', onError);
        writeStream.on('error', onError);

        if (transform) {
          transform(readStream, writeStream, file);
        } else {
          writeStream.on('open', function () {
            readStream.pipe(writeStream);
          });
        }

        writeStream.once('close', function () {
          gracefulFs.chmod(target, file.mode, function (err) {
            if (err) return onError(err)
            if (preserveTimestamps) {
              utimes.utimesMillis(target, file.atime, file.mtime, function (err) {
                if (err) return onError(err)
                return doneOne()
              });
            } else {
              doneOne();
            }
          });
        });
      }

      function rmFile (file, done) {
        gracefulFs.unlink(file, function (err) {
          if (err) return onError(err)
          return done()
        });
      }

      function onDir (dir) {
        var target = dir.name.replace(currentPath, targetPath.replace('$', '$$$$')); // escapes '$' with '$$'
        isWritable(target, function (writable) {
          if (writable) {
            return mkDir(dir, target)
          }
          copyDir(dir.name);
        });
      }

      function mkDir (dir, target) {
        gracefulFs.mkdir(target, dir.mode, function (err) {
          if (err) return onError(err)
          // despite setting mode in fs.mkdir, doesn't seem to work
          // so we set it here.
          gracefulFs.chmod(target, dir.mode, function (err) {
            if (err) return onError(err)
            copyDir(dir.name);
          });
        });
      }

      function copyDir (dir) {
        gracefulFs.readdir(dir, function (err, items) {
          if (err) return onError(err)
          items.forEach(function (item) {
            startCopy(path__default.join(dir, item));
          });
          return doneOne()
        });
      }

      function onLink (link) {
        var target = link.replace(currentPath, targetPath);
        gracefulFs.readlink(link, function (err, resolvedPath) {
          if (err) return onError(err)
          checkLink(resolvedPath, target);
        });
      }

      function checkLink (resolvedPath, target) {
        if (dereference) {
          resolvedPath = path__default.resolve(basePath, resolvedPath);
        }
        isWritable(target, function (writable) {
          if (writable) {
            return makeLink(resolvedPath, target)
          }
          gracefulFs.readlink(target, function (err, targetDest) {
            if (err) return onError(err)

            if (dereference) {
              targetDest = path__default.resolve(basePath, targetDest);
            }
            if (targetDest === resolvedPath) {
              return doneOne()
            }
            return rmFile(target, function () {
              makeLink(resolvedPath, target);
            })
          });
        });
      }

      function makeLink (linkPath, target) {
        gracefulFs.symlink(linkPath, target, function (err) {
          if (err) return onError(err)
          return doneOne()
        });
      }

      function isWritable (path, done) {
        gracefulFs.lstat(path, function (err) {
          if (err) {
            if (err.code === 'ENOENT') return done(true)
            return done(false)
          }
          return done(false)
        });
      }

      function onError (err) {
        // ensure callback is defined & called only once:
        if (!errored && callback !== undefined) {
          errored = true;
          return callback(err)
        }
      }

      function doneOne (skipped) {
        if (!skipped) running--;
        finished++;
        if ((started === finished) && (running === 0)) {
          if (callback !== undefined) {
            return callback(null)
          }
        }
      }
    }

    var ncp_1 = ncp;

    // get drive on windows
    function getRootPath (p) {
      p = path__default.normalize(path__default.resolve(p)).split(path__default.sep);
      if (p.length > 0) return p[0]
      return null
    }

    // http://stackoverflow.com/a/62888/10333 contains more accurate
    // TODO: expand to include the rest
    const INVALID_PATH_CHARS = /[<>:"|?*]/;

    function invalidWin32Path (p) {
      const rp = getRootPath(p);
      p = p.replace(rp, '');
      return INVALID_PATH_CHARS.test(p)
    }

    var win32 = {
      getRootPath,
      invalidWin32Path
    };

    const invalidWin32Path$1 = win32.invalidWin32Path;

    const o777 = parseInt('0777', 8);

    function mkdirs (p, opts, callback, made) {
      if (typeof opts === 'function') {
        callback = opts;
        opts = {};
      } else if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
      }

      if (process.platform === 'win32' && invalidWin32Path$1(p)) {
        const errInval = new Error(p + ' contains invalid WIN32 path characters.');
        errInval.code = 'EINVAL';
        return callback(errInval)
      }

      let mode = opts.mode;
      const xfs = opts.fs || gracefulFs;

      if (mode === undefined) {
        mode = o777 & (~process.umask());
      }
      if (!made) made = null;

      callback = callback || function () {};
      p = path__default.resolve(p);

      xfs.mkdir(p, mode, er => {
        if (!er) {
          made = made || p;
          return callback(null, made)
        }
        switch (er.code) {
          case 'ENOENT':
            if (path__default.dirname(p) === p) return callback(er)
            mkdirs(path__default.dirname(p), opts, (er, made) => {
              if (er) callback(er, made);
              else mkdirs(p, opts, callback, made);
            });
            break

          // In the case of any other error, just see if there's a dir
          // there already.  If so, then hooray!  If not, then something
          // is borked.
          default:
            xfs.stat(p, (er2, stat) => {
              // if the stat fails, then that's super weird.
              // let the original error be the failure reason.
              if (er2 || !stat.isDirectory()) callback(er, made);
              else callback(null, made);
            });
            break
        }
      });
    }

    var mkdirs_1 = mkdirs;

    const invalidWin32Path$2 = win32.invalidWin32Path;

    const o777$1 = parseInt('0777', 8);

    function mkdirsSync (p, opts, made) {
      if (!opts || typeof opts !== 'object') {
        opts = { mode: opts };
      }

      let mode = opts.mode;
      const xfs = opts.fs || gracefulFs;

      if (process.platform === 'win32' && invalidWin32Path$2(p)) {
        const errInval = new Error(p + ' contains invalid WIN32 path characters.');
        errInval.code = 'EINVAL';
        throw errInval
      }

      if (mode === undefined) {
        mode = o777$1 & (~process.umask());
      }
      if (!made) made = null;

      p = path__default.resolve(p);

      try {
        xfs.mkdirSync(p, mode);
        made = made || p;
      } catch (err0) {
        switch (err0.code) {
          case 'ENOENT':
            if (path__default.dirname(p) === p) throw err0
            made = mkdirsSync(path__default.dirname(p), opts, made);
            mkdirsSync(p, opts, made);
            break

          // In the case of any other error, just see if there's a dir
          // there already.  If so, then hooray!  If not, then something
          // is borked.
          default:
            let stat;
            try {
              stat = xfs.statSync(p);
            } catch (err1) {
              throw err0
            }
            if (!stat.isDirectory()) throw err0
            break
        }
      }

      return made
    }

    var mkdirsSync_1 = mkdirsSync;

    const u = universalify.fromCallback;
    const mkdirs$1 = u(mkdirs_1);


    var mkdirs_1$1 = {
      mkdirs: mkdirs$1,
      mkdirsSync: mkdirsSync_1,
      // alias
      mkdirp: mkdirs$1,
      mkdirpSync: mkdirsSync_1,
      ensureDir: mkdirs$1,
      ensureDirSync: mkdirsSync_1
    };

    const u$1 = universalify.fromPromise;


    function pathExists (path) {
      return fs_1.access(path).then(() => true).catch(() => false)
    }

    var pathExists_1 = {
      pathExists: u$1(pathExists),
      pathExistsSync: fs_1.existsSync
    };

    const pathExists$1 = pathExists_1.pathExists;

    function copy (src, dest, options, callback) {
      if (typeof options === 'function' && !callback) {
        callback = options;
        options = {};
      } else if (typeof options === 'function' || options instanceof RegExp) {
        options = {filter: options};
      }
      callback = callback || function () {};
      options = options || {};

      // Warn about using preserveTimestamps on 32-bit node:
      if (options.preserveTimestamps && process.arch === 'ia32') {
        console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`);
      }

      // don't allow src and dest to be the same
      const basePath = process.cwd();
      const currentPath = path__default.resolve(basePath, src);
      const targetPath = path__default.resolve(basePath, dest);
      if (currentPath === targetPath) return callback(new Error('Source and destination must not be the same.'))

      gracefulFs.lstat(src, (err, stats) => {
        if (err) return callback(err)

        let dir = null;
        if (stats.isDirectory()) {
          const parts = dest.split(path__default.sep);
          parts.pop();
          dir = parts.join(path__default.sep);
        } else {
          dir = path__default.dirname(dest);
        }

        pathExists$1(dir, (err, dirExists) => {
          if (err) return callback(err)
          if (dirExists) return ncp_1(src, dest, options, callback)
          mkdirs_1$1.mkdirs(dir, err => {
            if (err) return callback(err)
            ncp_1(src, dest, options, callback);
          });
        });
      });
    }

    var copy_1 = copy;

    const u$2 = universalify.fromCallback;
    var copy$1 = {
      copy: u$2(copy_1)
    };

    /* eslint-disable node/no-deprecated-api */
    var buffer = function (size) {
      if (typeof Buffer.allocUnsafe === 'function') {
        try {
          return Buffer.allocUnsafe(size)
        } catch (e) {
          return new Buffer(size)
        }
      }
      return new Buffer(size)
    };

    const BUF_LENGTH = 64 * 1024;
    const _buff = buffer(BUF_LENGTH);

    function copyFileSync (srcFile, destFile, options) {
      const overwrite = options.overwrite;
      const errorOnExist = options.errorOnExist;
      const preserveTimestamps = options.preserveTimestamps;

      if (gracefulFs.existsSync(destFile)) {
        if (overwrite) {
          gracefulFs.unlinkSync(destFile);
        } else if (errorOnExist) {
          throw new Error(`${destFile} already exists`)
        } else return
      }

      const fdr = gracefulFs.openSync(srcFile, 'r');
      const stat = gracefulFs.fstatSync(fdr);
      const fdw = gracefulFs.openSync(destFile, 'w', stat.mode);
      let bytesRead = 1;
      let pos = 0;

      while (bytesRead > 0) {
        bytesRead = gracefulFs.readSync(fdr, _buff, 0, BUF_LENGTH, pos);
        gracefulFs.writeSync(fdw, _buff, 0, bytesRead);
        pos += bytesRead;
      }

      if (preserveTimestamps) {
        gracefulFs.futimesSync(fdw, stat.atime, stat.mtime);
      }

      gracefulFs.closeSync(fdr);
      gracefulFs.closeSync(fdw);
    }

    var copyFileSync_1 = copyFileSync;

    function copySync (src, dest, options) {
      if (typeof options === 'function' || options instanceof RegExp) {
        options = {filter: options};
      }

      options = options || {};
      options.recursive = !!options.recursive;

      // default to true for now
      options.clobber = 'clobber' in options ? !!options.clobber : true;
      // overwrite falls back to clobber
      options.overwrite = 'overwrite' in options ? !!options.overwrite : options.clobber;
      options.dereference = 'dereference' in options ? !!options.dereference : false;
      options.preserveTimestamps = 'preserveTimestamps' in options ? !!options.preserveTimestamps : false;

      options.filter = options.filter || function () { return true };

      // Warn about using preserveTimestamps on 32-bit node:
      if (options.preserveTimestamps && process.arch === 'ia32') {
        console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`);
      }

      const stats = (options.recursive && !options.dereference) ? gracefulFs.lstatSync(src) : gracefulFs.statSync(src);
      const destFolder = path__default.dirname(dest);
      const destFolderExists = gracefulFs.existsSync(destFolder);
      let performCopy = false;

      if (options.filter instanceof RegExp) {
        console.warn('Warning: fs-extra: Passing a RegExp filter is deprecated, use a function');
        performCopy = options.filter.test(src);
      } else if (typeof options.filter === 'function') performCopy = options.filter(src, dest);

      if (stats.isFile() && performCopy) {
        if (!destFolderExists) mkdirs_1$1.mkdirsSync(destFolder);
        copyFileSync_1(src, dest, {
          overwrite: options.overwrite,
          errorOnExist: options.errorOnExist,
          preserveTimestamps: options.preserveTimestamps
        });
      } else if (stats.isDirectory() && performCopy) {
        if (!gracefulFs.existsSync(dest)) mkdirs_1$1.mkdirsSync(dest);
        const contents = gracefulFs.readdirSync(src);
        contents.forEach(content => {
          const opts = options;
          opts.recursive = true;
          copySync(path__default.join(src, content), path__default.join(dest, content), opts);
        });
      } else if (options.recursive && stats.isSymbolicLink() && performCopy) {
        const srcPath = gracefulFs.readlinkSync(src);
        gracefulFs.symlinkSync(srcPath, dest);
      }
    }

    var copySync_1 = copySync;

    var copySync$1 = {
      copySync: copySync_1
    };

    const isWindows = (process.platform === 'win32');

    function defaults (options) {
      const methods = [
        'unlink',
        'chmod',
        'stat',
        'lstat',
        'rmdir',
        'readdir'
      ];
      methods.forEach(m => {
        options[m] = options[m] || gracefulFs[m];
        m = m + 'Sync';
        options[m] = options[m] || gracefulFs[m];
      });

      options.maxBusyTries = options.maxBusyTries || 3;
    }

    function rimraf (p, options, cb) {
      let busyTries = 0;

      if (typeof options === 'function') {
        cb = options;
        options = {};
      }

      assert(p, 'rimraf: missing path');
      assert.equal(typeof p, 'string', 'rimraf: path should be a string');
      assert.equal(typeof cb, 'function', 'rimraf: callback function required');
      assert(options, 'rimraf: invalid options argument provided');
      assert.equal(typeof options, 'object', 'rimraf: options should be object');

      defaults(options);

      rimraf_(p, options, function CB (er) {
        if (er) {
          if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&
              busyTries < options.maxBusyTries) {
            busyTries++;
            let time = busyTries * 100;
            // try again, with the same exact callback as this one.
            return setTimeout(() => rimraf_(p, options, CB), time)
          }

          // already gone
          if (er.code === 'ENOENT') er = null;
        }

        cb(er);
      });
    }

    // Two possible strategies.
    // 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
    // 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
    //
    // Both result in an extra syscall when you guess wrong.  However, there
    // are likely far more normal files in the world than directories.  This
    // is based on the assumption that a the average number of files per
    // directory is >= 1.
    //
    // If anyone ever complains about this, then I guess the strategy could
    // be made configurable somehow.  But until then, YAGNI.
    function rimraf_ (p, options, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === 'function');

      // sunos lets the root user unlink directories, which is... weird.
      // so we have to lstat here and make sure it's not a dir.
      options.lstat(p, (er, st) => {
        if (er && er.code === 'ENOENT') {
          return cb(null)
        }

        // Windows can EPERM on stat.  Life is suffering.
        if (er && er.code === 'EPERM' && isWindows) {
          return fixWinEPERM(p, options, er, cb)
        }

        if (st && st.isDirectory()) {
          return rmdir(p, options, er, cb)
        }

        options.unlink(p, er => {
          if (er) {
            if (er.code === 'ENOENT') {
              return cb(null)
            }
            if (er.code === 'EPERM') {
              return (isWindows)
                ? fixWinEPERM(p, options, er, cb)
                : rmdir(p, options, er, cb)
            }
            if (er.code === 'EISDIR') {
              return rmdir(p, options, er, cb)
            }
          }
          return cb(er)
        });
      });
    }

    function fixWinEPERM (p, options, er, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === 'function');
      if (er) {
        assert(er instanceof Error);
      }

      options.chmod(p, 666, er2 => {
        if (er2) {
          cb(er2.code === 'ENOENT' ? null : er);
        } else {
          options.stat(p, (er3, stats) => {
            if (er3) {
              cb(er3.code === 'ENOENT' ? null : er);
            } else if (stats.isDirectory()) {
              rmdir(p, options, er, cb);
            } else {
              options.unlink(p, cb);
            }
          });
        }
      });
    }

    function fixWinEPERMSync (p, options, er) {
      let stats;

      assert(p);
      assert(options);
      if (er) {
        assert(er instanceof Error);
      }

      try {
        options.chmodSync(p, 666);
      } catch (er2) {
        if (er2.code === 'ENOENT') {
          return
        } else {
          throw er
        }
      }

      try {
        stats = options.statSync(p);
      } catch (er3) {
        if (er3.code === 'ENOENT') {
          return
        } else {
          throw er
        }
      }

      if (stats.isDirectory()) {
        rmdirSync(p, options, er);
      } else {
        options.unlinkSync(p);
      }
    }

    function rmdir (p, options, originalEr, cb) {
      assert(p);
      assert(options);
      if (originalEr) {
        assert(originalEr instanceof Error);
      }
      assert(typeof cb === 'function');

      // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
      // if we guessed wrong, and it's not a directory, then
      // raise the original error.
      options.rmdir(p, er => {
        if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {
          rmkids(p, options, cb);
        } else if (er && er.code === 'ENOTDIR') {
          cb(originalEr);
        } else {
          cb(er);
        }
      });
    }

    function rmkids (p, options, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === 'function');

      options.readdir(p, (er, files) => {
        if (er) return cb(er)

        let n = files.length;
        let errState;

        if (n === 0) return options.rmdir(p, cb)

        files.forEach(f => {
          rimraf(path__default.join(p, f), options, er => {
            if (errState) {
              return
            }
            if (er) return cb(errState = er)
            if (--n === 0) {
              options.rmdir(p, cb);
            }
          });
        });
      });
    }

    // this looks simpler, and is strictly *faster*, but will
    // tie up the JavaScript thread and fail on excessively
    // deep directory trees.
    function rimrafSync (p, options) {
      let st;

      options = options || {};
      defaults(options);

      assert(p, 'rimraf: missing path');
      assert.equal(typeof p, 'string', 'rimraf: path should be a string');
      assert(options, 'rimraf: missing options');
      assert.equal(typeof options, 'object', 'rimraf: options should be object');

      try {
        st = options.lstatSync(p);
      } catch (er) {
        if (er.code === 'ENOENT') {
          return
        }

        // Windows can EPERM on stat.  Life is suffering.
        if (er.code === 'EPERM' && isWindows) {
          fixWinEPERMSync(p, options, er);
        }
      }

      try {
        // sunos lets the root user unlink directories, which is... weird.
        if (st && st.isDirectory()) {
          rmdirSync(p, options, null);
        } else {
          options.unlinkSync(p);
        }
      } catch (er) {
        if (er.code === 'ENOENT') {
          return
        } else if (er.code === 'EPERM') {
          return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
        } else if (er.code !== 'EISDIR') {
          throw er
        }
        rmdirSync(p, options, er);
      }
    }

    function rmdirSync (p, options, originalEr) {
      assert(p);
      assert(options);
      if (originalEr) {
        assert(originalEr instanceof Error);
      }

      try {
        options.rmdirSync(p);
      } catch (er) {
        if (er.code === 'ENOTDIR') {
          throw originalEr
        } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {
          rmkidsSync(p, options);
        } else if (er.code !== 'ENOENT') {
          throw er
        }
      }
    }

    function rmkidsSync (p, options) {
      assert(p);
      assert(options);
      options.readdirSync(p).forEach(f => rimrafSync(path__default.join(p, f), options));

      // We only end up here once we got ENOTEMPTY at least once, and
      // at this point, we are guaranteed to have removed all the kids.
      // So, we know that it won't be ENOENT or ENOTDIR or anything else.
      // try really hard to delete stuff on windows, because it has a
      // PROFOUNDLY annoying habit of not closing handles promptly when
      // files are deleted, resulting in spurious ENOTEMPTY errors.
      const retries = isWindows ? 100 : 1;
      let i = 0;
      do {
        let threw = true;
        try {
          const ret = options.rmdirSync(p, options);
          threw = false;
          return ret
        } finally {
          if (++i < retries && threw) continue // eslint-disable-line
        }
      } while (true)
    }

    var rimraf_1 = rimraf;
    rimraf.sync = rimrafSync;

    const u$3 = universalify.fromCallback;


    var remove = {
      remove: u$3(rimraf_1),
      removeSync: rimraf_1.sync
    };

    var _fs;
    try {
      _fs = gracefulFs;
    } catch (_) {
      _fs = fs$2__default;
    }

    function readFile (file, options, callback) {
      if (callback == null) {
        callback = options;
        options = {};
      }

      if (typeof options === 'string') {
        options = {encoding: options};
      }

      options = options || {};
      var fs = options.fs || _fs;

      var shouldThrow = true;
      if ('throws' in options) {
        shouldThrow = options.throws;
      }

      fs.readFile(file, options, function (err, data) {
        if (err) return callback(err)

        data = stripBom(data);

        var obj;
        try {
          obj = JSON.parse(data, options ? options.reviver : null);
        } catch (err2) {
          if (shouldThrow) {
            err2.message = file + ': ' + err2.message;
            return callback(err2)
          } else {
            return callback(null, null)
          }
        }

        callback(null, obj);
      });
    }

    function readFileSync (file, options) {
      options = options || {};
      if (typeof options === 'string') {
        options = {encoding: options};
      }

      var fs = options.fs || _fs;

      var shouldThrow = true;
      if ('throws' in options) {
        shouldThrow = options.throws;
      }

      try {
        var content = fs.readFileSync(file, options);
        content = stripBom(content);
        return JSON.parse(content, options.reviver)
      } catch (err) {
        if (shouldThrow) {
          err.message = file + ': ' + err.message;
          throw err
        } else {
          return null
        }
      }
    }

    function stringify (obj, options) {
      var spaces;
      var EOL = '\n';
      if (typeof options === 'object' && options !== null) {
        if (options.spaces) {
          spaces = options.spaces;
        }
        if (options.EOL) {
          EOL = options.EOL;
        }
      }

      var str = JSON.stringify(obj, options ? options.replacer : null, spaces);

      return str.replace(/\n/g, EOL) + EOL
    }

    function writeFile (file, obj, options, callback) {
      if (callback == null) {
        callback = options;
        options = {};
      }
      options = options || {};
      var fs = options.fs || _fs;

      var str = '';
      try {
        str = stringify(obj, options);
      } catch (err) {
        // Need to return whether a callback was passed or not
        if (callback) callback(err, null);
        return
      }

      fs.writeFile(file, str, options, callback);
    }

    function writeFileSync (file, obj, options) {
      options = options || {};
      var fs = options.fs || _fs;

      var str = stringify(obj, options);
      // not sure if fs.writeFileSync returns anything, but just in case
      return fs.writeFileSync(file, str, options)
    }

    function stripBom (content) {
      // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified
      if (Buffer.isBuffer(content)) content = content.toString('utf8');
      content = content.replace(/^\uFEFF/, '');
      return content
    }

    var jsonfile = {
      readFile: readFile,
      readFileSync: readFileSync,
      writeFile: writeFile,
      writeFileSync: writeFileSync
    };

    var jsonfile_1 = jsonfile;

    const u$4 = universalify.fromCallback;


    var jsonfile$1 = {
      // jsonfile exports
      readJson: u$4(jsonfile_1.readFile),
      readJsonSync: jsonfile_1.readFileSync,
      writeJson: u$4(jsonfile_1.writeFile),
      writeJsonSync: jsonfile_1.writeFileSync
    };

    const pathExists$2 = pathExists_1.pathExists;


    function outputJson (file, data, options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }

      const dir = path__default.dirname(file);

      pathExists$2(dir, (err, itDoes) => {
        if (err) return callback(err)
        if (itDoes) return jsonfile$1.writeJson(file, data, options, callback)

        mkdirs_1$1.mkdirs(dir, err => {
          if (err) return callback(err)
          jsonfile$1.writeJson(file, data, options, callback);
        });
      });
    }

    var outputJson_1 = outputJson;

    function outputJsonSync (file, data, options) {
      const dir = path__default.dirname(file);

      if (!gracefulFs.existsSync(dir)) {
        mkdirs_1$1.mkdirsSync(dir);
      }

      jsonfile$1.writeJsonSync(file, data, options);
    }

    var outputJsonSync_1 = outputJsonSync;

    const u$5 = universalify.fromCallback;


    jsonfile$1.outputJson = u$5(outputJson_1);
    jsonfile$1.outputJsonSync = outputJsonSync_1;
    // aliases
    jsonfile$1.outputJSON = jsonfile$1.outputJson;
    jsonfile$1.outputJSONSync = jsonfile$1.outputJsonSync;
    jsonfile$1.writeJSON = jsonfile$1.writeJson;
    jsonfile$1.writeJSONSync = jsonfile$1.writeJsonSync;
    jsonfile$1.readJSON = jsonfile$1.readJson;
    jsonfile$1.readJSONSync = jsonfile$1.readJsonSync;

    var json = jsonfile$1;

    // most of this code was written by Andrew Kelley
    // licensed under the BSD license: see
    // https://github.com/andrewrk/node-mv/blob/master/package.json

    // this needs a cleanup

    const u$6 = universalify.fromCallback;



    const remove$1 = remove.remove;
    const mkdirp = mkdirs_1$1.mkdirs;

    function move (src, dest, options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }

      const overwrite = options.overwrite || options.clobber || false;

      isSrcSubdir(src, dest, (err, itIs) => {
        if (err) return callback(err)
        if (itIs) return callback(new Error(`Cannot move '${src}' to a subdirectory of itself, '${dest}'.`))
        mkdirp(path__default.dirname(dest), err => {
          if (err) return callback(err)
          doRename();
        });
      });

      function doRename () {
        if (path__default.resolve(src) === path__default.resolve(dest)) {
          gracefulFs.access(src, callback);
        } else if (overwrite) {
          gracefulFs.rename(src, dest, err => {
            if (!err) return callback()

            if (err.code === 'ENOTEMPTY' || err.code === 'EEXIST') {
              remove$1(dest, err => {
                if (err) return callback(err)
                options.overwrite = false; // just overwriteed it, no need to do it again
                move(src, dest, options, callback);
              });
              return
            }

            // weird Windows shit
            if (err.code === 'EPERM') {
              setTimeout(() => {
                remove$1(dest, err => {
                  if (err) return callback(err)
                  options.overwrite = false;
                  move(src, dest, options, callback);
                });
              }, 200);
              return
            }

            if (err.code !== 'EXDEV') return callback(err)
            moveAcrossDevice(src, dest, overwrite, callback);
          });
        } else {
          gracefulFs.link(src, dest, err => {
            if (err) {
              if (err.code === 'EXDEV' || err.code === 'EISDIR' || err.code === 'EPERM' || err.code === 'ENOTSUP') {
                return moveAcrossDevice(src, dest, overwrite, callback)
              }
              return callback(err)
            }
            return gracefulFs.unlink(src, callback)
          });
        }
      }
    }

    function moveAcrossDevice (src, dest, overwrite, callback) {
      gracefulFs.stat(src, (err, stat) => {
        if (err) return callback(err)

        if (stat.isDirectory()) {
          moveDirAcrossDevice(src, dest, overwrite, callback);
        } else {
          moveFileAcrossDevice(src, dest, overwrite, callback);
        }
      });
    }

    function moveFileAcrossDevice (src, dest, overwrite, callback) {
      const flags = overwrite ? 'w' : 'wx';
      const ins = gracefulFs.createReadStream(src);
      const outs = gracefulFs.createWriteStream(dest, { flags });

      ins.on('error', err => {
        ins.destroy();
        outs.destroy();
        outs.removeListener('close', onClose);

        // may want to create a directory but `out` line above
        // creates an empty file for us: See #108
        // don't care about error here
        gracefulFs.unlink(dest, () => {
          // note: `err` here is from the input stream errror
          if (err.code === 'EISDIR' || err.code === 'EPERM') {
            moveDirAcrossDevice(src, dest, overwrite, callback);
          } else {
            callback(err);
          }
        });
      });

      outs.on('error', err => {
        ins.destroy();
        outs.destroy();
        outs.removeListener('close', onClose);
        callback(err);
      });

      outs.once('close', onClose);
      ins.pipe(outs);

      function onClose () {
        gracefulFs.unlink(src, callback);
      }
    }

    function moveDirAcrossDevice (src, dest, overwrite, callback) {
      const options = {
        overwrite: false
      };

      if (overwrite) {
        remove$1(dest, err => {
          if (err) return callback(err)
          startNcp();
        });
      } else {
        startNcp();
      }

      function startNcp () {
        ncp_1(src, dest, options, err => {
          if (err) return callback(err)
          remove$1(src, callback);
        });
      }
    }

    // return true if dest is a subdir of src, otherwise false.
    // extract dest base dir and check if that is the same as src basename
    function isSrcSubdir (src, dest, cb) {
      gracefulFs.stat(src, (err, st) => {
        if (err) return cb(err)
        if (st.isDirectory()) {
          const baseDir = dest.split(path__default.dirname(src) + path__default.sep)[1];
          if (baseDir) {
            const destBasename = baseDir.split(path__default.sep)[0];
            if (destBasename) return cb(null, src !== dest && dest.indexOf(src) > -1 && destBasename === path__default.basename(src))
            return cb(null, false)
          }
          return cb(null, false)
        }
        return cb(null, false)
      });
    }

    var move_1 = {
      move: u$6(move)
    };

    const copySync$2 = copySync$1.copySync;
    const removeSync = remove.removeSync;
    const mkdirpSync = mkdirs_1$1.mkdirsSync;


    function moveSync (src, dest, options) {
      options = options || {};
      const overwrite = options.overwrite || options.clobber || false;

      src = path__default.resolve(src);
      dest = path__default.resolve(dest);

      if (src === dest) return gracefulFs.accessSync(src)

      if (isSrcSubdir$1(src, dest)) throw new Error(`Cannot move '${src}' into itself '${dest}'.`)

      mkdirpSync(path__default.dirname(dest));
      tryRenameSync();

      function tryRenameSync () {
        if (overwrite) {
          try {
            return gracefulFs.renameSync(src, dest)
          } catch (err) {
            if (err.code === 'ENOTEMPTY' || err.code === 'EEXIST' || err.code === 'EPERM') {
              removeSync(dest);
              options.overwrite = false; // just overwriteed it, no need to do it again
              return moveSync(src, dest, options)
            }

            if (err.code !== 'EXDEV') throw err
            return moveSyncAcrossDevice(src, dest, overwrite)
          }
        } else {
          try {
            gracefulFs.linkSync(src, dest);
            return gracefulFs.unlinkSync(src)
          } catch (err) {
            if (err.code === 'EXDEV' || err.code === 'EISDIR' || err.code === 'EPERM' || err.code === 'ENOTSUP') {
              return moveSyncAcrossDevice(src, dest, overwrite)
            }
            throw err
          }
        }
      }
    }

    function moveSyncAcrossDevice (src, dest, overwrite) {
      const stat = gracefulFs.statSync(src);

      if (stat.isDirectory()) {
        return moveDirSyncAcrossDevice(src, dest, overwrite)
      } else {
        return moveFileSyncAcrossDevice(src, dest, overwrite)
      }
    }

    function moveFileSyncAcrossDevice (src, dest, overwrite) {
      const BUF_LENGTH = 64 * 1024;
      const _buff = buffer(BUF_LENGTH);

      const flags = overwrite ? 'w' : 'wx';

      const fdr = gracefulFs.openSync(src, 'r');
      const stat = gracefulFs.fstatSync(fdr);
      const fdw = gracefulFs.openSync(dest, flags, stat.mode);
      let bytesRead = 1;
      let pos = 0;

      while (bytesRead > 0) {
        bytesRead = gracefulFs.readSync(fdr, _buff, 0, BUF_LENGTH, pos);
        gracefulFs.writeSync(fdw, _buff, 0, bytesRead);
        pos += bytesRead;
      }

      gracefulFs.closeSync(fdr);
      gracefulFs.closeSync(fdw);
      return gracefulFs.unlinkSync(src)
    }

    function moveDirSyncAcrossDevice (src, dest, overwrite) {
      const options = {
        overwrite: false
      };

      if (overwrite) {
        removeSync(dest);
        tryCopySync();
      } else {
        tryCopySync();
      }

      function tryCopySync () {
        copySync$2(src, dest, options);
        return removeSync(src)
      }
    }

    // return true if dest is a subdir of src, otherwise false.
    // extract dest base dir and check if that is the same as src basename
    function isSrcSubdir$1 (src, dest) {
      try {
        return gracefulFs.statSync(src).isDirectory() &&
               src !== dest &&
               dest.indexOf(src) > -1 &&
               dest.split(path__default.dirname(src) + path__default.sep)[1].split(path__default.sep)[0] === path__default.basename(src)
      } catch (e) {
        return false
      }
    }

    var moveSync_1 = {
      moveSync
    };

    const u$7 = universalify.fromCallback;





    const emptyDir = u$7(function emptyDir (dir, callback) {
      callback = callback || function () {};
      fs$2__default.readdir(dir, (err, items) => {
        if (err) return mkdirs_1$1.mkdirs(dir, callback)

        items = items.map(item => path__default.join(dir, item));

        deleteItem();

        function deleteItem () {
          const item = items.pop();
          if (!item) return callback()
          remove.remove(item, err => {
            if (err) return callback(err)
            deleteItem();
          });
        }
      });
    });

    function emptyDirSync (dir) {
      let items;
      try {
        items = fs$2__default.readdirSync(dir);
      } catch (err) {
        return mkdirs_1$1.mkdirsSync(dir)
      }

      items.forEach(item => {
        item = path__default.join(dir, item);
        remove.removeSync(item);
      });
    }

    var empty = {
      emptyDirSync,
      emptydirSync: emptyDirSync,
      emptyDir,
      emptydir: emptyDir
    };

    const u$8 = universalify.fromCallback;



    const pathExists$3 = pathExists_1.pathExists;

    function createFile (file, callback) {
      function makeFile () {
        gracefulFs.writeFile(file, '', err => {
          if (err) return callback(err)
          callback();
        });
      }

      gracefulFs.stat(file, (err, stats) => { // eslint-disable-line handle-callback-err
        if (!err && stats.isFile()) return callback()
        const dir = path__default.dirname(file);
        pathExists$3(dir, (err, dirExists) => {
          if (err) return callback(err)
          if (dirExists) return makeFile()
          mkdirs_1$1.mkdirs(dir, err => {
            if (err) return callback(err)
            makeFile();
          });
        });
      });
    }

    function createFileSync (file) {
      let stats;
      try {
        stats = gracefulFs.statSync(file);
      } catch (e) {}
      if (stats && stats.isFile()) return

      const dir = path__default.dirname(file);
      if (!gracefulFs.existsSync(dir)) {
        mkdirs_1$1.mkdirsSync(dir);
      }

      gracefulFs.writeFileSync(file, '');
    }

    var file = {
      createFile: u$8(createFile),
      createFileSync
    };

    const u$9 = universalify.fromCallback;



    const pathExists$4 = pathExists_1.pathExists;

    function createLink (srcpath, dstpath, callback) {
      function makeLink (srcpath, dstpath) {
        gracefulFs.link(srcpath, dstpath, err => {
          if (err) return callback(err)
          callback(null);
        });
      }

      pathExists$4(dstpath, (err, destinationExists) => {
        if (err) return callback(err)
        if (destinationExists) return callback(null)
        gracefulFs.lstat(srcpath, (err, stat) => {
          if (err) {
            err.message = err.message.replace('lstat', 'ensureLink');
            return callback(err)
          }

          const dir = path__default.dirname(dstpath);
          pathExists$4(dir, (err, dirExists) => {
            if (err) return callback(err)
            if (dirExists) return makeLink(srcpath, dstpath)
            mkdirs_1$1.mkdirs(dir, err => {
              if (err) return callback(err)
              makeLink(srcpath, dstpath);
            });
          });
        });
      });
    }

    function createLinkSync (srcpath, dstpath, callback) {
      const destinationExists = gracefulFs.existsSync(dstpath);
      if (destinationExists) return undefined

      try {
        gracefulFs.lstatSync(srcpath);
      } catch (err) {
        err.message = err.message.replace('lstat', 'ensureLink');
        throw err
      }

      const dir = path__default.dirname(dstpath);
      const dirExists = gracefulFs.existsSync(dir);
      if (dirExists) return gracefulFs.linkSync(srcpath, dstpath)
      mkdirs_1$1.mkdirsSync(dir);

      return gracefulFs.linkSync(srcpath, dstpath)
    }

    var link = {
      createLink: u$9(createLink),
      createLinkSync
    };

    const pathExists$5 = pathExists_1.pathExists;

    /**
     * Function that returns two types of paths, one relative to symlink, and one
     * relative to the current working directory. Checks if path is absolute or
     * relative. If the path is relative, this function checks if the path is
     * relative to symlink or relative to current working directory. This is an
     * initiative to find a smarter `srcpath` to supply when building symlinks.
     * This allows you to determine which path to use out of one of three possible
     * types of source paths. The first is an absolute path. This is detected by
     * `path.isAbsolute()`. When an absolute path is provided, it is checked to
     * see if it exists. If it does it's used, if not an error is returned
     * (callback)/ thrown (sync). The other two options for `srcpath` are a
     * relative url. By default Node's `fs.symlink` works by creating a symlink
     * using `dstpath` and expects the `srcpath` to be relative to the newly
     * created symlink. If you provide a `srcpath` that does not exist on the file
     * system it results in a broken symlink. To minimize this, the function
     * checks to see if the 'relative to symlink' source file exists, and if it
     * does it will use it. If it does not, it checks if there's a file that
     * exists that is relative to the current working directory, if does its used.
     * This preserves the expectations of the original fs.symlink spec and adds
     * the ability to pass in `relative to current working direcotry` paths.
     */

    function symlinkPaths (srcpath, dstpath, callback) {
      if (path__default.isAbsolute(srcpath)) {
        return gracefulFs.lstat(srcpath, (err, stat) => {
          if (err) {
            err.message = err.message.replace('lstat', 'ensureSymlink');
            return callback(err)
          }
          return callback(null, {
            'toCwd': srcpath,
            'toDst': srcpath
          })
        })
      } else {
        const dstdir = path__default.dirname(dstpath);
        const relativeToDst = path__default.join(dstdir, srcpath);
        return pathExists$5(relativeToDst, (err, exists) => {
          if (err) return callback(err)
          if (exists) {
            return callback(null, {
              'toCwd': relativeToDst,
              'toDst': srcpath
            })
          } else {
            return gracefulFs.lstat(srcpath, (err, stat) => {
              if (err) {
                err.message = err.message.replace('lstat', 'ensureSymlink');
                return callback(err)
              }
              return callback(null, {
                'toCwd': srcpath,
                'toDst': path__default.relative(dstdir, srcpath)
              })
            })
          }
        })
      }
    }

    function symlinkPathsSync (srcpath, dstpath) {
      let exists;
      if (path__default.isAbsolute(srcpath)) {
        exists = gracefulFs.existsSync(srcpath);
        if (!exists) throw new Error('absolute srcpath does not exist')
        return {
          'toCwd': srcpath,
          'toDst': srcpath
        }
      } else {
        const dstdir = path__default.dirname(dstpath);
        const relativeToDst = path__default.join(dstdir, srcpath);
        exists = gracefulFs.existsSync(relativeToDst);
        if (exists) {
          return {
            'toCwd': relativeToDst,
            'toDst': srcpath
          }
        } else {
          exists = gracefulFs.existsSync(srcpath);
          if (!exists) throw new Error('relative srcpath does not exist')
          return {
            'toCwd': srcpath,
            'toDst': path__default.relative(dstdir, srcpath)
          }
        }
      }
    }

    var symlinkPaths_1 = {
      symlinkPaths,
      symlinkPathsSync
    };

    function symlinkType (srcpath, type, callback) {
      callback = (typeof type === 'function') ? type : callback;
      type = (typeof type === 'function') ? false : type;
      if (type) return callback(null, type)
      gracefulFs.lstat(srcpath, (err, stats) => {
        if (err) return callback(null, 'file')
        type = (stats && stats.isDirectory()) ? 'dir' : 'file';
        callback(null, type);
      });
    }

    function symlinkTypeSync (srcpath, type) {
      let stats;

      if (type) return type
      try {
        stats = gracefulFs.lstatSync(srcpath);
      } catch (e) {
        return 'file'
      }
      return (stats && stats.isDirectory()) ? 'dir' : 'file'
    }

    var symlinkType_1 = {
      symlinkType,
      symlinkTypeSync
    };

    const u$a = universalify.fromCallback;



    const mkdirs$2 = mkdirs_1$1.mkdirs;
    const mkdirsSync$1 = mkdirs_1$1.mkdirsSync;


    const symlinkPaths$1 = symlinkPaths_1.symlinkPaths;
    const symlinkPathsSync$1 = symlinkPaths_1.symlinkPathsSync;


    const symlinkType$1 = symlinkType_1.symlinkType;
    const symlinkTypeSync$1 = symlinkType_1.symlinkTypeSync;

    const pathExists$6 = pathExists_1.pathExists;

    function createSymlink (srcpath, dstpath, type, callback) {
      callback = (typeof type === 'function') ? type : callback;
      type = (typeof type === 'function') ? false : type;

      pathExists$6(dstpath, (err, destinationExists) => {
        if (err) return callback(err)
        if (destinationExists) return callback(null)
        symlinkPaths$1(srcpath, dstpath, (err, relative) => {
          if (err) return callback(err)
          srcpath = relative.toDst;
          symlinkType$1(relative.toCwd, type, (err, type) => {
            if (err) return callback(err)
            const dir = path__default.dirname(dstpath);
            pathExists$6(dir, (err, dirExists) => {
              if (err) return callback(err)
              if (dirExists) return gracefulFs.symlink(srcpath, dstpath, type, callback)
              mkdirs$2(dir, err => {
                if (err) return callback(err)
                gracefulFs.symlink(srcpath, dstpath, type, callback);
              });
            });
          });
        });
      });
    }

    function createSymlinkSync (srcpath, dstpath, type, callback) {
      type = (typeof type === 'function') ? false : type;

      const destinationExists = gracefulFs.existsSync(dstpath);
      if (destinationExists) return undefined

      const relative = symlinkPathsSync$1(srcpath, dstpath);
      srcpath = relative.toDst;
      type = symlinkTypeSync$1(relative.toCwd, type);
      const dir = path__default.dirname(dstpath);
      const exists = gracefulFs.existsSync(dir);
      if (exists) return gracefulFs.symlinkSync(srcpath, dstpath, type)
      mkdirsSync$1(dir);
      return gracefulFs.symlinkSync(srcpath, dstpath, type)
    }

    var symlink = {
      createSymlink: u$a(createSymlink),
      createSymlinkSync
    };

    var ensure = {
      // file
      createFile: file.createFile,
      createFileSync: file.createFileSync,
      ensureFile: file.createFile,
      ensureFileSync: file.createFileSync,
      // link
      createLink: link.createLink,
      createLinkSync: link.createLinkSync,
      ensureLink: link.createLink,
      ensureLinkSync: link.createLinkSync,
      // symlink
      createSymlink: symlink.createSymlink,
      createSymlinkSync: symlink.createSymlinkSync,
      ensureSymlink: symlink.createSymlink,
      ensureSymlinkSync: symlink.createSymlinkSync
    };

    const u$b = universalify.fromCallback;



    const pathExists$7 = pathExists_1.pathExists;

    function outputFile (file, data, encoding, callback) {
      if (typeof encoding === 'function') {
        callback = encoding;
        encoding = 'utf8';
      }

      const dir = path__default.dirname(file);
      pathExists$7(dir, (err, itDoes) => {
        if (err) return callback(err)
        if (itDoes) return gracefulFs.writeFile(file, data, encoding, callback)

        mkdirs_1$1.mkdirs(dir, err => {
          if (err) return callback(err)

          gracefulFs.writeFile(file, data, encoding, callback);
        });
      });
    }

    function outputFileSync (file, data, encoding) {
      const dir = path__default.dirname(file);
      if (gracefulFs.existsSync(dir)) {
        return gracefulFs.writeFileSync.apply(gracefulFs, arguments)
      }
      mkdirs_1$1.mkdirsSync(dir);
      gracefulFs.writeFileSync.apply(gracefulFs, arguments);
    }

    var output = {
      outputFile: u$b(outputFile),
      outputFileSync
    };

    const fs$1 = {};

    // Export graceful-fs:
    assign_1(fs$1, fs_1);
    // Export extra methods:
    assign_1(fs$1, copy$1);
    assign_1(fs$1, copySync$1);
    assign_1(fs$1, mkdirs_1$1);
    assign_1(fs$1, remove);
    assign_1(fs$1, json);
    assign_1(fs$1, move_1);
    assign_1(fs$1, moveSync_1);
    assign_1(fs$1, empty);
    assign_1(fs$1, ensure);
    assign_1(fs$1, output);
    assign_1(fs$1, pathExists_1);

    var lib = fs$1;

    var fsExtra = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': lib,
        __moduleExports: lib
    });

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A wrapper around the Node.js file-system (i.e the `fs` package).
     */
    class NodeJSFileSystem {
        constructor() {
            this._caseSensitive = undefined;
        }
        exists(path) {
            return fs$2.existsSync(path);
        }
        readFile(path) {
            return fs$2.readFileSync(path, 'utf8');
        }
        readFileBuffer(path) {
            return fs$2.readFileSync(path);
        }
        writeFile(path, data, exclusive = false) {
            fs$2.writeFileSync(path, data, exclusive ? { flag: 'wx' } : undefined);
        }
        removeFile(path) {
            fs$2.unlinkSync(path);
        }
        symlink(target, path) {
            fs$2.symlinkSync(target, path);
        }
        readdir(path) {
            return fs$2.readdirSync(path);
        }
        lstat(path) {
            return fs$2.lstatSync(path);
        }
        stat(path) {
            return fs$2.statSync(path);
        }
        pwd() {
            return this.normalize(process.cwd());
        }
        chdir(dir) {
            process.chdir(dir);
        }
        copyFile(from, to) {
            fs$2.copyFileSync(from, to);
        }
        moveFile(from, to) {
            fs$2.renameSync(from, to);
        }
        ensureDir(path) {
            const parents = [];
            while (!this.isRoot(path) && !this.exists(path)) {
                parents.push(path);
                path = this.dirname(path);
            }
            while (parents.length) {
                this.safeMkdir(parents.pop());
            }
        }
        removeDeep(path) {
            undefined(path);
        }
        isCaseSensitive() {
            if (this._caseSensitive === undefined) {
                // Note the use of the real file-system is intentional:
                // `this.exists()` relies upon `isCaseSensitive()` so that would cause an infinite recursion.
                this._caseSensitive = !fs$2.existsSync(togglePathCase(__filename));
            }
            return this._caseSensitive;
        }
        resolve(...paths) {
            return this.normalize(path.resolve(...paths));
        }
        dirname(file) {
            return this.normalize(path.dirname(file));
        }
        join(basePath, ...paths) {
            return this.normalize(path.join(basePath, ...paths));
        }
        isRoot(path) {
            return this.dirname(path) === this.normalize(path);
        }
        isRooted(path$1) {
            return path.isAbsolute(path$1);
        }
        relative(from, to) {
            return this.normalize(path.relative(from, to));
        }
        basename(filePath, extension) {
            return path.basename(filePath, extension);
        }
        extname(path$1) {
            return path.extname(path$1);
        }
        realpath(path) {
            return this.resolve(fs$2.realpathSync(path));
        }
        getDefaultLibLocation() {
            return this.resolve(require.resolve('typescript'), '..');
        }
        normalize(path) {
            // Convert backslashes to forward slashes
            return path.replace(/\\/g, '/');
        }
        safeMkdir(path) {
            try {
                fs$2.mkdirSync(path);
            }
            catch (err) {
                // Ignore the error, if the path already exists and points to a directory.
                // Re-throw otherwise.
                if (!this.exists(path) || !this.stat(path).isDirectory()) {
                    throw err;
                }
            }
        }
    }
    /**
     * Toggle the case of each character in a file path.
     */
    function togglePathCase(str) {
        return absoluteFrom(str.replace(/\w/g, ch => ch.toUpperCase() === ch ? ch.toLowerCase() : ch.toUpperCase()));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var TagContentType;
    (function (TagContentType) {
        TagContentType[TagContentType["RAW_TEXT"] = 0] = "RAW_TEXT";
        TagContentType[TagContentType["ESCAPABLE_RAW_TEXT"] = 1] = "ESCAPABLE_RAW_TEXT";
        TagContentType[TagContentType["PARSABLE_DATA"] = 2] = "PARSABLE_DATA";
    })(TagContentType || (TagContentType = {}));
    function splitNsName(elementName) {
        if (elementName[0] != ':') {
            return [null, elementName];
        }
        const colonIndex = elementName.indexOf(':', 1);
        if (colonIndex == -1) {
            throw new Error(`Unsupported format "${elementName}" expecting ":namespace:name"`);
        }
        return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];
    }
    // `<ng-container>` tags work the same regardless the namespace
    function isNgContainer(tagName) {
        return splitNsName(tagName)[1] === 'ng-container';
    }
    // `<ng-content>` tags work the same regardless the namespace
    function isNgContent(tagName) {
        return splitNsName(tagName)[1] === 'ng-content';
    }
    // `<ng-template>` tags work the same regardless the namespace
    function isNgTemplate(tagName) {
        return splitNsName(tagName)[1] === 'ng-template';
    }
    function getNsPrefix(fullName) {
        return fullName === null ? null : splitNsName(fullName)[0];
    }
    function mergeNsAndName(prefix, localName) {
        return prefix ? `:${prefix}:${localName}` : localName;
    }
    // see http://www.w3.org/TR/html51/syntax.html#named-character-references
    // see https://html.spec.whatwg.org/multipage/entities.json
    // This list is not exhaustive to keep the compiler footprint low.
    // The `&#123;` / `&#x1ab;` syntax should be used when the named character reference does not
    // exist.
    const NAMED_ENTITIES = {
        'Aacute': '\u00C1',
        'aacute': '\u00E1',
        'Acirc': '\u00C2',
        'acirc': '\u00E2',
        'acute': '\u00B4',
        'AElig': '\u00C6',
        'aelig': '\u00E6',
        'Agrave': '\u00C0',
        'agrave': '\u00E0',
        'alefsym': '\u2135',
        'Alpha': '\u0391',
        'alpha': '\u03B1',
        'amp': '&',
        'and': '\u2227',
        'ang': '\u2220',
        'apos': '\u0027',
        'Aring': '\u00C5',
        'aring': '\u00E5',
        'asymp': '\u2248',
        'Atilde': '\u00C3',
        'atilde': '\u00E3',
        'Auml': '\u00C4',
        'auml': '\u00E4',
        'bdquo': '\u201E',
        'Beta': '\u0392',
        'beta': '\u03B2',
        'brvbar': '\u00A6',
        'bull': '\u2022',
        'cap': '\u2229',
        'Ccedil': '\u00C7',
        'ccedil': '\u00E7',
        'cedil': '\u00B8',
        'cent': '\u00A2',
        'Chi': '\u03A7',
        'chi': '\u03C7',
        'circ': '\u02C6',
        'clubs': '\u2663',
        'cong': '\u2245',
        'copy': '\u00A9',
        'crarr': '\u21B5',
        'cup': '\u222A',
        'curren': '\u00A4',
        'dagger': '\u2020',
        'Dagger': '\u2021',
        'darr': '\u2193',
        'dArr': '\u21D3',
        'deg': '\u00B0',
        'Delta': '\u0394',
        'delta': '\u03B4',
        'diams': '\u2666',
        'divide': '\u00F7',
        'Eacute': '\u00C9',
        'eacute': '\u00E9',
        'Ecirc': '\u00CA',
        'ecirc': '\u00EA',
        'Egrave': '\u00C8',
        'egrave': '\u00E8',
        'empty': '\u2205',
        'emsp': '\u2003',
        'ensp': '\u2002',
        'Epsilon': '\u0395',
        'epsilon': '\u03B5',
        'equiv': '\u2261',
        'Eta': '\u0397',
        'eta': '\u03B7',
        'ETH': '\u00D0',
        'eth': '\u00F0',
        'Euml': '\u00CB',
        'euml': '\u00EB',
        'euro': '\u20AC',
        'exist': '\u2203',
        'fnof': '\u0192',
        'forall': '\u2200',
        'frac12': '\u00BD',
        'frac14': '\u00BC',
        'frac34': '\u00BE',
        'frasl': '\u2044',
        'Gamma': '\u0393',
        'gamma': '\u03B3',
        'ge': '\u2265',
        'gt': '>',
        'harr': '\u2194',
        'hArr': '\u21D4',
        'hearts': '\u2665',
        'hellip': '\u2026',
        'Iacute': '\u00CD',
        'iacute': '\u00ED',
        'Icirc': '\u00CE',
        'icirc': '\u00EE',
        'iexcl': '\u00A1',
        'Igrave': '\u00CC',
        'igrave': '\u00EC',
        'image': '\u2111',
        'infin': '\u221E',
        'int': '\u222B',
        'Iota': '\u0399',
        'iota': '\u03B9',
        'iquest': '\u00BF',
        'isin': '\u2208',
        'Iuml': '\u00CF',
        'iuml': '\u00EF',
        'Kappa': '\u039A',
        'kappa': '\u03BA',
        'Lambda': '\u039B',
        'lambda': '\u03BB',
        'lang': '\u27E8',
        'laquo': '\u00AB',
        'larr': '\u2190',
        'lArr': '\u21D0',
        'lceil': '\u2308',
        'ldquo': '\u201C',
        'le': '\u2264',
        'lfloor': '\u230A',
        'lowast': '\u2217',
        'loz': '\u25CA',
        'lrm': '\u200E',
        'lsaquo': '\u2039',
        'lsquo': '\u2018',
        'lt': '<',
        'macr': '\u00AF',
        'mdash': '\u2014',
        'micro': '\u00B5',
        'middot': '\u00B7',
        'minus': '\u2212',
        'Mu': '\u039C',
        'mu': '\u03BC',
        'nabla': '\u2207',
        'nbsp': '\u00A0',
        'ndash': '\u2013',
        'ne': '\u2260',
        'ni': '\u220B',
        'not': '\u00AC',
        'notin': '\u2209',
        'nsub': '\u2284',
        'Ntilde': '\u00D1',
        'ntilde': '\u00F1',
        'Nu': '\u039D',
        'nu': '\u03BD',
        'Oacute': '\u00D3',
        'oacute': '\u00F3',
        'Ocirc': '\u00D4',
        'ocirc': '\u00F4',
        'OElig': '\u0152',
        'oelig': '\u0153',
        'Ograve': '\u00D2',
        'ograve': '\u00F2',
        'oline': '\u203E',
        'Omega': '\u03A9',
        'omega': '\u03C9',
        'Omicron': '\u039F',
        'omicron': '\u03BF',
        'oplus': '\u2295',
        'or': '\u2228',
        'ordf': '\u00AA',
        'ordm': '\u00BA',
        'Oslash': '\u00D8',
        'oslash': '\u00F8',
        'Otilde': '\u00D5',
        'otilde': '\u00F5',
        'otimes': '\u2297',
        'Ouml': '\u00D6',
        'ouml': '\u00F6',
        'para': '\u00B6',
        'permil': '\u2030',
        'perp': '\u22A5',
        'Phi': '\u03A6',
        'phi': '\u03C6',
        'Pi': '\u03A0',
        'pi': '\u03C0',
        'piv': '\u03D6',
        'plusmn': '\u00B1',
        'pound': '\u00A3',
        'prime': '\u2032',
        'Prime': '\u2033',
        'prod': '\u220F',
        'prop': '\u221D',
        'Psi': '\u03A8',
        'psi': '\u03C8',
        'quot': '\u0022',
        'radic': '\u221A',
        'rang': '\u27E9',
        'raquo': '\u00BB',
        'rarr': '\u2192',
        'rArr': '\u21D2',
        'rceil': '\u2309',
        'rdquo': '\u201D',
        'real': '\u211C',
        'reg': '\u00AE',
        'rfloor': '\u230B',
        'Rho': '\u03A1',
        'rho': '\u03C1',
        'rlm': '\u200F',
        'rsaquo': '\u203A',
        'rsquo': '\u2019',
        'sbquo': '\u201A',
        'Scaron': '\u0160',
        'scaron': '\u0161',
        'sdot': '\u22C5',
        'sect': '\u00A7',
        'shy': '\u00AD',
        'Sigma': '\u03A3',
        'sigma': '\u03C3',
        'sigmaf': '\u03C2',
        'sim': '\u223C',
        'spades': '\u2660',
        'sub': '\u2282',
        'sube': '\u2286',
        'sum': '\u2211',
        'sup': '\u2283',
        'sup1': '\u00B9',
        'sup2': '\u00B2',
        'sup3': '\u00B3',
        'supe': '\u2287',
        'szlig': '\u00DF',
        'Tau': '\u03A4',
        'tau': '\u03C4',
        'there4': '\u2234',
        'Theta': '\u0398',
        'theta': '\u03B8',
        'thetasym': '\u03D1',
        'thinsp': '\u2009',
        'THORN': '\u00DE',
        'thorn': '\u00FE',
        'tilde': '\u02DC',
        'times': '\u00D7',
        'trade': '\u2122',
        'Uacute': '\u00DA',
        'uacute': '\u00FA',
        'uarr': '\u2191',
        'uArr': '\u21D1',
        'Ucirc': '\u00DB',
        'ucirc': '\u00FB',
        'Ugrave': '\u00D9',
        'ugrave': '\u00F9',
        'uml': '\u00A8',
        'upsih': '\u03D2',
        'Upsilon': '\u03A5',
        'upsilon': '\u03C5',
        'Uuml': '\u00DC',
        'uuml': '\u00FC',
        'weierp': '\u2118',
        'Xi': '\u039E',
        'xi': '\u03BE',
        'Yacute': '\u00DD',
        'yacute': '\u00FD',
        'yen': '\u00A5',
        'yuml': '\u00FF',
        'Yuml': '\u0178',
        'Zeta': '\u0396',
        'zeta': '\u03B6',
        'zwj': '\u200D',
        'zwnj': '\u200C',
    };
    // The &ngsp; pseudo-entity is denoting a space. see:
    // https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart
    const NGSP_UNICODE = '\uE500';
    NAMED_ENTITIES['ngsp'] = NGSP_UNICODE;

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class HtmlTagDefinition {
        constructor({ closedByChildren, implicitNamespacePrefix, contentType = TagContentType.PARSABLE_DATA, closedByParent = false, isVoid = false, ignoreFirstLf = false } = {}) {
            this.closedByChildren = {};
            this.closedByParent = false;
            this.canSelfClose = false;
            if (closedByChildren && closedByChildren.length > 0) {
                closedByChildren.forEach(tagName => this.closedByChildren[tagName] = true);
            }
            this.isVoid = isVoid;
            this.closedByParent = closedByParent || isVoid;
            this.implicitNamespacePrefix = implicitNamespacePrefix || null;
            this.contentType = contentType;
            this.ignoreFirstLf = ignoreFirstLf;
        }
        isClosedByChild(name) {
            return this.isVoid || name.toLowerCase() in this.closedByChildren;
        }
    }
    let _DEFAULT_TAG_DEFINITION;
    // see http://www.w3.org/TR/html51/syntax.html#optional-tags
    // This implementation does not fully conform to the HTML5 spec.
    let TAG_DEFINITIONS;
    function getHtmlTagDefinition(tagName) {
        if (!TAG_DEFINITIONS) {
            _DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();
            TAG_DEFINITIONS = {
                'base': new HtmlTagDefinition({ isVoid: true }),
                'meta': new HtmlTagDefinition({ isVoid: true }),
                'area': new HtmlTagDefinition({ isVoid: true }),
                'embed': new HtmlTagDefinition({ isVoid: true }),
                'link': new HtmlTagDefinition({ isVoid: true }),
                'img': new HtmlTagDefinition({ isVoid: true }),
                'input': new HtmlTagDefinition({ isVoid: true }),
                'param': new HtmlTagDefinition({ isVoid: true }),
                'hr': new HtmlTagDefinition({ isVoid: true }),
                'br': new HtmlTagDefinition({ isVoid: true }),
                'source': new HtmlTagDefinition({ isVoid: true }),
                'track': new HtmlTagDefinition({ isVoid: true }),
                'wbr': new HtmlTagDefinition({ isVoid: true }),
                'p': new HtmlTagDefinition({
                    closedByChildren: [
                        'address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset',
                        'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5',
                        'h6', 'header', 'hgroup', 'hr', 'main', 'nav', 'ol',
                        'p', 'pre', 'section', 'table', 'ul'
                    ],
                    closedByParent: true
                }),
                'thead': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'] }),
                'tbody': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'], closedByParent: true }),
                'tfoot': new HtmlTagDefinition({ closedByChildren: ['tbody'], closedByParent: true }),
                'tr': new HtmlTagDefinition({ closedByChildren: ['tr'], closedByParent: true }),
                'td': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),
                'th': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),
                'col': new HtmlTagDefinition({ isVoid: true }),
                'svg': new HtmlTagDefinition({ implicitNamespacePrefix: 'svg' }),
                'math': new HtmlTagDefinition({ implicitNamespacePrefix: 'math' }),
                'li': new HtmlTagDefinition({ closedByChildren: ['li'], closedByParent: true }),
                'dt': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'] }),
                'dd': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'], closedByParent: true }),
                'rb': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),
                'rt': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),
                'rtc': new HtmlTagDefinition({ closedByChildren: ['rb', 'rtc', 'rp'], closedByParent: true }),
                'rp': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),
                'optgroup': new HtmlTagDefinition({ closedByChildren: ['optgroup'], closedByParent: true }),
                'option': new HtmlTagDefinition({ closedByChildren: ['option', 'optgroup'], closedByParent: true }),
                'pre': new HtmlTagDefinition({ ignoreFirstLf: true }),
                'listing': new HtmlTagDefinition({ ignoreFirstLf: true }),
                'style': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),
                'script': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),
                'title': new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT }),
                'textarea': new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }),
            };
        }
        return TAG_DEFINITIONS[tagName.toLowerCase()] || _DEFAULT_TAG_DEFINITION;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const _SELECTOR_REGEXP = new RegExp('(\\:not\\()|' + // 1: ":not("
        '(([\\.\\#]?)[-\\w]+)|' + // 2: "tag"; 3: "."/"#";
        // "-" should appear first in the regexp below as FF31 parses "[.-\w]" as a range
        // 4: attribute; 5: attribute_string; 6: attribute_value
        '(?:\\[([-.\\w*]+)(?:=([\"\']?)([^\\]\"\']*)\\5)?\\])|' + // "[name]", "[name=value]",
        // "[name="value"]",
        // "[name='value']"
        '(\\))|' + // 7: ")"
        '(\\s*,\\s*)', // 8: ","
    'g');
    /**
     * A css selector contains an element name,
     * css classes and attribute/value pairs with the purpose
     * of selecting subsets out of them.
     */
    class CssSelector {
        constructor() {
            this.element = null;
            this.classNames = [];
            /**
             * The selectors are encoded in pairs where:
             * - even locations are attribute names
             * - odd locations are attribute values.
             *
             * Example:
             * Selector: `[key1=value1][key2]` would parse to:
             * ```
             * ['key1', 'value1', 'key2', '']
             * ```
             */
            this.attrs = [];
            this.notSelectors = [];
        }
        static parse(selector) {
            const results = [];
            const _addResult = (res, cssSel) => {
                if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 &&
                    cssSel.attrs.length == 0) {
                    cssSel.element = '*';
                }
                res.push(cssSel);
            };
            let cssSelector = new CssSelector();
            let match;
            let current = cssSelector;
            let inNot = false;
            _SELECTOR_REGEXP.lastIndex = 0;
            while (match = _SELECTOR_REGEXP.exec(selector)) {
                if (match[1 /* NOT */]) {
                    if (inNot) {
                        throw new Error('Nesting :not in a selector is not allowed');
                    }
                    inNot = true;
                    current = new CssSelector();
                    cssSelector.notSelectors.push(current);
                }
                const tag = match[2 /* TAG */];
                if (tag) {
                    const prefix = match[3 /* PREFIX */];
                    if (prefix === '#') {
                        // #hash
                        current.addAttribute('id', tag.substr(1));
                    }
                    else if (prefix === '.') {
                        // Class
                        current.addClassName(tag.substr(1));
                    }
                    else {
                        // Element
                        current.setElement(tag);
                    }
                }
                const attribute = match[4 /* ATTRIBUTE */];
                if (attribute) {
                    current.addAttribute(attribute, match[6 /* ATTRIBUTE_VALUE */]);
                }
                if (match[7 /* NOT_END */]) {
                    inNot = false;
                    current = cssSelector;
                }
                if (match[8 /* SEPARATOR */]) {
                    if (inNot) {
                        throw new Error('Multiple selectors in :not are not supported');
                    }
                    _addResult(results, cssSelector);
                    cssSelector = current = new CssSelector();
                }
            }
            _addResult(results, cssSelector);
            return results;
        }
        isElementSelector() {
            return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 &&
                this.notSelectors.length === 0;
        }
        hasElementSelector() {
            return !!this.element;
        }
        setElement(element = null) {
            this.element = element;
        }
        /** Gets a template string for an element that matches the selector. */
        getMatchingElementTemplate() {
            const tagName = this.element || 'div';
            const classAttr = this.classNames.length > 0 ? ` class="${this.classNames.join(' ')}"` : '';
            let attrs = '';
            for (let i = 0; i < this.attrs.length; i += 2) {
                const attrName = this.attrs[i];
                const attrValue = this.attrs[i + 1] !== '' ? `="${this.attrs[i + 1]}"` : '';
                attrs += ` ${attrName}${attrValue}`;
            }
            return getHtmlTagDefinition(tagName).isVoid ? `<${tagName}${classAttr}${attrs}/>` :
                `<${tagName}${classAttr}${attrs}></${tagName}>`;
        }
        getAttrs() {
            const result = [];
            if (this.classNames.length > 0) {
                result.push('class', this.classNames.join(' '));
            }
            return result.concat(this.attrs);
        }
        addAttribute(name, value = '') {
            this.attrs.push(name, value && value.toLowerCase() || '');
        }
        addClassName(name) {
            this.classNames.push(name.toLowerCase());
        }
        toString() {
            let res = this.element || '';
            if (this.classNames) {
                this.classNames.forEach(klass => res += `.${klass}`);
            }
            if (this.attrs) {
                for (let i = 0; i < this.attrs.length; i += 2) {
                    const name = this.attrs[i];
                    const value = this.attrs[i + 1];
                    res += `[${name}${value ? '=' + value : ''}]`;
                }
            }
            this.notSelectors.forEach(notSelector => res += `:not(${notSelector})`);
            return res;
        }
    }
    /**
     * Reads a list of CssSelectors and allows to calculate which ones
     * are contained in a given CssSelector.
     */
    class SelectorMatcher {
        constructor() {
            this._elementMap = new Map();
            this._elementPartialMap = new Map();
            this._classMap = new Map();
            this._classPartialMap = new Map();
            this._attrValueMap = new Map();
            this._attrValuePartialMap = new Map();
            this._listContexts = [];
        }
        static createNotMatcher(notSelectors) {
            const notMatcher = new SelectorMatcher();
            notMatcher.addSelectables(notSelectors, null);
            return notMatcher;
        }
        addSelectables(cssSelectors, callbackCtxt) {
            let listContext = null;
            if (cssSelectors.length > 1) {
                listContext = new SelectorListContext(cssSelectors);
                this._listContexts.push(listContext);
            }
            for (let i = 0; i < cssSelectors.length; i++) {
                this._addSelectable(cssSelectors[i], callbackCtxt, listContext);
            }
        }
        /**
         * Add an object that can be found later on by calling `match`.
         * @param cssSelector A css selector
         * @param callbackCtxt An opaque object that will be given to the callback of the `match` function
         */
        _addSelectable(cssSelector, callbackCtxt, listContext) {
            let matcher = this;
            const element = cssSelector.element;
            const classNames = cssSelector.classNames;
            const attrs = cssSelector.attrs;
            const selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);
            if (element) {
                const isTerminal = attrs.length === 0 && classNames.length === 0;
                if (isTerminal) {
                    this._addTerminal(matcher._elementMap, element, selectable);
                }
                else {
                    matcher = this._addPartial(matcher._elementPartialMap, element);
                }
            }
            if (classNames) {
                for (let i = 0; i < classNames.length; i++) {
                    const isTerminal = attrs.length === 0 && i === classNames.length - 1;
                    const className = classNames[i];
                    if (isTerminal) {
                        this._addTerminal(matcher._classMap, className, selectable);
                    }
                    else {
                        matcher = this._addPartial(matcher._classPartialMap, className);
                    }
                }
            }
            if (attrs) {
                for (let i = 0; i < attrs.length; i += 2) {
                    const isTerminal = i === attrs.length - 2;
                    const name = attrs[i];
                    const value = attrs[i + 1];
                    if (isTerminal) {
                        const terminalMap = matcher._attrValueMap;
                        let terminalValuesMap = terminalMap.get(name);
                        if (!terminalValuesMap) {
                            terminalValuesMap = new Map();
                            terminalMap.set(name, terminalValuesMap);
                        }
                        this._addTerminal(terminalValuesMap, value, selectable);
                    }
                    else {
                        const partialMap = matcher._attrValuePartialMap;
                        let partialValuesMap = partialMap.get(name);
                        if (!partialValuesMap) {
                            partialValuesMap = new Map();
                            partialMap.set(name, partialValuesMap);
                        }
                        matcher = this._addPartial(partialValuesMap, value);
                    }
                }
            }
        }
        _addTerminal(map, name, selectable) {
            let terminalList = map.get(name);
            if (!terminalList) {
                terminalList = [];
                map.set(name, terminalList);
            }
            terminalList.push(selectable);
        }
        _addPartial(map, name) {
            let matcher = map.get(name);
            if (!matcher) {
                matcher = new SelectorMatcher();
                map.set(name, matcher);
            }
            return matcher;
        }
        /**
         * Find the objects that have been added via `addSelectable`
         * whose css selector is contained in the given css selector.
         * @param cssSelector A css selector
         * @param matchedCallback This callback will be called with the object handed into `addSelectable`
         * @return boolean true if a match was found
         */
        match(cssSelector, matchedCallback) {
            let result = false;
            const element = cssSelector.element;
            const classNames = cssSelector.classNames;
            const attrs = cssSelector.attrs;
            for (let i = 0; i < this._listContexts.length; i++) {
                this._listContexts[i].alreadyMatched = false;
            }
            result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;
            result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) ||
                result;
            if (classNames) {
                for (let i = 0; i < classNames.length; i++) {
                    const className = classNames[i];
                    result =
                        this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;
                    result =
                        this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||
                            result;
                }
            }
            if (attrs) {
                for (let i = 0; i < attrs.length; i += 2) {
                    const name = attrs[i];
                    const value = attrs[i + 1];
                    const terminalValuesMap = this._attrValueMap.get(name);
                    if (value) {
                        result =
                            this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;
                    }
                    result =
                        this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;
                    const partialValuesMap = this._attrValuePartialMap.get(name);
                    if (value) {
                        result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;
                    }
                    result =
                        this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;
                }
            }
            return result;
        }
        /** @internal */
        _matchTerminal(map, name, cssSelector, matchedCallback) {
            if (!map || typeof name !== 'string') {
                return false;
            }
            let selectables = map.get(name) || [];
            const starSelectables = map.get('*');
            if (starSelectables) {
                selectables = selectables.concat(starSelectables);
            }
            if (selectables.length === 0) {
                return false;
            }
            let selectable;
            let result = false;
            for (let i = 0; i < selectables.length; i++) {
                selectable = selectables[i];
                result = selectable.finalize(cssSelector, matchedCallback) || result;
            }
            return result;
        }
        /** @internal */
        _matchPartial(map, name, cssSelector, matchedCallback) {
            if (!map || typeof name !== 'string') {
                return false;
            }
            const nestedSelector = map.get(name);
            if (!nestedSelector) {
                return false;
            }
            // TODO(perf): get rid of recursion and measure again
            // TODO(perf): don't pass the whole selector into the recursion,
            // but only the not processed parts
            return nestedSelector.match(cssSelector, matchedCallback);
        }
    }
    class SelectorListContext {
        constructor(selectors) {
            this.selectors = selectors;
            this.alreadyMatched = false;
        }
    }
    // Store context to pass back selector and context when a selector is matched
    class SelectorContext {
        constructor(selector, cbContext, listContext) {
            this.selector = selector;
            this.cbContext = cbContext;
            this.listContext = listContext;
            this.notSelectors = selector.notSelectors;
        }
        finalize(cssSelector, callback) {
            let result = true;
            if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {
                const notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);
                result = !notMatcher.match(cssSelector, null);
            }
            if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {
                if (this.listContext) {
                    this.listContext.alreadyMatched = true;
                }
                callback(this.selector, this.cbContext);
            }
            return result;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var ViewEncapsulation;
    (function (ViewEncapsulation) {
        ViewEncapsulation[ViewEncapsulation["Emulated"] = 0] = "Emulated";
        ViewEncapsulation[ViewEncapsulation["Native"] = 1] = "Native";
        ViewEncapsulation[ViewEncapsulation["None"] = 2] = "None";
        ViewEncapsulation[ViewEncapsulation["ShadowDom"] = 3] = "ShadowDom";
    })(ViewEncapsulation || (ViewEncapsulation = {}));
    var ChangeDetectionStrategy;
    (function (ChangeDetectionStrategy) {
        ChangeDetectionStrategy[ChangeDetectionStrategy["OnPush"] = 0] = "OnPush";
        ChangeDetectionStrategy[ChangeDetectionStrategy["Default"] = 1] = "Default";
    })(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));
    const CUSTOM_ELEMENTS_SCHEMA = {
        name: 'custom-elements'
    };
    const NO_ERRORS_SCHEMA = {
        name: 'no-errors-schema'
    };
    var SecurityContext;
    (function (SecurityContext) {
        SecurityContext[SecurityContext["NONE"] = 0] = "NONE";
        SecurityContext[SecurityContext["HTML"] = 1] = "HTML";
        SecurityContext[SecurityContext["STYLE"] = 2] = "STYLE";
        SecurityContext[SecurityContext["SCRIPT"] = 3] = "SCRIPT";
        SecurityContext[SecurityContext["URL"] = 4] = "URL";
        SecurityContext[SecurityContext["RESOURCE_URL"] = 5] = "RESOURCE_URL";
    })(SecurityContext || (SecurityContext = {}));
    var MissingTranslationStrategy;
    (function (MissingTranslationStrategy) {
        MissingTranslationStrategy[MissingTranslationStrategy["Error"] = 0] = "Error";
        MissingTranslationStrategy[MissingTranslationStrategy["Warning"] = 1] = "Warning";
        MissingTranslationStrategy[MissingTranslationStrategy["Ignore"] = 2] = "Ignore";
    })(MissingTranslationStrategy || (MissingTranslationStrategy = {}));
    function parserSelectorToSimpleSelector(selector) {
        const classes = selector.classNames && selector.classNames.length ?
            [8 /* CLASS */, ...selector.classNames] :
            [];
        const elementName = selector.element && selector.element !== '*' ? selector.element : '';
        return [elementName, ...selector.attrs, ...classes];
    }
    function parserSelectorToNegativeSelector(selector) {
        const classes = selector.classNames && selector.classNames.length ?
            [8 /* CLASS */, ...selector.classNames] :
            [];
        if (selector.element) {
            return [
                1 /* NOT */ | 4 /* ELEMENT */, selector.element, ...selector.attrs, ...classes
            ];
        }
        else if (selector.attrs.length) {
            return [1 /* NOT */ | 2 /* ATTRIBUTE */, ...selector.attrs, ...classes];
        }
        else {
            return selector.classNames && selector.classNames.length ?
                [1 /* NOT */ | 8 /* CLASS */, ...selector.classNames] :
                [];
        }
    }
    function parserSelectorToR3Selector(selector) {
        const positive = parserSelectorToSimpleSelector(selector);
        const negative = selector.notSelectors && selector.notSelectors.length ?
            selector.notSelectors.map(notSelector => parserSelectorToNegativeSelector(notSelector)) :
            [];
        return positive.concat(...negative);
    }
    function parseSelectorToR3Selector(selector) {
        return selector ? CssSelector.parse(selector).map(parserSelectorToR3Selector) : [];
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    //// Types
    var TypeModifier;
    (function (TypeModifier) {
        TypeModifier[TypeModifier["Const"] = 0] = "Const";
    })(TypeModifier || (TypeModifier = {}));
    class Type {
        constructor(modifiers = null) {
            this.modifiers = modifiers;
            if (!modifiers) {
                this.modifiers = [];
            }
        }
        hasModifier(modifier) {
            return this.modifiers.indexOf(modifier) !== -1;
        }
    }
    var BuiltinTypeName;
    (function (BuiltinTypeName) {
        BuiltinTypeName[BuiltinTypeName["Dynamic"] = 0] = "Dynamic";
        BuiltinTypeName[BuiltinTypeName["Bool"] = 1] = "Bool";
        BuiltinTypeName[BuiltinTypeName["String"] = 2] = "String";
        BuiltinTypeName[BuiltinTypeName["Int"] = 3] = "Int";
        BuiltinTypeName[BuiltinTypeName["Number"] = 4] = "Number";
        BuiltinTypeName[BuiltinTypeName["Function"] = 5] = "Function";
        BuiltinTypeName[BuiltinTypeName["Inferred"] = 6] = "Inferred";
        BuiltinTypeName[BuiltinTypeName["None"] = 7] = "None";
    })(BuiltinTypeName || (BuiltinTypeName = {}));
    class BuiltinType extends Type {
        constructor(name, modifiers = null) {
            super(modifiers);
            this.name = name;
        }
        visitType(visitor, context) {
            return visitor.visitBuiltinType(this, context);
        }
    }
    class ExpressionType extends Type {
        constructor(value, modifiers = null, typeParams = null) {
            super(modifiers);
            this.value = value;
            this.typeParams = typeParams;
        }
        visitType(visitor, context) {
            return visitor.visitExpressionType(this, context);
        }
    }
    const DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);
    const INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);
    const BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);
    const INT_TYPE = new BuiltinType(BuiltinTypeName.Int);
    const NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);
    const STRING_TYPE = new BuiltinType(BuiltinTypeName.String);
    const FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);
    const NONE_TYPE = new BuiltinType(BuiltinTypeName.None);
    ///// Expressions
    var BinaryOperator;
    (function (BinaryOperator) {
        BinaryOperator[BinaryOperator["Equals"] = 0] = "Equals";
        BinaryOperator[BinaryOperator["NotEquals"] = 1] = "NotEquals";
        BinaryOperator[BinaryOperator["Identical"] = 2] = "Identical";
        BinaryOperator[BinaryOperator["NotIdentical"] = 3] = "NotIdentical";
        BinaryOperator[BinaryOperator["Minus"] = 4] = "Minus";
        BinaryOperator[BinaryOperator["Plus"] = 5] = "Plus";
        BinaryOperator[BinaryOperator["Divide"] = 6] = "Divide";
        BinaryOperator[BinaryOperator["Multiply"] = 7] = "Multiply";
        BinaryOperator[BinaryOperator["Modulo"] = 8] = "Modulo";
        BinaryOperator[BinaryOperator["And"] = 9] = "And";
        BinaryOperator[BinaryOperator["Or"] = 10] = "Or";
        BinaryOperator[BinaryOperator["BitwiseAnd"] = 11] = "BitwiseAnd";
        BinaryOperator[BinaryOperator["Lower"] = 12] = "Lower";
        BinaryOperator[BinaryOperator["LowerEquals"] = 13] = "LowerEquals";
        BinaryOperator[BinaryOperator["Bigger"] = 14] = "Bigger";
        BinaryOperator[BinaryOperator["BiggerEquals"] = 15] = "BiggerEquals";
    })(BinaryOperator || (BinaryOperator = {}));
    function nullSafeIsEquivalent(base, other) {
        if (base == null || other == null) {
            return base == other;
        }
        return base.isEquivalent(other);
    }
    function areAllEquivalent(base, other) {
        const len = base.length;
        if (len !== other.length) {
            return false;
        }
        for (let i = 0; i < len; i++) {
            if (!base[i].isEquivalent(other[i])) {
                return false;
            }
        }
        return true;
    }
    class Expression {
        constructor(type, sourceSpan) {
            this.type = type || null;
            this.sourceSpan = sourceSpan || null;
        }
        prop(name, sourceSpan) {
            return new ReadPropExpr(this, name, null, sourceSpan);
        }
        key(index, type, sourceSpan) {
            return new ReadKeyExpr(this, index, type, sourceSpan);
        }
        callMethod(name, params, sourceSpan) {
            return new InvokeMethodExpr(this, name, params, null, sourceSpan);
        }
        callFn(params, sourceSpan, pure) {
            return new InvokeFunctionExpr(this, params, null, sourceSpan, pure);
        }
        instantiate(params, type, sourceSpan) {
            return new InstantiateExpr(this, params, type, sourceSpan);
        }
        conditional(trueCase, falseCase = null, sourceSpan) {
            return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);
        }
        equals(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);
        }
        notEquals(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);
        }
        identical(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);
        }
        notIdentical(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);
        }
        minus(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);
        }
        plus(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);
        }
        divide(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);
        }
        multiply(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);
        }
        modulo(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);
        }
        and(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);
        }
        bitwiseAnd(rhs, sourceSpan, parens = true) {
            return new BinaryOperatorExpr(BinaryOperator.BitwiseAnd, this, rhs, null, sourceSpan, parens);
        }
        or(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);
        }
        lower(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);
        }
        lowerEquals(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);
        }
        bigger(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);
        }
        biggerEquals(rhs, sourceSpan) {
            return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);
        }
        isBlank(sourceSpan) {
            // Note: We use equals by purpose here to compare to null and undefined in JS.
            // We use the typed null to allow strictNullChecks to narrow types.
            return this.equals(TYPED_NULL_EXPR, sourceSpan);
        }
        cast(type, sourceSpan) {
            return new CastExpr(this, type, sourceSpan);
        }
        toStmt() {
            return new ExpressionStatement(this, null);
        }
    }
    var BuiltinVar;
    (function (BuiltinVar) {
        BuiltinVar[BuiltinVar["This"] = 0] = "This";
        BuiltinVar[BuiltinVar["Super"] = 1] = "Super";
        BuiltinVar[BuiltinVar["CatchError"] = 2] = "CatchError";
        BuiltinVar[BuiltinVar["CatchStack"] = 3] = "CatchStack";
    })(BuiltinVar || (BuiltinVar = {}));
    class ReadVarExpr extends Expression {
        constructor(name, type, sourceSpan) {
            super(type, sourceSpan);
            if (typeof name === 'string') {
                this.name = name;
                this.builtin = null;
            }
            else {
                this.name = null;
                this.builtin = name;
            }
        }
        isEquivalent(e) {
            return e instanceof ReadVarExpr && this.name === e.name && this.builtin === e.builtin;
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitReadVarExpr(this, context);
        }
        set(value) {
            if (!this.name) {
                throw new Error(`Built in variable ${this.builtin} can not be assigned to.`);
            }
            return new WriteVarExpr(this.name, value, null, this.sourceSpan);
        }
    }
    class TypeofExpr extends Expression {
        constructor(expr, type, sourceSpan) {
            super(type, sourceSpan);
            this.expr = expr;
        }
        visitExpression(visitor, context) {
            return visitor.visitTypeofExpr(this, context);
        }
        isEquivalent(e) {
            return e instanceof TypeofExpr && e.expr.isEquivalent(this.expr);
        }
        isConstant() {
            return this.expr.isConstant();
        }
    }
    class WrappedNodeExpr extends Expression {
        constructor(node, type, sourceSpan) {
            super(type, sourceSpan);
            this.node = node;
        }
        isEquivalent(e) {
            return e instanceof WrappedNodeExpr && this.node === e.node;
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitWrappedNodeExpr(this, context);
        }
    }
    class WriteVarExpr extends Expression {
        constructor(name, value, type, sourceSpan) {
            super(type || value.type, sourceSpan);
            this.name = name;
            this.value = value;
        }
        isEquivalent(e) {
            return e instanceof WriteVarExpr && this.name === e.name && this.value.isEquivalent(e.value);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitWriteVarExpr(this, context);
        }
        toDeclStmt(type, modifiers) {
            return new DeclareVarStmt(this.name, this.value, type, modifiers, this.sourceSpan);
        }
        toConstDecl() {
            return this.toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]);
        }
    }
    class WriteKeyExpr extends Expression {
        constructor(receiver, index, value, type, sourceSpan) {
            super(type || value.type, sourceSpan);
            this.receiver = receiver;
            this.index = index;
            this.value = value;
        }
        isEquivalent(e) {
            return e instanceof WriteKeyExpr && this.receiver.isEquivalent(e.receiver) &&
                this.index.isEquivalent(e.index) && this.value.isEquivalent(e.value);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitWriteKeyExpr(this, context);
        }
    }
    class WritePropExpr extends Expression {
        constructor(receiver, name, value, type, sourceSpan) {
            super(type || value.type, sourceSpan);
            this.receiver = receiver;
            this.name = name;
            this.value = value;
        }
        isEquivalent(e) {
            return e instanceof WritePropExpr && this.receiver.isEquivalent(e.receiver) &&
                this.name === e.name && this.value.isEquivalent(e.value);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitWritePropExpr(this, context);
        }
    }
    var BuiltinMethod;
    (function (BuiltinMethod) {
        BuiltinMethod[BuiltinMethod["ConcatArray"] = 0] = "ConcatArray";
        BuiltinMethod[BuiltinMethod["SubscribeObservable"] = 1] = "SubscribeObservable";
        BuiltinMethod[BuiltinMethod["Bind"] = 2] = "Bind";
    })(BuiltinMethod || (BuiltinMethod = {}));
    class InvokeMethodExpr extends Expression {
        constructor(receiver, method, args, type, sourceSpan) {
            super(type, sourceSpan);
            this.receiver = receiver;
            this.args = args;
            if (typeof method === 'string') {
                this.name = method;
                this.builtin = null;
            }
            else {
                this.name = null;
                this.builtin = method;
            }
        }
        isEquivalent(e) {
            return e instanceof InvokeMethodExpr && this.receiver.isEquivalent(e.receiver) &&
                this.name === e.name && this.builtin === e.builtin && areAllEquivalent(this.args, e.args);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitInvokeMethodExpr(this, context);
        }
    }
    class InvokeFunctionExpr extends Expression {
        constructor(fn, args, type, sourceSpan, pure = false) {
            super(type, sourceSpan);
            this.fn = fn;
            this.args = args;
            this.pure = pure;
        }
        isEquivalent(e) {
            return e instanceof InvokeFunctionExpr && this.fn.isEquivalent(e.fn) &&
                areAllEquivalent(this.args, e.args) && this.pure === e.pure;
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitInvokeFunctionExpr(this, context);
        }
    }
    class InstantiateExpr extends Expression {
        constructor(classExpr, args, type, sourceSpan) {
            super(type, sourceSpan);
            this.classExpr = classExpr;
            this.args = args;
        }
        isEquivalent(e) {
            return e instanceof InstantiateExpr && this.classExpr.isEquivalent(e.classExpr) &&
                areAllEquivalent(this.args, e.args);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitInstantiateExpr(this, context);
        }
    }
    class LiteralExpr extends Expression {
        constructor(value, type, sourceSpan) {
            super(type, sourceSpan);
            this.value = value;
        }
        isEquivalent(e) {
            return e instanceof LiteralExpr && this.value === e.value;
        }
        isConstant() {
            return true;
        }
        visitExpression(visitor, context) {
            return visitor.visitLiteralExpr(this, context);
        }
    }
    class LocalizedString extends Expression {
        constructor(metaBlock, messageParts, placeHolderNames, expressions, sourceSpan) {
            super(STRING_TYPE, sourceSpan);
            this.metaBlock = metaBlock;
            this.messageParts = messageParts;
            this.placeHolderNames = placeHolderNames;
            this.expressions = expressions;
        }
        isEquivalent(e) {
            // return e instanceof LocalizedString && this.message === e.message;
            return false;
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitLocalizedString(this, context);
        }
        /**
         * Serialize the given `meta` and `messagePart` into "cooked" and "raw" strings that can be used
         * in a `$localize` tagged string. The format of the metadata is the same as that parsed by
         * `parseI18nMeta()`.
         *
         * @param meta The metadata to serialize
         * @param messagePart The first part of the tagged string
         */
        serializeI18nHead() {
            const MEANING_SEPARATOR = '|';
            const ID_SEPARATOR = '@@';
            const LEGACY_ID_INDICATOR = '';
            let metaBlock = this.metaBlock.description || '';
            if (this.metaBlock.meaning) {
                metaBlock = `${this.metaBlock.meaning}${MEANING_SEPARATOR}${metaBlock}`;
            }
            if (this.metaBlock.customId) {
                metaBlock = `${metaBlock}${ID_SEPARATOR}${this.metaBlock.customId}`;
            }
            if (this.metaBlock.legacyIds) {
                this.metaBlock.legacyIds.forEach(legacyId => {
                    metaBlock = `${metaBlock}${LEGACY_ID_INDICATOR}${legacyId}`;
                });
            }
            return createCookedRawString(metaBlock, this.messageParts[0]);
        }
        /**
         * Serialize the given `placeholderName` and `messagePart` into "cooked" and "raw" strings that
         * can be used in a `$localize` tagged string.
         *
         * @param placeholderName The placeholder name to serialize
         * @param messagePart The following message string after this placeholder
         */
        serializeI18nTemplatePart(partIndex) {
            const placeholderName = this.placeHolderNames[partIndex - 1];
            const messagePart = this.messageParts[partIndex];
            return createCookedRawString(placeholderName, messagePart);
        }
    }
    const escapeSlashes = (str) => str.replace(/\\/g, '\\\\');
    const escapeStartingColon = (str) => str.replace(/^:/, '\\:');
    const escapeColons = (str) => str.replace(/:/g, '\\:');
    const escapeForMessagePart = (str) => str.replace(/`/g, '\\`').replace(/\${/g, '$\\{');
    /**
     * Creates a `{cooked, raw}` object from the `metaBlock` and `messagePart`.
     *
     * The `raw` text must have various character sequences escaped:
     * * "\" would otherwise indicate that the next character is a control character.
     * * "`" and "${" are template string control sequences that would otherwise prematurely indicate
     *   the end of a message part.
     * * ":" inside a metablock would prematurely indicate the end of the metablock.
     * * ":" at the start of a messagePart with no metablock would erroneously indicate the start of a
     *   metablock.
     *
     * @param metaBlock Any metadata that should be prepended to the string
     * @param messagePart The message part of the string
     */
    function createCookedRawString(metaBlock, messagePart) {
        if (metaBlock === '') {
            return {
                cooked: messagePart,
                raw: escapeForMessagePart(escapeStartingColon(escapeSlashes(messagePart)))
            };
        }
        else {
            return {
                cooked: `:${metaBlock}:${messagePart}`,
                raw: escapeForMessagePart(`:${escapeColons(escapeSlashes(metaBlock))}:${escapeSlashes(messagePart)}`)
            };
        }
    }
    class ExternalExpr extends Expression {
        constructor(value, type, typeParams = null, sourceSpan) {
            super(type, sourceSpan);
            this.value = value;
            this.typeParams = typeParams;
        }
        isEquivalent(e) {
            return e instanceof ExternalExpr && this.value.name === e.value.name &&
                this.value.moduleName === e.value.moduleName && this.value.runtime === e.value.runtime;
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitExternalExpr(this, context);
        }
    }
    class ExternalReference {
        constructor(moduleName, name, runtime) {
            this.moduleName = moduleName;
            this.name = name;
            this.runtime = runtime;
        }
    }
    class ConditionalExpr extends Expression {
        constructor(condition, trueCase, falseCase = null, type, sourceSpan) {
            super(type || trueCase.type, sourceSpan);
            this.condition = condition;
            this.falseCase = falseCase;
            this.trueCase = trueCase;
        }
        isEquivalent(e) {
            return e instanceof ConditionalExpr && this.condition.isEquivalent(e.condition) &&
                this.trueCase.isEquivalent(e.trueCase) && nullSafeIsEquivalent(this.falseCase, e.falseCase);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitConditionalExpr(this, context);
        }
    }
    class NotExpr extends Expression {
        constructor(condition, sourceSpan) {
            super(BOOL_TYPE, sourceSpan);
            this.condition = condition;
        }
        isEquivalent(e) {
            return e instanceof NotExpr && this.condition.isEquivalent(e.condition);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitNotExpr(this, context);
        }
    }
    class AssertNotNull extends Expression {
        constructor(condition, sourceSpan) {
            super(condition.type, sourceSpan);
            this.condition = condition;
        }
        isEquivalent(e) {
            return e instanceof AssertNotNull && this.condition.isEquivalent(e.condition);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitAssertNotNullExpr(this, context);
        }
    }
    class CastExpr extends Expression {
        constructor(value, type, sourceSpan) {
            super(type, sourceSpan);
            this.value = value;
        }
        isEquivalent(e) {
            return e instanceof CastExpr && this.value.isEquivalent(e.value);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitCastExpr(this, context);
        }
    }
    class FnParam {
        constructor(name, type = null) {
            this.name = name;
            this.type = type;
        }
        isEquivalent(param) {
            return this.name === param.name;
        }
    }
    class FunctionExpr extends Expression {
        constructor(params, statements, type, sourceSpan, name) {
            super(type, sourceSpan);
            this.params = params;
            this.statements = statements;
            this.name = name;
        }
        isEquivalent(e) {
            return e instanceof FunctionExpr && areAllEquivalent(this.params, e.params) &&
                areAllEquivalent(this.statements, e.statements);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitFunctionExpr(this, context);
        }
        toDeclStmt(name, modifiers = null) {
            return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers, this.sourceSpan);
        }
    }
    class BinaryOperatorExpr extends Expression {
        constructor(operator, lhs, rhs, type, sourceSpan, parens = true) {
            super(type || lhs.type, sourceSpan);
            this.operator = operator;
            this.rhs = rhs;
            this.parens = parens;
            this.lhs = lhs;
        }
        isEquivalent(e) {
            return e instanceof BinaryOperatorExpr && this.operator === e.operator &&
                this.lhs.isEquivalent(e.lhs) && this.rhs.isEquivalent(e.rhs);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitBinaryOperatorExpr(this, context);
        }
    }
    class ReadPropExpr extends Expression {
        constructor(receiver, name, type, sourceSpan) {
            super(type, sourceSpan);
            this.receiver = receiver;
            this.name = name;
        }
        isEquivalent(e) {
            return e instanceof ReadPropExpr && this.receiver.isEquivalent(e.receiver) &&
                this.name === e.name;
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitReadPropExpr(this, context);
        }
        set(value) {
            return new WritePropExpr(this.receiver, this.name, value, null, this.sourceSpan);
        }
    }
    class ReadKeyExpr extends Expression {
        constructor(receiver, index, type, sourceSpan) {
            super(type, sourceSpan);
            this.receiver = receiver;
            this.index = index;
        }
        isEquivalent(e) {
            return e instanceof ReadKeyExpr && this.receiver.isEquivalent(e.receiver) &&
                this.index.isEquivalent(e.index);
        }
        isConstant() {
            return false;
        }
        visitExpression(visitor, context) {
            return visitor.visitReadKeyExpr(this, context);
        }
        set(value) {
            return new WriteKeyExpr(this.receiver, this.index, value, null, this.sourceSpan);
        }
    }
    class LiteralArrayExpr extends Expression {
        constructor(entries, type, sourceSpan) {
            super(type, sourceSpan);
            this.entries = entries;
        }
        isConstant() {
            return this.entries.every(e => e.isConstant());
        }
        isEquivalent(e) {
            return e instanceof LiteralArrayExpr && areAllEquivalent(this.entries, e.entries);
        }
        visitExpression(visitor, context) {
            return visitor.visitLiteralArrayExpr(this, context);
        }
    }
    class LiteralMapEntry {
        constructor(key, value, quoted) {
            this.key = key;
            this.value = value;
            this.quoted = quoted;
        }
        isEquivalent(e) {
            return this.key === e.key && this.value.isEquivalent(e.value);
        }
    }
    class LiteralMapExpr extends Expression {
        constructor(entries, type, sourceSpan) {
            super(type, sourceSpan);
            this.entries = entries;
            this.valueType = null;
            if (type) {
                this.valueType = type.valueType;
            }
        }
        isEquivalent(e) {
            return e instanceof LiteralMapExpr && areAllEquivalent(this.entries, e.entries);
        }
        isConstant() {
            return this.entries.every(e => e.value.isConstant());
        }
        visitExpression(visitor, context) {
            return visitor.visitLiteralMapExpr(this, context);
        }
    }
    const THIS_EXPR = new ReadVarExpr(BuiltinVar.This, null, null);
    const SUPER_EXPR = new ReadVarExpr(BuiltinVar.Super, null, null);
    const CATCH_ERROR_VAR = new ReadVarExpr(BuiltinVar.CatchError, null, null);
    const CATCH_STACK_VAR = new ReadVarExpr(BuiltinVar.CatchStack, null, null);
    const NULL_EXPR = new LiteralExpr(null, null, null);
    const TYPED_NULL_EXPR = new LiteralExpr(null, INFERRED_TYPE, null);
    //// Statements
    var StmtModifier;
    (function (StmtModifier) {
        StmtModifier[StmtModifier["Final"] = 0] = "Final";
        StmtModifier[StmtModifier["Private"] = 1] = "Private";
        StmtModifier[StmtModifier["Exported"] = 2] = "Exported";
        StmtModifier[StmtModifier["Static"] = 3] = "Static";
    })(StmtModifier || (StmtModifier = {}));
    class Statement {
        constructor(modifiers, sourceSpan) {
            this.modifiers = modifiers || [];
            this.sourceSpan = sourceSpan || null;
        }
        hasModifier(modifier) {
            return this.modifiers.indexOf(modifier) !== -1;
        }
    }
    class DeclareVarStmt extends Statement {
        constructor(name, value, type, modifiers = null, sourceSpan) {
            super(modifiers, sourceSpan);
            this.name = name;
            this.value = value;
            this.type = type || (value && value.type) || null;
        }
        isEquivalent(stmt) {
            return stmt instanceof DeclareVarStmt && this.name === stmt.name &&
                (this.value ? !!stmt.value && this.value.isEquivalent(stmt.value) : !stmt.value);
        }
        visitStatement(visitor, context) {
            return visitor.visitDeclareVarStmt(this, context);
        }
    }
    class DeclareFunctionStmt extends Statement {
        constructor(name, params, statements, type, modifiers = null, sourceSpan) {
            super(modifiers, sourceSpan);
            this.name = name;
            this.params = params;
            this.statements = statements;
            this.type = type || null;
        }
        isEquivalent(stmt) {
            return stmt instanceof DeclareFunctionStmt && areAllEquivalent(this.params, stmt.params) &&
                areAllEquivalent(this.statements, stmt.statements);
        }
        visitStatement(visitor, context) {
            return visitor.visitDeclareFunctionStmt(this, context);
        }
    }
    class ExpressionStatement extends Statement {
        constructor(expr, sourceSpan) {
            super(null, sourceSpan);
            this.expr = expr;
        }
        isEquivalent(stmt) {
            return stmt instanceof ExpressionStatement && this.expr.isEquivalent(stmt.expr);
        }
        visitStatement(visitor, context) {
            return visitor.visitExpressionStmt(this, context);
        }
    }
    class ReturnStatement extends Statement {
        constructor(value, sourceSpan) {
            super(null, sourceSpan);
            this.value = value;
        }
        isEquivalent(stmt) {
            return stmt instanceof ReturnStatement && this.value.isEquivalent(stmt.value);
        }
        visitStatement(visitor, context) {
            return visitor.visitReturnStmt(this, context);
        }
    }
    class IfStmt extends Statement {
        constructor(condition, trueCase, falseCase = [], sourceSpan) {
            super(null, sourceSpan);
            this.condition = condition;
            this.trueCase = trueCase;
            this.falseCase = falseCase;
        }
        isEquivalent(stmt) {
            return stmt instanceof IfStmt && this.condition.isEquivalent(stmt.condition) &&
                areAllEquivalent(this.trueCase, stmt.trueCase) &&
                areAllEquivalent(this.falseCase, stmt.falseCase);
        }
        visitStatement(visitor, context) {
            return visitor.visitIfStmt(this, context);
        }
    }
    class JSDocCommentStmt extends Statement {
        constructor(tags = [], sourceSpan) {
            super(null, sourceSpan);
            this.tags = tags;
        }
        isEquivalent(stmt) {
            return stmt instanceof JSDocCommentStmt && this.toString() === stmt.toString();
        }
        visitStatement(visitor, context) {
            return visitor.visitJSDocCommentStmt(this, context);
        }
        toString() {
            return serializeTags(this.tags);
        }
    }
    function variable(name, type, sourceSpan) {
        return new ReadVarExpr(name, type, sourceSpan);
    }
    function importExpr(id, typeParams = null, sourceSpan) {
        return new ExternalExpr(id, null, typeParams, sourceSpan);
    }
    function expressionType(expr, typeModifiers = null, typeParams = null) {
        return new ExpressionType(expr, typeModifiers, typeParams);
    }
    function typeofExpr(expr) {
        return new TypeofExpr(expr);
    }
    function literalArr(values, type, sourceSpan) {
        return new LiteralArrayExpr(values, type, sourceSpan);
    }
    function literalMap(values, type = null) {
        return new LiteralMapExpr(values.map(e => new LiteralMapEntry(e.key, e.value, e.quoted)), type, null);
    }
    function not(expr, sourceSpan) {
        return new NotExpr(expr, sourceSpan);
    }
    function assertNotNull(expr, sourceSpan) {
        return new AssertNotNull(expr, sourceSpan);
    }
    function fn(params, body, type, sourceSpan, name) {
        return new FunctionExpr(params, body, type, sourceSpan, name);
    }
    function ifStmt(condition, thenClause, elseClause) {
        return new IfStmt(condition, thenClause, elseClause);
    }
    function literal(value, type, sourceSpan) {
        return new LiteralExpr(value, type, sourceSpan);
    }
    function localizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan) {
        return new LocalizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan);
    }
    function isNull(exp) {
        return exp instanceof LiteralExpr && exp.value === null;
    }
    /*
     * Serializes a `Tag` into a string.
     * Returns a string like " @foo {bar} baz" (note the leading whitespace before `@foo`).
     */
    function tagToString(tag) {
        let out = '';
        if (tag.tagName) {
            out += ` @${tag.tagName}`;
        }
        if (tag.text) {
            if (tag.text.match(/\/\*|\*\//)) {
                throw new Error('JSDoc text cannot contain "/*" and "*/"');
            }
            out += ' ' + tag.text.replace(/@/g, '\\@');
        }
        return out;
    }
    function serializeTags(tags) {
        if (tags.length === 0)
            return '';
        let out = '*\n';
        for (const tag of tags) {
            out += ' *';
            // If the tagToString is multi-line, insert " * " prefixes on subsequent lines.
            out += tagToString(tag).replace(/\n/g, '\n * ');
            out += '\n';
        }
        out += ' ';
        return out;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const DASH_CASE_REGEXP = /-+([a-z0-9])/g;
    function dashCaseToCamelCase(input) {
        return input.replace(DASH_CASE_REGEXP, (...m) => m[1].toUpperCase());
    }
    function splitAtColon(input, defaultValues) {
        return _splitAt(input, ':', defaultValues);
    }
    function splitAtPeriod(input, defaultValues) {
        return _splitAt(input, '.', defaultValues);
    }
    function _splitAt(input, character, defaultValues) {
        const characterIndex = input.indexOf(character);
        if (characterIndex == -1)
            return defaultValues;
        return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];
    }
    function error(msg) {
        throw new Error(`Internal Error: ${msg}`);
    }
    function syntaxError(msg, parseErrors) {
        const error = Error(msg);
        error[ERROR_SYNTAX_ERROR] = true;
        if (parseErrors)
            error[ERROR_PARSE_ERRORS] = parseErrors;
        return error;
    }
    const ERROR_SYNTAX_ERROR = 'ngSyntaxError';
    const ERROR_PARSE_ERRORS = 'ngParseErrors';
    // Escape characters that have a special meaning in Regular Expressions
    function escapeRegExp(s) {
        return s.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
    }
    function utf8Encode(str) {
        let encoded = '';
        for (let index = 0; index < str.length; index++) {
            let codePoint = str.charCodeAt(index);
            // decode surrogate
            // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > (index + 1)) {
                const low = str.charCodeAt(index + 1);
                if (low >= 0xdc00 && low <= 0xdfff) {
                    index++;
                    codePoint = ((codePoint - 0xd800) << 10) + low - 0xdc00 + 0x10000;
                }
            }
            if (codePoint <= 0x7f) {
                encoded += String.fromCharCode(codePoint);
            }
            else if (codePoint <= 0x7ff) {
                encoded += String.fromCharCode(((codePoint >> 6) & 0x1F) | 0xc0, (codePoint & 0x3f) | 0x80);
            }
            else if (codePoint <= 0xffff) {
                encoded += String.fromCharCode((codePoint >> 12) | 0xe0, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);
            }
            else if (codePoint <= 0x1fffff) {
                encoded += String.fromCharCode(((codePoint >> 18) & 0x07) | 0xf0, ((codePoint >> 12) & 0x3f) | 0x80, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);
            }
        }
        return encoded;
    }
    function stringify$1(token) {
        if (typeof token === 'string') {
            return token;
        }
        if (Array.isArray(token)) {
            return '[' + token.map(stringify$1).join(', ') + ']';
        }
        if (token == null) {
            return '' + token;
        }
        if (token.overriddenName) {
            return `${token.overriddenName}`;
        }
        if (token.name) {
            return `${token.name}`;
        }
        if (!token.toString) {
            return 'object';
        }
        // WARNING: do not try to `JSON.stringify(token)` here
        // see https://github.com/angular/angular/issues/23440
        const res = token.toString();
        if (res == null) {
            return '' + res;
        }
        const newLineIndex = res.indexOf('\n');
        return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
    }
    class Version {
        constructor(full) {
            this.full = full;
            const splits = full.split('.');
            this.major = splits[0];
            this.minor = splits[1];
            this.patch = splits.slice(2).join('.');
        }
    }
    const __window = typeof window !== 'undefined' && window;
    const __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&
        self instanceof WorkerGlobalScope && self;
    const __global = typeof global !== 'undefined' && global;
    // Check __global first, because in Node tests both __global and __window may be defined and _global
    // should be __global in that case.
    const _global = __global || __window || __self;
    function newArray(size, value) {
        const list = [];
        for (let i = 0; i < size; i++) {
            list.push(value);
        }
        return list;
    }
    /**
     * Partitions a given array into 2 arrays, based on a boolean value returned by the condition
     * function.
     *
     * @param arr Input array that should be partitioned
     * @param conditionFn Condition function that is called for each item in a given array and returns a
     * boolean value.
     */
    function partitionArray(arr, conditionFn) {
        const truthy = [];
        const falsy = [];
        arr.forEach(item => {
            (conditionFn(item) ? truthy : falsy).push(item);
        });
        return [truthy, falsy];
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const CONSTANT_PREFIX = '_c';
    /**
     * `ConstantPool` tries to reuse literal factories when two or more literals are identical.
     * We determine whether literals are identical by creating a key out of their AST using the
     * `KeyVisitor`. This constant is used to replace dynamic expressions which can't be safely
     * converted into a key. E.g. given an expression `{foo: bar()}`, since we don't know what
     * the result of `bar` will be, we create a key that looks like `{foo: <unknown>}`. Note
     * that we use a variable, rather than something like `null` in order to avoid collisions.
     */
    const UNKNOWN_VALUE_KEY = variable('<unknown>');
    /**
     * Context to use when producing a key.
     *
     * This ensures we see the constant not the reference variable when producing
     * a key.
     */
    const KEY_CONTEXT = {};
    /**
     * Generally all primitive values are excluded from the `ConstantPool`, but there is an exclusion
     * for strings that reach a certain length threshold. This constant defines the length threshold for
     * strings.
     */
    const POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS = 50;
    /**
     * A node that is a place-holder that allows the node to be replaced when the actual
     * node is known.
     *
     * This allows the constant pool to change an expression from a direct reference to
     * a constant to a shared constant. It returns a fix-up node that is later allowed to
     * change the referenced expression.
     */
    class FixupExpression extends Expression {
        constructor(resolved) {
            super(resolved.type);
            this.resolved = resolved;
            this.original = resolved;
        }
        visitExpression(visitor, context) {
            if (context === KEY_CONTEXT) {
                // When producing a key we want to traverse the constant not the
                // variable used to refer to it.
                return this.original.visitExpression(visitor, context);
            }
            else {
                return this.resolved.visitExpression(visitor, context);
            }
        }
        isEquivalent(e) {
            return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);
        }
        isConstant() {
            return true;
        }
        fixup(expression) {
            this.resolved = expression;
            this.shared = true;
        }
    }
    /**
     * A constant pool allows a code emitter to share constant in an output context.
     *
     * The constant pool also supports sharing access to ivy definitions references.
     */
    class ConstantPool {
        constructor(isClosureCompilerEnabled = false) {
            this.isClosureCompilerEnabled = isClosureCompilerEnabled;
            this.statements = [];
            this.literals = new Map();
            this.literalFactories = new Map();
            this.injectorDefinitions = new Map();
            this.directiveDefinitions = new Map();
            this.componentDefinitions = new Map();
            this.pipeDefinitions = new Map();
            this.nextNameIndex = 0;
        }
        getConstLiteral(literal, forceShared) {
            if ((literal instanceof LiteralExpr && !isLongStringLiteral(literal)) ||
                literal instanceof FixupExpression) {
                // Do no put simple literals into the constant pool or try to produce a constant for a
                // reference to a constant.
                return literal;
            }
            const key = this.keyOf(literal);
            let fixup = this.literals.get(key);
            let newValue = false;
            if (!fixup) {
                fixup = new FixupExpression(literal);
                this.literals.set(key, fixup);
                newValue = true;
            }
            if ((!newValue && !fixup.shared) || (newValue && forceShared)) {
                // Replace the expression with a variable
                const name = this.freshName();
                let definition;
                let usage;
                if (this.isClosureCompilerEnabled && isLongStringLiteral(literal)) {
                    // For string literals, Closure will **always** inline the string at
                    // **all** usages, duplicating it each time. For large strings, this
                    // unnecessarily bloats bundle size. To work around this restriction, we
                    // wrap the string in a function, and call that function for each usage.
                    // This tricks Closure into using inline logic for functions instead of
                    // string literals. Function calls are only inlined if the body is small
                    // enough to be worth it. By doing this, very large strings will be
                    // shared across multiple usages, rather than duplicating the string at
                    // each usage site.
                    //
                    // const myStr = function() { return "very very very long string"; };
                    // const usage1 = myStr();
                    // const usage2 = myStr();
                    definition = variable(name).set(new FunctionExpr([], // Params.
                    [
                        // Statements.
                        new ReturnStatement(literal),
                    ]));
                    usage = variable(name).callFn([]);
                }
                else {
                    // Just declare and use the variable directly, without a function call
                    // indirection. This saves a few bytes and avoids an unncessary call.
                    definition = variable(name).set(literal);
                    usage = variable(name);
                }
                this.statements.push(definition.toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]));
                fixup.fixup(usage);
            }
            return fixup;
        }
        getDefinition(type, kind, ctx, forceShared = false) {
            const definitions = this.definitionsOf(kind);
            let fixup = definitions.get(type);
            let newValue = false;
            if (!fixup) {
                const property = this.propertyNameOf(kind);
                fixup = new FixupExpression(ctx.importExpr(type).prop(property));
                definitions.set(type, fixup);
                newValue = true;
            }
            if ((!newValue && !fixup.shared) || (newValue && forceShared)) {
                const name = this.freshName();
                this.statements.push(variable(name).set(fixup.resolved).toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]));
                fixup.fixup(variable(name));
            }
            return fixup;
        }
        getLiteralFactory(literal) {
            // Create a pure function that builds an array of a mix of constant and variable expressions
            if (literal instanceof LiteralArrayExpr) {
                const argumentsForKey = literal.entries.map(e => e.isConstant() ? e : UNKNOWN_VALUE_KEY);
                const key = this.keyOf(literalArr(argumentsForKey));
                return this._getLiteralFactory(key, literal.entries, entries => literalArr(entries));
            }
            else {
                const expressionForKey = literalMap(literal.entries.map(e => ({
                    key: e.key,
                    value: e.value.isConstant() ? e.value : UNKNOWN_VALUE_KEY,
                    quoted: e.quoted
                })));
                const key = this.keyOf(expressionForKey);
                return this._getLiteralFactory(key, literal.entries.map(e => e.value), entries => literalMap(entries.map((value, index) => ({
                    key: literal.entries[index].key,
                    value,
                    quoted: literal.entries[index].quoted
                }))));
            }
        }
        _getLiteralFactory(key, values, resultMap) {
            let literalFactory = this.literalFactories.get(key);
            const literalFactoryArguments = values.filter((e => !e.isConstant()));
            if (!literalFactory) {
                const resultExpressions = values.map((e, index) => e.isConstant() ? this.getConstLiteral(e, true) : variable(`a${index}`));
                const parameters = resultExpressions.filter(isVariable).map(e => new FnParam(e.name, DYNAMIC_TYPE));
                const pureFunctionDeclaration = fn(parameters, [new ReturnStatement(resultMap(resultExpressions))], INFERRED_TYPE);
                const name = this.freshName();
                this.statements.push(variable(name).set(pureFunctionDeclaration).toDeclStmt(INFERRED_TYPE, [
                    StmtModifier.Final
                ]));
                literalFactory = variable(name);
                this.literalFactories.set(key, literalFactory);
            }
            return { literalFactory, literalFactoryArguments };
        }
        /**
         * Produce a unique name.
         *
         * The name might be unique among different prefixes if any of the prefixes end in
         * a digit so the prefix should be a constant string (not based on user input) and
         * must not end in a digit.
         */
        uniqueName(prefix) {
            return `${prefix}${this.nextNameIndex++}`;
        }
        definitionsOf(kind) {
            switch (kind) {
                case 2 /* Component */:
                    return this.componentDefinitions;
                case 1 /* Directive */:
                    return this.directiveDefinitions;
                case 0 /* Injector */:
                    return this.injectorDefinitions;
                case 3 /* Pipe */:
                    return this.pipeDefinitions;
            }
            error(`Unknown definition kind ${kind}`);
            return this.componentDefinitions;
        }
        propertyNameOf(kind) {
            switch (kind) {
                case 2 /* Component */:
                    return 'cmp';
                case 1 /* Directive */:
                    return 'dir';
                case 0 /* Injector */:
                    return 'inj';
                case 3 /* Pipe */:
                    return 'pipe';
            }
            error(`Unknown definition kind ${kind}`);
            return '<unknown>';
        }
        freshName() {
            return this.uniqueName(CONSTANT_PREFIX);
        }
        keyOf(expression) {
            return expression.visitExpression(new KeyVisitor(), KEY_CONTEXT);
        }
    }
    /**
     * Visitor used to determine if 2 expressions are equivalent and can be shared in the
     * `ConstantPool`.
     *
     * When the id (string) generated by the visitor is equal, expressions are considered equivalent.
     */
    class KeyVisitor {
        constructor() {
            this.visitWrappedNodeExpr = invalid;
            this.visitWriteVarExpr = invalid;
            this.visitWriteKeyExpr = invalid;
            this.visitWritePropExpr = invalid;
            this.visitInvokeMethodExpr = invalid;
            this.visitInvokeFunctionExpr = invalid;
            this.visitInstantiateExpr = invalid;
            this.visitConditionalExpr = invalid;
            this.visitNotExpr = invalid;
            this.visitAssertNotNullExpr = invalid;
            this.visitCastExpr = invalid;
            this.visitFunctionExpr = invalid;
            this.visitBinaryOperatorExpr = invalid;
            this.visitReadPropExpr = invalid;
            this.visitReadKeyExpr = invalid;
            this.visitCommaExpr = invalid;
            this.visitLocalizedString = invalid;
        }
        visitLiteralExpr(ast) {
            return `${typeof ast.value === 'string' ? '"' + ast.value + '"' : ast.value}`;
        }
        visitLiteralArrayExpr(ast, context) {
            return `[${ast.entries.map(entry => entry.visitExpression(this, context)).join(',')}]`;
        }
        visitLiteralMapExpr(ast, context) {
            const mapKey = (entry) => {
                const quote = entry.quoted ? '"' : '';
                return `${quote}${entry.key}${quote}`;
            };
            const mapEntry = (entry) => `${mapKey(entry)}:${entry.value.visitExpression(this, context)}`;
            return `{${ast.entries.map(mapEntry).join(',')}`;
        }
        visitExternalExpr(ast) {
            return ast.value.moduleName ? `EX:${ast.value.moduleName}:${ast.value.name}` :
                `EX:${ast.value.runtime.name}`;
        }
        visitReadVarExpr(node) {
            return `VAR:${node.name}`;
        }
        visitTypeofExpr(node, context) {
            return `TYPEOF:${node.expr.visitExpression(this, context)}`;
        }
    }
    function invalid(arg) {
        throw new Error(`Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);
    }
    function isVariable(e) {
        return e instanceof ReadVarExpr;
    }
    function isLongStringLiteral(expr) {
        return expr instanceof LiteralExpr && typeof expr.value === 'string' &&
            expr.value.length >= POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const CORE = '@angular/core';
    class Identifiers {
    }
    Identifiers.ANALYZE_FOR_ENTRY_COMPONENTS = {
        name: 'ANALYZE_FOR_ENTRY_COMPONENTS',
        moduleName: CORE,
    };
    Identifiers.ElementRef = { name: 'ElementRef', moduleName: CORE };
    Identifiers.NgModuleRef = { name: 'NgModuleRef', moduleName: CORE };
    Identifiers.ViewContainerRef = { name: 'ViewContainerRef', moduleName: CORE };
    Identifiers.ChangeDetectorRef = {
        name: 'ChangeDetectorRef',
        moduleName: CORE,
    };
    Identifiers.QueryList = { name: 'QueryList', moduleName: CORE };
    Identifiers.TemplateRef = { name: 'TemplateRef', moduleName: CORE };
    Identifiers.Renderer2 = { name: 'Renderer2', moduleName: CORE };
    Identifiers.CodegenComponentFactoryResolver = {
        name: 'CodegenComponentFactoryResolver',
        moduleName: CORE,
    };
    Identifiers.ComponentFactoryResolver = {
        name: 'ComponentFactoryResolver',
        moduleName: CORE,
    };
    Identifiers.ComponentFactory = { name: 'ComponentFactory', moduleName: CORE };
    Identifiers.ComponentRef = { name: 'ComponentRef', moduleName: CORE };
    Identifiers.NgModuleFactory = { name: 'NgModuleFactory', moduleName: CORE };
    Identifiers.createModuleFactory = {
        name: 'cmf',
        moduleName: CORE,
    };
    Identifiers.moduleDef = {
        name: 'mod',
        moduleName: CORE,
    };
    Identifiers.moduleProviderDef = {
        name: 'mpd',
        moduleName: CORE,
    };
    Identifiers.RegisterModuleFactoryFn = {
        name: 'registerModuleFactory',
        moduleName: CORE,
    };
    Identifiers.inject = { name: 'inject', moduleName: CORE };
    Identifiers.directiveInject = { name: 'directiveInject', moduleName: CORE };
    Identifiers.INJECTOR = { name: 'INJECTOR', moduleName: CORE };
    Identifiers.Injector = { name: 'Injector', moduleName: CORE };
    Identifiers.defineInjectable = { name: 'defineInjectable', moduleName: CORE };
    Identifiers.InjectableDef = { name: 'InjectableDef', moduleName: CORE };
    Identifiers.ViewEncapsulation = {
        name: 'ViewEncapsulation',
        moduleName: CORE,
    };
    Identifiers.ChangeDetectionStrategy = {
        name: 'ChangeDetectionStrategy',
        moduleName: CORE,
    };
    Identifiers.SecurityContext = {
        name: 'SecurityContext',
        moduleName: CORE,
    };
    Identifiers.LOCALE_ID = { name: 'LOCALE_ID', moduleName: CORE };
    Identifiers.TRANSLATIONS_FORMAT = {
        name: 'TRANSLATIONS_FORMAT',
        moduleName: CORE,
    };
    Identifiers.inlineInterpolate = {
        name: 'inlineInterpolate',
        moduleName: CORE,
    };
    Identifiers.interpolate = { name: 'interpolate', moduleName: CORE };
    Identifiers.EMPTY_ARRAY = { name: 'EMPTY_ARRAY', moduleName: CORE };
    Identifiers.EMPTY_MAP = { name: 'EMPTY_MAP', moduleName: CORE };
    Identifiers.Renderer = { name: 'Renderer', moduleName: CORE };
    Identifiers.viewDef = { name: 'vid', moduleName: CORE };
    Identifiers.elementDef = { name: 'eld', moduleName: CORE };
    Identifiers.anchorDef = { name: 'and', moduleName: CORE };
    Identifiers.textDef = { name: 'ted', moduleName: CORE };
    Identifiers.directiveDef = { name: 'did', moduleName: CORE };
    Identifiers.providerDef = { name: 'prd', moduleName: CORE };
    Identifiers.queryDef = { name: 'qud', moduleName: CORE };
    Identifiers.pureArrayDef = { name: 'pad', moduleName: CORE };
    Identifiers.pureObjectDef = { name: 'pod', moduleName: CORE };
    Identifiers.purePipeDef = { name: 'ppd', moduleName: CORE };
    Identifiers.pipeDef = { name: 'pid', moduleName: CORE };
    Identifiers.nodeValue = { name: 'nov', moduleName: CORE };
    Identifiers.ngContentDef = { name: 'ncd', moduleName: CORE };
    Identifiers.unwrapValue = { name: 'unv', moduleName: CORE };
    Identifiers.createRendererType2 = { name: 'crt', moduleName: CORE };
    // type only
    Identifiers.RendererType2 = {
        name: 'RendererType2',
        moduleName: CORE,
    };
    // type only
    Identifiers.ViewDefinition = {
        name: 'ViewDefinition',
        moduleName: CORE,
    };
    Identifiers.createComponentFactory = { name: 'ccf', moduleName: CORE };
    Identifiers.setClassMetadata = { name: 'setClassMetadata', moduleName: CORE };

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A token representing the a reference to a static type.
     *
     * This token is unique for a filePath and name and can be used as a hash table key.
     */
    class StaticSymbol {
        constructor(filePath, name, members) {
            this.filePath = filePath;
            this.name = name;
            this.members = members;
        }
        assertNoMembers() {
            if (this.members.length) {
                throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);
            }
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function sanitizeIdentifier(name) {
        return name.replace(/\W/g, '_');
    }
    let _anonymousTypeIndex = 0;
    function identifierName(compileIdentifier) {
        if (!compileIdentifier || !compileIdentifier.reference) {
            return null;
        }
        const ref = compileIdentifier.reference;
        if (ref instanceof StaticSymbol) {
            return ref.name;
        }
        if (ref['__anonymousType']) {
            return ref['__anonymousType'];
        }
        let identifier = stringify$1(ref);
        if (identifier.indexOf('(') >= 0) {
            // case: anonymous functions!
            identifier = `anonymous_${_anonymousTypeIndex++}`;
            ref['__anonymousType'] = identifier;
        }
        else {
            identifier = sanitizeIdentifier(identifier);
        }
        return identifier;
    }
    var CompileSummaryKind;
    (function (CompileSummaryKind) {
        CompileSummaryKind[CompileSummaryKind["Pipe"] = 0] = "Pipe";
        CompileSummaryKind[CompileSummaryKind["Directive"] = 1] = "Directive";
        CompileSummaryKind[CompileSummaryKind["NgModule"] = 2] = "NgModule";
        CompileSummaryKind[CompileSummaryKind["Injectable"] = 3] = "Injectable";
    })(CompileSummaryKind || (CompileSummaryKind = {}));
    function flatten(list) {
        return list.reduce((flat, item) => {
            const flatItem = Array.isArray(item) ? flatten(item) : item;
            return flat.concat(flatItem);
        }, []);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const CORE$1 = '@angular/core';
    class Identifiers$1 {
    }
    /* Methods */
    Identifiers$1.NEW_METHOD = 'factory';
    Identifiers$1.TRANSFORM_METHOD = 'transform';
    Identifiers$1.PATCH_DEPS = 'patchedDeps';
    /* Instructions */
    Identifiers$1.namespaceHTML = { name: 'namespaceHTML', moduleName: CORE$1 };
    Identifiers$1.namespaceMathML = { name: 'namespaceMathML', moduleName: CORE$1 };
    Identifiers$1.namespaceSVG = { name: 'namespaceSVG', moduleName: CORE$1 };
    Identifiers$1.element = { name: 'element', moduleName: CORE$1 };
    Identifiers$1.elementStart = { name: 'elementStart', moduleName: CORE$1 };
    Identifiers$1.elementEnd = { name: 'elementEnd', moduleName: CORE$1 };
    Identifiers$1.select = { name: 'select', moduleName: CORE$1 };
    Identifiers$1.advance = { name: 'advance', moduleName: CORE$1 };
    Identifiers$1.syntheticHostProperty = { name: 'syntheticHostProperty', moduleName: CORE$1 };
    Identifiers$1.syntheticHostListener = { name: 'syntheticHostListener', moduleName: CORE$1 };
    Identifiers$1.attribute = { name: 'attribute', moduleName: CORE$1 };
    Identifiers$1.attributeInterpolate1 = { name: 'attributeInterpolate1', moduleName: CORE$1 };
    Identifiers$1.attributeInterpolate2 = { name: 'attributeInterpolate2', moduleName: CORE$1 };
    Identifiers$1.attributeInterpolate3 = { name: 'attributeInterpolate3', moduleName: CORE$1 };
    Identifiers$1.attributeInterpolate4 = { name: 'attributeInterpolate4', moduleName: CORE$1 };
    Identifiers$1.attributeInterpolate5 = { name: 'attributeInterpolate5', moduleName: CORE$1 };
    Identifiers$1.attributeInterpolate6 = { name: 'attributeInterpolate6', moduleName: CORE$1 };
    Identifiers$1.attributeInterpolate7 = { name: 'attributeInterpolate7', moduleName: CORE$1 };
    Identifiers$1.attributeInterpolate8 = { name: 'attributeInterpolate8', moduleName: CORE$1 };
    Identifiers$1.attributeInterpolateV = { name: 'attributeInterpolateV', moduleName: CORE$1 };
    Identifiers$1.classProp = { name: 'classProp', moduleName: CORE$1 };
    Identifiers$1.elementContainerStart = { name: 'elementContainerStart', moduleName: CORE$1 };
    Identifiers$1.elementContainerEnd = { name: 'elementContainerEnd', moduleName: CORE$1 };
    Identifiers$1.elementContainer = { name: 'elementContainer', moduleName: CORE$1 };
    Identifiers$1.styleMap = { name: 'styleMap', moduleName: CORE$1 };
    Identifiers$1.styleMapInterpolate1 = { name: 'styleMapInterpolate1', moduleName: CORE$1 };
    Identifiers$1.styleMapInterpolate2 = { name: 'styleMapInterpolate2', moduleName: CORE$1 };
    Identifiers$1.styleMapInterpolate3 = { name: 'styleMapInterpolate3', moduleName: CORE$1 };
    Identifiers$1.styleMapInterpolate4 = { name: 'styleMapInterpolate4', moduleName: CORE$1 };
    Identifiers$1.styleMapInterpolate5 = { name: 'styleMapInterpolate5', moduleName: CORE$1 };
    Identifiers$1.styleMapInterpolate6 = { name: 'styleMapInterpolate6', moduleName: CORE$1 };
    Identifiers$1.styleMapInterpolate7 = { name: 'styleMapInterpolate7', moduleName: CORE$1 };
    Identifiers$1.styleMapInterpolate8 = { name: 'styleMapInterpolate8', moduleName: CORE$1 };
    Identifiers$1.styleMapInterpolateV = { name: 'styleMapInterpolateV', moduleName: CORE$1 };
    Identifiers$1.classMap = { name: 'classMap', moduleName: CORE$1 };
    Identifiers$1.classMapInterpolate1 = { name: 'classMapInterpolate1', moduleName: CORE$1 };
    Identifiers$1.classMapInterpolate2 = { name: 'classMapInterpolate2', moduleName: CORE$1 };
    Identifiers$1.classMapInterpolate3 = { name: 'classMapInterpolate3', moduleName: CORE$1 };
    Identifiers$1.classMapInterpolate4 = { name: 'classMapInterpolate4', moduleName: CORE$1 };
    Identifiers$1.classMapInterpolate5 = { name: 'classMapInterpolate5', moduleName: CORE$1 };
    Identifiers$1.classMapInterpolate6 = { name: 'classMapInterpolate6', moduleName: CORE$1 };
    Identifiers$1.classMapInterpolate7 = { name: 'classMapInterpolate7', moduleName: CORE$1 };
    Identifiers$1.classMapInterpolate8 = { name: 'classMapInterpolate8', moduleName: CORE$1 };
    Identifiers$1.classMapInterpolateV = { name: 'classMapInterpolateV', moduleName: CORE$1 };
    Identifiers$1.styleProp = { name: 'styleProp', moduleName: CORE$1 };
    Identifiers$1.stylePropInterpolate1 = { name: 'stylePropInterpolate1', moduleName: CORE$1 };
    Identifiers$1.stylePropInterpolate2 = { name: 'stylePropInterpolate2', moduleName: CORE$1 };
    Identifiers$1.stylePropInterpolate3 = { name: 'stylePropInterpolate3', moduleName: CORE$1 };
    Identifiers$1.stylePropInterpolate4 = { name: 'stylePropInterpolate4', moduleName: CORE$1 };
    Identifiers$1.stylePropInterpolate5 = { name: 'stylePropInterpolate5', moduleName: CORE$1 };
    Identifiers$1.stylePropInterpolate6 = { name: 'stylePropInterpolate6', moduleName: CORE$1 };
    Identifiers$1.stylePropInterpolate7 = { name: 'stylePropInterpolate7', moduleName: CORE$1 };
    Identifiers$1.stylePropInterpolate8 = { name: 'stylePropInterpolate8', moduleName: CORE$1 };
    Identifiers$1.stylePropInterpolateV = { name: 'stylePropInterpolateV', moduleName: CORE$1 };
    Identifiers$1.nextContext = { name: 'nextContext', moduleName: CORE$1 };
    Identifiers$1.templateCreate = { name: 'template', moduleName: CORE$1 };
    Identifiers$1.text = { name: 'text', moduleName: CORE$1 };
    Identifiers$1.enableBindings = { name: 'enableBindings', moduleName: CORE$1 };
    Identifiers$1.disableBindings = { name: 'disableBindings', moduleName: CORE$1 };
    Identifiers$1.getCurrentView = { name: 'getCurrentView', moduleName: CORE$1 };
    Identifiers$1.textInterpolate = { name: 'textInterpolate', moduleName: CORE$1 };
    Identifiers$1.textInterpolate1 = { name: 'textInterpolate1', moduleName: CORE$1 };
    Identifiers$1.textInterpolate2 = { name: 'textInterpolate2', moduleName: CORE$1 };
    Identifiers$1.textInterpolate3 = { name: 'textInterpolate3', moduleName: CORE$1 };
    Identifiers$1.textInterpolate4 = { name: 'textInterpolate4', moduleName: CORE$1 };
    Identifiers$1.textInterpolate5 = { name: 'textInterpolate5', moduleName: CORE$1 };
    Identifiers$1.textInterpolate6 = { name: 'textInterpolate6', moduleName: CORE$1 };
    Identifiers$1.textInterpolate7 = { name: 'textInterpolate7', moduleName: CORE$1 };
    Identifiers$1.textInterpolate8 = { name: 'textInterpolate8', moduleName: CORE$1 };
    Identifiers$1.textInterpolateV = { name: 'textInterpolateV', moduleName: CORE$1 };
    Identifiers$1.restoreView = { name: 'restoreView', moduleName: CORE$1 };
    Identifiers$1.pureFunction0 = { name: 'pureFunction0', moduleName: CORE$1 };
    Identifiers$1.pureFunction1 = { name: 'pureFunction1', moduleName: CORE$1 };
    Identifiers$1.pureFunction2 = { name: 'pureFunction2', moduleName: CORE$1 };
    Identifiers$1.pureFunction3 = { name: 'pureFunction3', moduleName: CORE$1 };
    Identifiers$1.pureFunction4 = { name: 'pureFunction4', moduleName: CORE$1 };
    Identifiers$1.pureFunction5 = { name: 'pureFunction5', moduleName: CORE$1 };
    Identifiers$1.pureFunction6 = { name: 'pureFunction6', moduleName: CORE$1 };
    Identifiers$1.pureFunction7 = { name: 'pureFunction7', moduleName: CORE$1 };
    Identifiers$1.pureFunction8 = { name: 'pureFunction8', moduleName: CORE$1 };
    Identifiers$1.pureFunctionV = { name: 'pureFunctionV', moduleName: CORE$1 };
    Identifiers$1.pipeBind1 = { name: 'pipeBind1', moduleName: CORE$1 };
    Identifiers$1.pipeBind2 = { name: 'pipeBind2', moduleName: CORE$1 };
    Identifiers$1.pipeBind3 = { name: 'pipeBind3', moduleName: CORE$1 };
    Identifiers$1.pipeBind4 = { name: 'pipeBind4', moduleName: CORE$1 };
    Identifiers$1.pipeBindV = { name: 'pipeBindV', moduleName: CORE$1 };
    Identifiers$1.hostProperty = { name: 'hostProperty', moduleName: CORE$1 };
    Identifiers$1.property = { name: 'property', moduleName: CORE$1 };
    Identifiers$1.propertyInterpolate = { name: 'propertyInterpolate', moduleName: CORE$1 };
    Identifiers$1.propertyInterpolate1 = { name: 'propertyInterpolate1', moduleName: CORE$1 };
    Identifiers$1.propertyInterpolate2 = { name: 'propertyInterpolate2', moduleName: CORE$1 };
    Identifiers$1.propertyInterpolate3 = { name: 'propertyInterpolate3', moduleName: CORE$1 };
    Identifiers$1.propertyInterpolate4 = { name: 'propertyInterpolate4', moduleName: CORE$1 };
    Identifiers$1.propertyInterpolate5 = { name: 'propertyInterpolate5', moduleName: CORE$1 };
    Identifiers$1.propertyInterpolate6 = { name: 'propertyInterpolate6', moduleName: CORE$1 };
    Identifiers$1.propertyInterpolate7 = { name: 'propertyInterpolate7', moduleName: CORE$1 };
    Identifiers$1.propertyInterpolate8 = { name: 'propertyInterpolate8', moduleName: CORE$1 };
    Identifiers$1.propertyInterpolateV = { name: 'propertyInterpolateV', moduleName: CORE$1 };
    Identifiers$1.i18n = { name: 'i18n', moduleName: CORE$1 };
    Identifiers$1.i18nAttributes = { name: 'i18nAttributes', moduleName: CORE$1 };
    Identifiers$1.i18nExp = { name: 'i18nExp', moduleName: CORE$1 };
    Identifiers$1.i18nStart = { name: 'i18nStart', moduleName: CORE$1 };
    Identifiers$1.i18nEnd = { name: 'i18nEnd', moduleName: CORE$1 };
    Identifiers$1.i18nApply = { name: 'i18nApply', moduleName: CORE$1 };
    Identifiers$1.i18nPostprocess = { name: 'i18nPostprocess', moduleName: CORE$1 };
    Identifiers$1.pipe = { name: 'pipe', moduleName: CORE$1 };
    Identifiers$1.projection = { name: 'projection', moduleName: CORE$1 };
    Identifiers$1.projectionDef = { name: 'projectionDef', moduleName: CORE$1 };
    Identifiers$1.reference = { name: 'reference', moduleName: CORE$1 };
    Identifiers$1.inject = { name: 'inject', moduleName: CORE$1 };
    Identifiers$1.injectAttribute = { name: 'injectAttribute', moduleName: CORE$1 };
    Identifiers$1.injectPipeChangeDetectorRef = { name: 'injectPipeChangeDetectorRef', moduleName: CORE$1 };
    Identifiers$1.directiveInject = { name: 'directiveInject', moduleName: CORE$1 };
    Identifiers$1.invalidFactory = { name: 'invalidFactory', moduleName: CORE$1 };
    Identifiers$1.invalidFactoryDep = { name: 'invalidFactoryDep', moduleName: CORE$1 };
    Identifiers$1.templateRefExtractor = { name: 'templateRefExtractor', moduleName: CORE$1 };
    Identifiers$1.resolveWindow = { name: 'resolveWindow', moduleName: CORE$1 };
    Identifiers$1.resolveDocument = { name: 'resolveDocument', moduleName: CORE$1 };
    Identifiers$1.resolveBody = { name: 'resolveBody', moduleName: CORE$1 };
    Identifiers$1.defineComponent = { name: 'defineComponent', moduleName: CORE$1 };
    Identifiers$1.setComponentScope = { name: 'setComponentScope', moduleName: CORE$1 };
    Identifiers$1.ComponentDefWithMeta = {
        name: 'ComponentDefWithMeta',
        moduleName: CORE$1,
    };
    Identifiers$1.FactoryDef = {
        name: 'FactoryDef',
        moduleName: CORE$1,
    };
    Identifiers$1.defineDirective = {
        name: 'defineDirective',
        moduleName: CORE$1,
    };
    Identifiers$1.DirectiveDefWithMeta = {
        name: 'DirectiveDefWithMeta',
        moduleName: CORE$1,
    };
    Identifiers$1.InjectorDef = {
        name: 'InjectorDef',
        moduleName: CORE$1,
    };
    Identifiers$1.defineInjector = {
        name: 'defineInjector',
        moduleName: CORE$1,
    };
    Identifiers$1.NgModuleDefWithMeta = {
        name: 'NgModuleDefWithMeta',
        moduleName: CORE$1,
    };
    Identifiers$1.ModuleWithProviders = {
        name: 'ModuleWithProviders',
        moduleName: CORE$1,
    };
    Identifiers$1.defineNgModule = { name: 'defineNgModule', moduleName: CORE$1 };
    Identifiers$1.setNgModuleScope = { name: 'setNgModuleScope', moduleName: CORE$1 };
    Identifiers$1.PipeDefWithMeta = { name: 'PipeDefWithMeta', moduleName: CORE$1 };
    Identifiers$1.definePipe = { name: 'definePipe', moduleName: CORE$1 };
    Identifiers$1.queryRefresh = { name: 'queryRefresh', moduleName: CORE$1 };
    Identifiers$1.viewQuery = { name: 'viewQuery', moduleName: CORE$1 };
    Identifiers$1.staticViewQuery = { name: 'staticViewQuery', moduleName: CORE$1 };
    Identifiers$1.staticContentQuery = { name: 'staticContentQuery', moduleName: CORE$1 };
    Identifiers$1.loadQuery = { name: 'loadQuery', moduleName: CORE$1 };
    Identifiers$1.contentQuery = { name: 'contentQuery', moduleName: CORE$1 };
    Identifiers$1.NgOnChangesFeature = { name: 'NgOnChangesFeature', moduleName: CORE$1 };
    Identifiers$1.InheritDefinitionFeature = { name: 'InheritDefinitionFeature', moduleName: CORE$1 };
    Identifiers$1.CopyDefinitionFeature = { name: 'CopyDefinitionFeature', moduleName: CORE$1 };
    Identifiers$1.ProvidersFeature = { name: 'ProvidersFeature', moduleName: CORE$1 };
    Identifiers$1.listener = { name: 'listener', moduleName: CORE$1 };
    Identifiers$1.getFactoryOf = {
        name: 'getFactoryOf',
        moduleName: CORE$1,
    };
    Identifiers$1.getInheritedFactory = {
        name: 'getInheritedFactory',
        moduleName: CORE$1,
    };
    // sanitization-related functions
    Identifiers$1.sanitizeHtml = { name: 'sanitizeHtml', moduleName: CORE$1 };
    Identifiers$1.sanitizeStyle = { name: 'sanitizeStyle', moduleName: CORE$1 };
    Identifiers$1.sanitizeResourceUrl = { name: 'sanitizeResourceUrl', moduleName: CORE$1 };
    Identifiers$1.sanitizeScript = { name: 'sanitizeScript', moduleName: CORE$1 };
    Identifiers$1.sanitizeUrl = { name: 'sanitizeUrl', moduleName: CORE$1 };
    Identifiers$1.sanitizeUrlOrResourceUrl = { name: 'sanitizeUrlOrResourceUrl', moduleName: CORE$1 };

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Convert an object map with `Expression` values into a `LiteralMapExpr`.
     */
    function mapToMapExpression(map) {
        const result = Object.keys(map).map(key => ({
            key,
            // The assertion here is because really TypeScript doesn't allow us to express that if the
            // key is present, it will have a value, but this is true in reality.
            value: map[key],
            quoted: false,
        }));
        return literalMap(result);
    }
    function typeWithParameters(type, numParams) {
        let params = null;
        if (numParams > 0) {
            params = [];
            for (let i = 0; i < numParams; i++) {
                params.push(DYNAMIC_TYPE);
            }
        }
        return expressionType(type, null, params);
    }
    const ANIMATE_SYMBOL_PREFIX = '@';
    function prepareSyntheticPropertyName(name) {
        return `${ANIMATE_SYMBOL_PREFIX}${name}`;
    }
    function prepareSyntheticListenerName(name, phase) {
        return `${ANIMATE_SYMBOL_PREFIX}${name}.${phase}`;
    }
    function prepareSyntheticListenerFunctionName(name, phase) {
        return `animation_${name}_${phase}`;
    }
    function jitOnlyGuardedExpression(expr) {
        const ngJitMode = new ExternalExpr({ name: 'ngJitMode', moduleName: null });
        const jitFlagNotDefined = new BinaryOperatorExpr(BinaryOperator.Identical, new TypeofExpr(ngJitMode), literal('undefined'));
        const jitFlagUndefinedOrTrue = new BinaryOperatorExpr(BinaryOperator.Or, jitFlagNotDefined, ngJitMode, /* type */ undefined, 
        /* sourceSpan */ undefined, true);
        return new BinaryOperatorExpr(BinaryOperator.And, jitFlagUndefinedOrTrue, expr);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const $EOF = 0;
    const $BSPACE = 8;
    const $TAB = 9;
    const $LF = 10;
    const $VTAB = 11;
    const $FF = 12;
    const $CR = 13;
    const $SPACE = 32;
    const $BANG = 33;
    const $DQ = 34;
    const $HASH = 35;
    const $$ = 36;
    const $PERCENT = 37;
    const $AMPERSAND = 38;
    const $SQ = 39;
    const $LPAREN = 40;
    const $RPAREN = 41;
    const $STAR = 42;
    const $PLUS = 43;
    const $COMMA = 44;
    const $MINUS = 45;
    const $PERIOD = 46;
    const $SLASH = 47;
    const $COLON = 58;
    const $SEMICOLON = 59;
    const $LT = 60;
    const $EQ = 61;
    const $GT = 62;
    const $QUESTION = 63;
    const $0 = 48;
    const $7 = 55;
    const $9 = 57;
    const $A = 65;
    const $E = 69;
    const $F = 70;
    const $X = 88;
    const $Z = 90;
    const $LBRACKET = 91;
    const $BACKSLASH = 92;
    const $RBRACKET = 93;
    const $CARET = 94;
    const $_ = 95;
    const $a = 97;
    const $b = 98;
    const $e = 101;
    const $f = 102;
    const $n = 110;
    const $r = 114;
    const $t = 116;
    const $u = 117;
    const $v = 118;
    const $x = 120;
    const $z = 122;
    const $LBRACE = 123;
    const $BAR = 124;
    const $RBRACE = 125;
    const $NBSP = 160;
    const $BT = 96;
    function isWhitespace(code) {
        return (code >= $TAB && code <= $SPACE) || (code == $NBSP);
    }
    function isDigit(code) {
        return $0 <= code && code <= $9;
    }
    function isAsciiLetter(code) {
        return code >= $a && code <= $z || code >= $A && code <= $Z;
    }
    function isAsciiHexDigit(code) {
        return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);
    }
    function isNewLine(code) {
        return code === $LF || code === $CR;
    }
    function isOctalDigit(code) {
        return $0 <= code && code <= $7;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class ParseLocation {
        constructor(file, offset, line, col) {
            this.file = file;
            this.offset = offset;
            this.line = line;
            this.col = col;
        }
        toString() {
            return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
        }
        moveBy(delta) {
            const source = this.file.content;
            const len = source.length;
            let offset = this.offset;
            let line = this.line;
            let col = this.col;
            while (offset > 0 && delta < 0) {
                offset--;
                delta++;
                const ch = source.charCodeAt(offset);
                if (ch == $LF) {
                    line--;
                    const priorLine = source.substr(0, offset - 1).lastIndexOf(String.fromCharCode($LF));
                    col = priorLine > 0 ? offset - priorLine : offset;
                }
                else {
                    col--;
                }
            }
            while (offset < len && delta > 0) {
                const ch = source.charCodeAt(offset);
                offset++;
                delta--;
                if (ch == $LF) {
                    line++;
                    col = 0;
                }
                else {
                    col++;
                }
            }
            return new ParseLocation(this.file, offset, line, col);
        }
        // Return the source around the location
        // Up to `maxChars` or `maxLines` on each side of the location
        getContext(maxChars, maxLines) {
            const content = this.file.content;
            let startOffset = this.offset;
            if (startOffset != null) {
                if (startOffset > content.length - 1) {
                    startOffset = content.length - 1;
                }
                let endOffset = startOffset;
                let ctxChars = 0;
                let ctxLines = 0;
                while (ctxChars < maxChars && startOffset > 0) {
                    startOffset--;
                    ctxChars++;
                    if (content[startOffset] == '\n') {
                        if (++ctxLines == maxLines) {
                            break;
                        }
                    }
                }
                ctxChars = 0;
                ctxLines = 0;
                while (ctxChars < maxChars && endOffset < content.length - 1) {
                    endOffset++;
                    ctxChars++;
                    if (content[endOffset] == '\n') {
                        if (++ctxLines == maxLines) {
                            break;
                        }
                    }
                }
                return {
                    before: content.substring(startOffset, this.offset),
                    after: content.substring(this.offset, endOffset + 1),
                };
            }
            return null;
        }
    }
    class ParseSourceFile {
        constructor(content, url) {
            this.content = content;
            this.url = url;
        }
    }
    class ParseSourceSpan {
        constructor(start, end, details = null) {
            this.start = start;
            this.end = end;
            this.details = details;
        }
        toString() {
            return this.start.file.content.substring(this.start.offset, this.end.offset);
        }
    }
    var ParseErrorLevel;
    (function (ParseErrorLevel) {
        ParseErrorLevel[ParseErrorLevel["WARNING"] = 0] = "WARNING";
        ParseErrorLevel[ParseErrorLevel["ERROR"] = 1] = "ERROR";
    })(ParseErrorLevel || (ParseErrorLevel = {}));
    class ParseError {
        constructor(span, msg, level = ParseErrorLevel.ERROR) {
            this.span = span;
            this.msg = msg;
            this.level = level;
        }
        contextualMessage() {
            const ctx = this.span.start.getContext(100, 3);
            return ctx ? `${this.msg} ("${ctx.before}[${ParseErrorLevel[this.level]} ->]${ctx.after}")` :
                this.msg;
        }
        toString() {
            const details = this.span.details ? `, ${this.span.details}` : '';
            return `${this.contextualMessage()}: ${this.span.start}${details}`;
        }
    }
    /**
     * Generates Source Span object for a given R3 Type for JIT mode.
     *
     * @param kind Component or Directive.
     * @param typeName name of the Component or Directive.
     * @param sourceUrl reference to Component or Directive source.
     * @returns instance of ParseSourceSpan that represent a given Component or Directive.
     */
    function r3JitTypeSourceSpan(kind, typeName, sourceUrl) {
        const sourceFileName = `in ${kind} ${typeName} in ${sourceUrl}`;
        const sourceFile = new ParseSourceFile('', sourceFileName);
        return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class Text {
        constructor(value, sourceSpan) {
            this.value = value;
            this.sourceSpan = sourceSpan;
        }
        visit(visitor) {
            return visitor.visitText(this);
        }
    }
    class BoundText {
        constructor(value, sourceSpan, i18n) {
            this.value = value;
            this.sourceSpan = sourceSpan;
            this.i18n = i18n;
        }
        visit(visitor) {
            return visitor.visitBoundText(this);
        }
    }
    class TextAttribute {
        constructor(name, value, sourceSpan, valueSpan, i18n) {
            this.name = name;
            this.value = value;
            this.sourceSpan = sourceSpan;
            this.valueSpan = valueSpan;
            this.i18n = i18n;
        }
        visit(visitor) {
            return visitor.visitTextAttribute(this);
        }
    }
    class BoundAttribute {
        constructor(name, type, securityContext, value, unit, sourceSpan, valueSpan, i18n) {
            this.name = name;
            this.type = type;
            this.securityContext = securityContext;
            this.value = value;
            this.unit = unit;
            this.sourceSpan = sourceSpan;
            this.valueSpan = valueSpan;
            this.i18n = i18n;
        }
        static fromBoundElementProperty(prop, i18n) {
            return new BoundAttribute(prop.name, prop.type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan, prop.valueSpan, i18n);
        }
        visit(visitor) {
            return visitor.visitBoundAttribute(this);
        }
    }
    class BoundEvent {
        constructor(name, type, handler, target, phase, sourceSpan, handlerSpan) {
            this.name = name;
            this.type = type;
            this.handler = handler;
            this.target = target;
            this.phase = phase;
            this.sourceSpan = sourceSpan;
            this.handlerSpan = handlerSpan;
        }
        static fromParsedEvent(event) {
            const target = event.type === 0 /* Regular */ ? event.targetOrPhase : null;
            const phase = event.type === 1 /* Animation */ ? event.targetOrPhase : null;
            return new BoundEvent(event.name, event.type, event.handler, target, phase, event.sourceSpan, event.handlerSpan);
        }
        visit(visitor) {
            return visitor.visitBoundEvent(this);
        }
    }
    class Element {
        constructor(name, attributes, inputs, outputs, children, references, sourceSpan, startSourceSpan, endSourceSpan, i18n) {
            this.name = name;
            this.attributes = attributes;
            this.inputs = inputs;
            this.outputs = outputs;
            this.children = children;
            this.references = references;
            this.sourceSpan = sourceSpan;
            this.startSourceSpan = startSourceSpan;
            this.endSourceSpan = endSourceSpan;
            this.i18n = i18n;
            // If the element is empty then the source span should include any closing tag
            if (children.length === 0 && startSourceSpan && endSourceSpan) {
                this.sourceSpan = new ParseSourceSpan(sourceSpan.start, endSourceSpan.end);
            }
        }
        visit(visitor) {
            return visitor.visitElement(this);
        }
    }
    class Template {
        constructor(tagName, attributes, inputs, outputs, templateAttrs, children, references, variables, sourceSpan, startSourceSpan, endSourceSpan, i18n) {
            this.tagName = tagName;
            this.attributes = attributes;
            this.inputs = inputs;
            this.outputs = outputs;
            this.templateAttrs = templateAttrs;
            this.children = children;
            this.references = references;
            this.variables = variables;
            this.sourceSpan = sourceSpan;
            this.startSourceSpan = startSourceSpan;
            this.endSourceSpan = endSourceSpan;
            this.i18n = i18n;
        }
        visit(visitor) {
            return visitor.visitTemplate(this);
        }
    }
    class Content {
        constructor(selector, attributes, sourceSpan, i18n) {
            this.selector = selector;
            this.attributes = attributes;
            this.sourceSpan = sourceSpan;
            this.i18n = i18n;
            this.name = 'ng-content';
        }
        visit(visitor) {
            return visitor.visitContent(this);
        }
    }
    class Variable {
        constructor(name, value, sourceSpan, valueSpan) {
            this.name = name;
            this.value = value;
            this.sourceSpan = sourceSpan;
            this.valueSpan = valueSpan;
        }
        visit(visitor) {
            return visitor.visitVariable(this);
        }
    }
    class Reference {
        constructor(name, value, sourceSpan, valueSpan) {
            this.name = name;
            this.value = value;
            this.sourceSpan = sourceSpan;
            this.valueSpan = valueSpan;
        }
        visit(visitor) {
            return visitor.visitReference(this);
        }
    }
    class Icu {
        constructor(vars, placeholders, sourceSpan, i18n) {
            this.vars = vars;
            this.placeholders = placeholders;
            this.sourceSpan = sourceSpan;
            this.i18n = i18n;
        }
        visit(visitor) {
            return visitor.visitIcu(this);
        }
    }
    class RecursiveVisitor {
        visitElement(element) {
            visitAll(this, element.attributes);
            visitAll(this, element.children);
            visitAll(this, element.references);
        }
        visitTemplate(template) {
            visitAll(this, template.attributes);
            visitAll(this, template.children);
            visitAll(this, template.references);
            visitAll(this, template.variables);
        }
        visitContent(content) { }
        visitVariable(variable) { }
        visitReference(reference) { }
        visitTextAttribute(attribute) { }
        visitBoundAttribute(attribute) { }
        visitBoundEvent(attribute) { }
        visitText(text) { }
        visitBoundText(text) { }
        visitIcu(icu) { }
    }
    function visitAll(visitor, nodes) {
        const result = [];
        if (visitor.visit) {
            for (const node of nodes) {
                const newNode = visitor.visit(node) || node.visit(visitor);
            }
        }
        else {
            for (const node of nodes) {
                const newNode = node.visit(visitor);
                if (newNode) {
                    result.push(newNode);
                }
            }
        }
        return result;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class Message {
        /**
         * @param nodes message AST
         * @param placeholders maps placeholder names to static content
         * @param placeholderToMessage maps placeholder names to messages (used for nested ICU messages)
         * @param meaning
         * @param description
         * @param customId
         */
        constructor(nodes, placeholders, placeholderToMessage, meaning, description, customId) {
            this.nodes = nodes;
            this.placeholders = placeholders;
            this.placeholderToMessage = placeholderToMessage;
            this.meaning = meaning;
            this.description = description;
            this.customId = customId;
            this.id = this.customId;
            /** The ids to use if there are no custom id and if `i18nLegacyMessageIdFormat` is not empty */
            this.legacyIds = [];
            if (nodes.length) {
                this.sources = [{
                        filePath: nodes[0].sourceSpan.start.file.url,
                        startLine: nodes[0].sourceSpan.start.line + 1,
                        startCol: nodes[0].sourceSpan.start.col + 1,
                        endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,
                        endCol: nodes[0].sourceSpan.start.col + 1
                    }];
            }
            else {
                this.sources = [];
            }
        }
    }
    class Text$1 {
        constructor(value, sourceSpan) {
            this.value = value;
            this.sourceSpan = sourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitText(this, context);
        }
    }
    // TODO(vicb): do we really need this node (vs an array) ?
    class Container {
        constructor(children, sourceSpan) {
            this.children = children;
            this.sourceSpan = sourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitContainer(this, context);
        }
    }
    class Icu$1 {
        constructor(expression, type, cases, sourceSpan) {
            this.expression = expression;
            this.type = type;
            this.cases = cases;
            this.sourceSpan = sourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitIcu(this, context);
        }
    }
    class TagPlaceholder {
        constructor(tag, attrs, startName, closeName, children, isVoid, sourceSpan) {
            this.tag = tag;
            this.attrs = attrs;
            this.startName = startName;
            this.closeName = closeName;
            this.children = children;
            this.isVoid = isVoid;
            this.sourceSpan = sourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitTagPlaceholder(this, context);
        }
    }
    class Placeholder {
        constructor(value, name, sourceSpan) {
            this.value = value;
            this.name = name;
            this.sourceSpan = sourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitPlaceholder(this, context);
        }
    }
    class IcuPlaceholder {
        constructor(value, name, sourceSpan) {
            this.value = value;
            this.name = name;
            this.sourceSpan = sourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitIcuPlaceholder(this, context);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Compute the message id using the XLIFF1 digest.
     */
    function computeDigest(message) {
        return sha1(serializeNodes(message.nodes).join('') + `[${message.meaning}]`);
    }
    /**
     * Return the message id or compute it using the XLIFF2/XMB/$localize digest.
     */
    function decimalDigest(message) {
        return message.id || computeDecimalDigest(message);
    }
    /**
     * Compute the message id using the XLIFF2/XMB/$localize digest.
     */
    function computeDecimalDigest(message) {
        const visitor = new _SerializerIgnoreIcuExpVisitor();
        const parts = message.nodes.map(a => a.visit(visitor, null));
        return computeMsgId(parts.join(''), message.meaning);
    }
    /**
     * Serialize the i18n ast to something xml-like in order to generate an UID.
     *
     * The visitor is also used in the i18n parser tests
     *
     * @internal
     */
    class _SerializerVisitor {
        visitText(text, context) {
            return text.value;
        }
        visitContainer(container, context) {
            return `[${container.children.map(child => child.visit(this)).join(', ')}]`;
        }
        visitIcu(icu, context) {
            const strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);
            return `{${icu.expression}, ${icu.type}, ${strCases.join(', ')}}`;
        }
        visitTagPlaceholder(ph, context) {
            return ph.isVoid ?
                `<ph tag name="${ph.startName}"/>` :
                `<ph tag name="${ph.startName}">${ph.children.map(child => child.visit(this)).join(', ')}</ph name="${ph.closeName}">`;
        }
        visitPlaceholder(ph, context) {
            return ph.value ? `<ph name="${ph.name}">${ph.value}</ph>` : `<ph name="${ph.name}"/>`;
        }
        visitIcuPlaceholder(ph, context) {
            return `<ph icu name="${ph.name}">${ph.value.visit(this)}</ph>`;
        }
    }
    const serializerVisitor = new _SerializerVisitor();
    function serializeNodes(nodes) {
        return nodes.map(a => a.visit(serializerVisitor, null));
    }
    /**
     * Serialize the i18n ast to something xml-like in order to generate an UID.
     *
     * Ignore the ICU expressions so that message IDs stays identical if only the expression changes.
     *
     * @internal
     */
    class _SerializerIgnoreIcuExpVisitor extends _SerializerVisitor {
        visitIcu(icu, context) {
            let strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);
            // Do not take the expression into account
            return `{${icu.type}, ${strCases.join(', ')}}`;
        }
    }
    /**
     * Compute the SHA1 of the given string
     *
     * see http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
     *
     * WARNING: this function has not been designed not tested with security in mind.
     *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.
     */
    function sha1(str) {
        const utf8 = utf8Encode(str);
        const words32 = stringToWords32(utf8, Endian.Big);
        const len = utf8.length * 8;
        const w = newArray(80);
        let a = 0x67452301, b = 0xefcdab89, c = 0x98badcfe, d = 0x10325476, e = 0xc3d2e1f0;
        words32[len >> 5] |= 0x80 << (24 - len % 32);
        words32[((len + 64 >> 9) << 4) + 15] = len;
        for (let i = 0; i < words32.length; i += 16) {
            const h0 = a, h1 = b, h2 = c, h3 = d, h4 = e;
            for (let j = 0; j < 80; j++) {
                if (j < 16) {
                    w[j] = words32[i + j];
                }
                else {
                    w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
                }
                const fkVal = fk(j, b, c, d);
                const f = fkVal[0];
                const k = fkVal[1];
                const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);
                e = d;
                d = c;
                c = rol32(b, 30);
                b = a;
                a = temp;
            }
            a = add32(a, h0);
            b = add32(b, h1);
            c = add32(c, h2);
            d = add32(d, h3);
            e = add32(e, h4);
        }
        return byteStringToHexString(words32ToByteString([a, b, c, d, e]));
    }
    function fk(index, b, c, d) {
        if (index < 20) {
            return [(b & c) | (~b & d), 0x5a827999];
        }
        if (index < 40) {
            return [b ^ c ^ d, 0x6ed9eba1];
        }
        if (index < 60) {
            return [(b & c) | (b & d) | (c & d), 0x8f1bbcdc];
        }
        return [b ^ c ^ d, 0xca62c1d6];
    }
    /**
     * Compute the fingerprint of the given string
     *
     * The output is 64 bit number encoded as a decimal string
     *
     * based on:
     * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java
     */
    function fingerprint(str) {
        const utf8 = utf8Encode(str);
        let hi = hash32(utf8, 0);
        let lo = hash32(utf8, 102072);
        if (hi == 0 && (lo == 0 || lo == 1)) {
            hi = hi ^ 0x130f9bef;
            lo = lo ^ -0x6b5f56d8;
        }
        return [hi, lo];
    }
    function computeMsgId(msg, meaning = '') {
        let msgFingerprint = fingerprint(msg);
        if (meaning) {
            const meaningFingerprint = fingerprint(meaning);
            msgFingerprint = add64(rol64(msgFingerprint, 1), meaningFingerprint);
        }
        const hi = msgFingerprint[0];
        const lo = msgFingerprint[1];
        return byteStringToDecString(words32ToByteString([hi & 0x7fffffff, lo]));
    }
    function hash32(str, c) {
        let a = 0x9e3779b9, b = 0x9e3779b9;
        let i;
        const len = str.length;
        for (i = 0; i + 12 <= len; i += 12) {
            a = add32(a, wordAt(str, i, Endian.Little));
            b = add32(b, wordAt(str, i + 4, Endian.Little));
            c = add32(c, wordAt(str, i + 8, Endian.Little));
            const res = mix(a, b, c);
            a = res[0], b = res[1], c = res[2];
        }
        a = add32(a, wordAt(str, i, Endian.Little));
        b = add32(b, wordAt(str, i + 4, Endian.Little));
        // the first byte of c is reserved for the length
        c = add32(c, len);
        c = add32(c, wordAt(str, i + 8, Endian.Little) << 8);
        return mix(a, b, c)[2];
    }
    // clang-format off
    function mix(a, b, c) {
        a = sub32(a, b);
        a = sub32(a, c);
        a ^= c >>> 13;
        b = sub32(b, c);
        b = sub32(b, a);
        b ^= a << 8;
        c = sub32(c, a);
        c = sub32(c, b);
        c ^= b >>> 13;
        a = sub32(a, b);
        a = sub32(a, c);
        a ^= c >>> 12;
        b = sub32(b, c);
        b = sub32(b, a);
        b ^= a << 16;
        c = sub32(c, a);
        c = sub32(c, b);
        c ^= b >>> 5;
        a = sub32(a, b);
        a = sub32(a, c);
        a ^= c >>> 3;
        b = sub32(b, c);
        b = sub32(b, a);
        b ^= a << 10;
        c = sub32(c, a);
        c = sub32(c, b);
        c ^= b >>> 15;
        return [a, b, c];
    }
    // clang-format on
    // Utils
    var Endian;
    (function (Endian) {
        Endian[Endian["Little"] = 0] = "Little";
        Endian[Endian["Big"] = 1] = "Big";
    })(Endian || (Endian = {}));
    function add32(a, b) {
        return add32to64(a, b)[1];
    }
    function add32to64(a, b) {
        const low = (a & 0xffff) + (b & 0xffff);
        const high = (a >>> 16) + (b >>> 16) + (low >>> 16);
        return [high >>> 16, (high << 16) | (low & 0xffff)];
    }
    function add64(a, b) {
        const ah = a[0], al = a[1];
        const bh = b[0], bl = b[1];
        const result = add32to64(al, bl);
        const carry = result[0];
        const l = result[1];
        const h = add32(add32(ah, bh), carry);
        return [h, l];
    }
    function sub32(a, b) {
        const low = (a & 0xffff) - (b & 0xffff);
        const high = (a >> 16) - (b >> 16) + (low >> 16);
        return (high << 16) | (low & 0xffff);
    }
    // Rotate a 32b number left `count` position
    function rol32(a, count) {
        return (a << count) | (a >>> (32 - count));
    }
    // Rotate a 64b number left `count` position
    function rol64(num, count) {
        const hi = num[0], lo = num[1];
        const h = (hi << count) | (lo >>> (32 - count));
        const l = (lo << count) | (hi >>> (32 - count));
        return [h, l];
    }
    function stringToWords32(str, endian) {
        const size = (str.length + 3) >>> 2;
        const words32 = [];
        for (let i = 0; i < size; i++) {
            words32[i] = wordAt(str, i * 4, endian);
        }
        return words32;
    }
    function byteAt(str, index) {
        return index >= str.length ? 0 : str.charCodeAt(index) & 0xff;
    }
    function wordAt(str, index, endian) {
        let word = 0;
        if (endian === Endian.Big) {
            for (let i = 0; i < 4; i++) {
                word += byteAt(str, index + i) << (24 - 8 * i);
            }
        }
        else {
            for (let i = 0; i < 4; i++) {
                word += byteAt(str, index + i) << 8 * i;
            }
        }
        return word;
    }
    function words32ToByteString(words32) {
        return words32.reduce((str, word) => str + word32ToByteString(word), '');
    }
    function word32ToByteString(word) {
        let str = '';
        for (let i = 0; i < 4; i++) {
            str += String.fromCharCode((word >>> 8 * (3 - i)) & 0xff);
        }
        return str;
    }
    function byteStringToHexString(str) {
        let hex = '';
        for (let i = 0; i < str.length; i++) {
            const b = byteAt(str, i);
            hex += (b >>> 4).toString(16) + (b & 0x0f).toString(16);
        }
        return hex.toLowerCase();
    }
    // based on http://www.danvk.org/hex2dec.html (JS can not handle more than 56b)
    function byteStringToDecString(str) {
        let decimal = '';
        let toThePower = '1';
        for (let i = str.length - 1; i >= 0; i--) {
            decimal = addBigInt(decimal, numberTimesBigInt(byteAt(str, i), toThePower));
            toThePower = numberTimesBigInt(256, toThePower);
        }
        return decimal.split('').reverse().join('');
    }
    // x and y decimal, lowest significant digit first
    function addBigInt(x, y) {
        let sum = '';
        const len = Math.max(x.length, y.length);
        for (let i = 0, carry = 0; i < len || carry; i++) {
            const tmpSum = carry + +(x[i] || 0) + +(y[i] || 0);
            if (tmpSum >= 10) {
                carry = 1;
                sum += tmpSum - 10;
            }
            else {
                carry = 0;
                sum += tmpSum;
            }
        }
        return sum;
    }
    function numberTimesBigInt(num, b) {
        let product = '';
        let bToThePower = b;
        for (; num !== 0; num = num >>> 1) {
            if (num & 1)
                product = addBigInt(product, bToThePower);
            bToThePower = addBigInt(bToThePower, bToThePower);
        }
        return product;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // XMB/XTB placeholders can only contain A-Z, 0-9 and _
    function toPublicName(internalName) {
        return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, '_');
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /* Closure variables holding messages must be named `MSG_[A-Z0-9]+` */
    const CLOSURE_TRANSLATION_PREFIX = 'MSG_';
    /* Prefix for non-`goog.getMsg` i18n-related vars */
    const TRANSLATION_PREFIX = 'I18N_';
    /** Name of the i18n attributes **/
    const I18N_ATTR = 'i18n';
    const I18N_ATTR_PREFIX = 'i18n-';
    /** Prefix of var expressions used in ICUs */
    const I18N_ICU_VAR_PREFIX = 'VAR_';
    /** Prefix of ICU expressions for post processing */
    const I18N_ICU_MAPPING_PREFIX = 'I18N_EXP_';
    /** Placeholder wrapper for i18n expressions **/
    const I18N_PLACEHOLDER_SYMBOL = '';
    function isI18nAttribute(name) {
        return name === I18N_ATTR || name.startsWith(I18N_ATTR_PREFIX);
    }
    function isI18nRootNode(meta) {
        return meta instanceof Message;
    }
    function isSingleI18nIcu(meta) {
        return isI18nRootNode(meta) && meta.nodes.length === 1 && meta.nodes[0] instanceof Icu$1;
    }
    function hasI18nMeta(node) {
        return !!node.i18n;
    }
    function hasI18nAttrs(element) {
        return element.attrs.some((attr) => isI18nAttribute(attr.name));
    }
    function icuFromI18nMessage(message) {
        return message.nodes[0];
    }
    function wrapI18nPlaceholder(content, contextId = 0) {
        const blockId = contextId > 0 ? `:${contextId}` : '';
        return `${I18N_PLACEHOLDER_SYMBOL}${content}${blockId}${I18N_PLACEHOLDER_SYMBOL}`;
    }
    function assembleI18nBoundString(strings, bindingStartIndex = 0, contextId = 0) {
        if (!strings.length)
            return '';
        let acc = '';
        const lastIdx = strings.length - 1;
        for (let i = 0; i < lastIdx; i++) {
            acc += `${strings[i]}${wrapI18nPlaceholder(bindingStartIndex + i, contextId)}`;
        }
        acc += strings[lastIdx];
        return acc;
    }
    function getSeqNumberGenerator(startsAt = 0) {
        let current = startsAt;
        return () => current++;
    }
    function placeholdersToParams(placeholders) {
        const params = {};
        placeholders.forEach((values, key) => {
            params[key] = literal(values.length > 1 ? `[${values.join('|')}]` : values[0]);
        });
        return params;
    }
    function updatePlaceholderMap(map, name, ...values) {
        const current = map.get(name) || [];
        current.push(...values);
        map.set(name, current);
    }
    function assembleBoundTextPlaceholders(meta, bindingStartIndex = 0, contextId = 0) {
        const startIdx = bindingStartIndex;
        const placeholders = new Map();
        const node = meta instanceof Message ? meta.nodes.find(node => node instanceof Container) : meta;
        if (node) {
            node
                .children
                .filter((child) => child instanceof Placeholder)
                .forEach((child, idx) => {
                const content = wrapI18nPlaceholder(startIdx + idx, contextId);
                updatePlaceholderMap(placeholders, child.name, content);
            });
        }
        return placeholders;
    }
    /**
     * Format the placeholder names in a map of placeholders to expressions.
     *
     * The placeholder names are converted from "internal" format (e.g. `START_TAG_DIV_1`) to "external"
     * format (e.g. `startTagDiv_1`).
     *
     * @param params A map of placeholder names to expressions.
     * @param useCamelCase whether to camelCase the placeholder name when formatting.
     * @returns A new map of formatted placeholder names to expressions.
     */
    function i18nFormatPlaceholderNames(params = {}, useCamelCase) {
        const _params = {};
        if (params && Object.keys(params).length) {
            Object.keys(params).forEach(key => _params[formatI18nPlaceholderName(key, useCamelCase)] = params[key]);
        }
        return _params;
    }
    /**
     * Converts internal placeholder names to public-facing format
     * (for example to use in goog.getMsg call).
     * Example: `START_TAG_DIV_1` is converted to `startTagDiv_1`.
     *
     * @param name The placeholder name that should be formatted
     * @returns Formatted placeholder name
     */
    function formatI18nPlaceholderName(name, useCamelCase = true) {
        const publicName = toPublicName(name);
        if (!useCamelCase) {
            return publicName;
        }
        const chunks = publicName.split('_');
        if (chunks.length === 1) {
            // if no "_" found - just lowercase the value
            return name.toLowerCase();
        }
        let postfix;
        // eject last element if it's a number
        if (/^\d+$/.test(chunks[chunks.length - 1])) {
            postfix = chunks.pop();
        }
        let raw = chunks.shift().toLowerCase();
        if (chunks.length) {
            raw += chunks.map(c => c.charAt(0).toUpperCase() + c.slice(1).toLowerCase()).join('');
        }
        return postfix ? `${raw}_${postfix}` : raw;
    }
    /**
     * Generates a prefix for translation const name.
     *
     * @param extra Additional local prefix that should be injected into translation var name
     * @returns Complete translation const prefix
     */
    function getTranslationConstPrefix(extra) {
        return `${CLOSURE_TRANSLATION_PREFIX}${extra}`.toUpperCase();
    }
    /**
     * Generate AST to declare a variable. E.g. `var I18N_1;`.
     * @param variable the name of the variable to declare.
     */
    function declareI18nVariable(variable) {
        return new DeclareVarStmt(variable.name, undefined, INFERRED_TYPE, null, variable.sourceSpan);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Checks whether an object key contains potentially unsafe chars, thus the key should be wrapped in
     * quotes. Note: we do not wrap all keys into quotes, as it may have impact on minification and may
     * bot work in some cases when object keys are mangled by minifier.
     *
     * TODO(FW-1136): this is a temporary solution, we need to come up with a better way of working with
     * inputs that contain potentially unsafe chars.
     */
    const UNSAFE_OBJECT_KEY_NAME_REGEXP = /[-.]/;
    /** Name of the temporary to use during data binding */
    const TEMPORARY_NAME = '_t';
    /** Name of the context parameter passed into a template function */
    const CONTEXT_NAME = 'ctx';
    /** Name of the RenderFlag passed into a template function */
    const RENDER_FLAGS = 'rf';
    /** The prefix reference variables */
    const REFERENCE_PREFIX = '_r';
    /** The name of the implicit context reference */
    const IMPLICIT_REFERENCE = '$implicit';
    /** Non bindable attribute name **/
    const NON_BINDABLE_ATTR = 'ngNonBindable';
    /**
     * Creates an allocator for a temporary variable.
     *
     * A variable declaration is added to the statements the first time the allocator is invoked.
     */
    function temporaryAllocator(statements, name) {
        let temp = null;
        return () => {
            if (!temp) {
                statements.push(new DeclareVarStmt(TEMPORARY_NAME, undefined, DYNAMIC_TYPE));
                temp = variable(name);
            }
            return temp;
        };
    }
    function unsupported(feature) {
        if (this) {
            throw new Error(`Builder ${this.constructor.name} doesn't support ${feature} yet`);
        }
        throw new Error(`Feature ${feature} is not supported yet`);
    }
    function invalid$1(arg) {
        throw new Error(`Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);
    }
    function asLiteral(value) {
        if (Array.isArray(value)) {
            return literalArr(value.map(asLiteral));
        }
        return literal(value, INFERRED_TYPE);
    }
    function conditionallyCreateMapObjectLiteral(keys, keepDeclared) {
        if (Object.getOwnPropertyNames(keys).length > 0) {
            return mapToExpression(keys, keepDeclared);
        }
        return null;
    }
    function mapToExpression(map, keepDeclared) {
        return literalMap(Object.getOwnPropertyNames(map).map(key => {
            // canonical syntax: `dirProp: publicProp`
            // if there is no `:`, use dirProp = elProp
            const value = map[key];
            let declaredName;
            let publicName;
            let minifiedName;
            if (Array.isArray(value)) {
                [publicName, declaredName] = value;
            }
            else {
                [declaredName, publicName] = splitAtColon(key, [key, value]);
            }
            minifiedName = declaredName;
            return {
                key: minifiedName,
                // put quotes around keys that contain potentially unsafe characters
                quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(minifiedName),
                value: (keepDeclared && publicName !== declaredName) ?
                    literalArr([asLiteral(publicName), asLiteral(declaredName)]) :
                    asLiteral(publicName)
            };
        }));
    }
    /**
     *  Remove trailing null nodes as they are implied.
     */
    function trimTrailingNulls(parameters) {
        while (isNull(parameters[parameters.length - 1])) {
            parameters.pop();
        }
        return parameters;
    }
    function getQueryPredicate(query, constantPool) {
        if (Array.isArray(query.predicate)) {
            let predicate = [];
            query.predicate.forEach((selector) => {
                // Each item in predicates array may contain strings with comma-separated refs
                // (for ex. 'ref, ref1, ..., refN'), thus we extract individual refs and store them
                // as separate array entities
                const selectors = selector.split(',').map(token => literal(token.trim()));
                predicate.push(...selectors);
            });
            return constantPool.getConstLiteral(literalArr(predicate), true);
        }
        else {
            return query.predicate;
        }
    }
    class DefinitionMap {
        constructor() {
            this.values = [];
        }
        set(key, value) {
            if (value) {
                this.values.push({ key, value, quoted: false });
            }
        }
        toLiteralMap() {
            return literalMap(this.values);
        }
    }
    /**
     * Extract a map of properties to values for a given element or template node, which can be used
     * by the directive matching machinery.
     *
     * @param elOrTpl the element or template in question
     * @return an object set up for directive matching. For attributes on the element/template, this
     * object maps a property name to its (static) value. For any bindings, this map simply maps the
     * property name to an empty string.
     */
    function getAttrsForDirectiveMatching(elOrTpl) {
        const attributesMap = {};
        if (elOrTpl instanceof Template && elOrTpl.tagName !== 'ng-template') {
            elOrTpl.templateAttrs.forEach(a => attributesMap[a.name] = '');
        }
        else {
            elOrTpl.attributes.forEach(a => {
                if (!isI18nAttribute(a.name)) {
                    attributesMap[a.name] = a.value;
                }
            });
            elOrTpl.inputs.forEach(i => {
                attributesMap[i.name] = '';
            });
            elOrTpl.outputs.forEach(o => {
                attributesMap[o.name] = '';
            });
        }
        return attributesMap;
    }
    /** Returns a call expression to a chained instruction, e.g. `property(params[0])(params[1])`. */
    function chainedInstruction(reference, calls, span) {
        let expression = importExpr(reference, null, span);
        if (calls.length > 0) {
            for (let i = 0; i < calls.length; i++) {
                expression = expression.callFn(calls[i], span);
            }
        }
        else {
            // Add a blank invocation, in case the `calls` array is empty.
            expression = expression.callFn([], span);
        }
        return expression;
    }
    /**
     * Gets the number of arguments expected to be passed to a generated instruction in the case of
     * interpolation instructions.
     * @param interpolation An interpolation ast
     */
    function getInterpolationArgsLength(interpolation) {
        const { expressions, strings } = interpolation;
        if (expressions.length === 1 && strings.length === 2 && strings[0] === '' && strings[1] === '') {
            // If the interpolation has one interpolated value, but the prefix and suffix are both empty
            // strings, we only pass one argument, to a special instruction like `propertyInterpolate` or
            // `textInterpolate`.
            return 1;
        }
        else {
            return expressions.length + strings.length;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var R3FactoryDelegateType;
    (function (R3FactoryDelegateType) {
        R3FactoryDelegateType[R3FactoryDelegateType["Class"] = 0] = "Class";
        R3FactoryDelegateType[R3FactoryDelegateType["Function"] = 1] = "Function";
        R3FactoryDelegateType[R3FactoryDelegateType["Factory"] = 2] = "Factory";
    })(R3FactoryDelegateType || (R3FactoryDelegateType = {}));
    var R3FactoryTarget;
    (function (R3FactoryTarget) {
        R3FactoryTarget[R3FactoryTarget["Directive"] = 0] = "Directive";
        R3FactoryTarget[R3FactoryTarget["Component"] = 1] = "Component";
        R3FactoryTarget[R3FactoryTarget["Injectable"] = 2] = "Injectable";
        R3FactoryTarget[R3FactoryTarget["Pipe"] = 3] = "Pipe";
        R3FactoryTarget[R3FactoryTarget["NgModule"] = 4] = "NgModule";
    })(R3FactoryTarget || (R3FactoryTarget = {}));
    /**
     * Resolved type of a dependency.
     *
     * Occasionally, dependencies will have special significance which is known statically. In that
     * case the `R3ResolvedDependencyType` informs the factory generator that a particular dependency
     * should be generated specially (usually by calling a special injection function instead of the
     * standard one).
     */
    var R3ResolvedDependencyType;
    (function (R3ResolvedDependencyType) {
        /**
         * A normal token dependency.
         */
        R3ResolvedDependencyType[R3ResolvedDependencyType["Token"] = 0] = "Token";
        /**
         * The dependency is for an attribute.
         *
         * The token expression is a string representing the attribute name.
         */
        R3ResolvedDependencyType[R3ResolvedDependencyType["Attribute"] = 1] = "Attribute";
        /**
         * Injecting the `ChangeDetectorRef` token. Needs special handling when injected into a pipe.
         */
        R3ResolvedDependencyType[R3ResolvedDependencyType["ChangeDetectorRef"] = 2] = "ChangeDetectorRef";
        /**
         * An invalid dependency (no token could be determined). An error should be thrown at runtime.
         */
        R3ResolvedDependencyType[R3ResolvedDependencyType["Invalid"] = 3] = "Invalid";
    })(R3ResolvedDependencyType || (R3ResolvedDependencyType = {}));
    /**
     * Construct a factory function expression for the given `R3FactoryMetadata`.
     */
    function compileFactoryFunction(meta) {
        const t = variable('t');
        const statements = [];
        let ctorDepsType = NONE_TYPE;
        // The type to instantiate via constructor invocation. If there is no delegated factory, meaning
        // this type is always created by constructor invocation, then this is the type-to-create
        // parameter provided by the user (t) if specified, or the current type if not. If there is a
        // delegated factory (which is used to create the current type) then this is only the type-to-
        // create parameter (t).
        const typeForCtor = !isDelegatedMetadata(meta) ?
            new BinaryOperatorExpr(BinaryOperator.Or, t, meta.internalType) :
            t;
        let ctorExpr = null;
        if (meta.deps !== null) {
            // There is a constructor (either explicitly or implicitly defined).
            if (meta.deps !== 'invalid') {
                ctorExpr = new InstantiateExpr(typeForCtor, injectDependencies(meta.deps, meta.injectFn, meta.target === R3FactoryTarget.Pipe));
                ctorDepsType = createCtorDepsType(meta.deps);
            }
        }
        else {
            const baseFactory = variable(`${meta.name}_BaseFactory`);
            const getInheritedFactory = importExpr(Identifiers$1.getInheritedFactory);
            const baseFactoryStmt = baseFactory
                .set(getInheritedFactory.callFn([meta.internalType], /* sourceSpan */ undefined, /* pure */ true))
                .toDeclStmt(INFERRED_TYPE, [StmtModifier.Exported, StmtModifier.Final]);
            statements.push(baseFactoryStmt);
            // There is no constructor, use the base class' factory to construct typeForCtor.
            ctorExpr = baseFactory.callFn([typeForCtor]);
        }
        const ctorExprFinal = ctorExpr;
        const body = [];
        let retExpr = null;
        function makeConditionalFactory(nonCtorExpr) {
            const r = variable('r');
            body.push(r.set(NULL_EXPR).toDeclStmt());
            let ctorStmt = null;
            if (ctorExprFinal !== null) {
                ctorStmt = r.set(ctorExprFinal).toStmt();
            }
            else {
                ctorStmt = importExpr(Identifiers$1.invalidFactory).callFn([]).toStmt();
            }
            body.push(ifStmt(t, [ctorStmt], [r.set(nonCtorExpr).toStmt()]));
            return r;
        }
        if (isDelegatedMetadata(meta) && meta.delegateType === R3FactoryDelegateType.Factory) {
            const delegateFactory = variable(`${meta.name}_BaseFactory`);
            const getFactoryOf = importExpr(Identifiers$1.getFactoryOf);
            if (meta.delegate.isEquivalent(meta.internalType)) {
                throw new Error(`Illegal state: compiling factory that delegates to itself`);
            }
            const delegateFactoryStmt = delegateFactory.set(getFactoryOf.callFn([meta.delegate])).toDeclStmt(INFERRED_TYPE, [
                StmtModifier.Exported, StmtModifier.Final
            ]);
            statements.push(delegateFactoryStmt);
            retExpr = makeConditionalFactory(delegateFactory.callFn([]));
        }
        else if (isDelegatedMetadata(meta)) {
            // This type is created with a delegated factory. If a type parameter is not specified, call
            // the factory instead.
            const delegateArgs = injectDependencies(meta.delegateDeps, meta.injectFn, meta.target === R3FactoryTarget.Pipe);
            // Either call `new delegate(...)` or `delegate(...)` depending on meta.delegateType.
            const factoryExpr = new (meta.delegateType === R3FactoryDelegateType.Class ?
                InstantiateExpr :
                InvokeFunctionExpr)(meta.delegate, delegateArgs);
            retExpr = makeConditionalFactory(factoryExpr);
        }
        else if (isExpressionFactoryMetadata(meta)) {
            // TODO(alxhub): decide whether to lower the value here or in the caller
            retExpr = makeConditionalFactory(meta.expression);
        }
        else {
            retExpr = ctorExpr;
        }
        if (retExpr !== null) {
            body.push(new ReturnStatement(retExpr));
        }
        else {
            body.push(importExpr(Identifiers$1.invalidFactory).callFn([]).toStmt());
        }
        return {
            factory: fn([new FnParam('t', DYNAMIC_TYPE)], body, INFERRED_TYPE, undefined, `${meta.name}_Factory`),
            statements,
            type: expressionType(importExpr(Identifiers$1.FactoryDef, [typeWithParameters(meta.type.type, meta.typeArgumentCount), ctorDepsType]))
        };
    }
    function injectDependencies(deps, injectFn, isPipe) {
        return deps.map((dep, index) => compileInjectDependency(dep, injectFn, isPipe, index));
    }
    function compileInjectDependency(dep, injectFn, isPipe, index) {
        // Interpret the dependency according to its resolved type.
        switch (dep.resolved) {
            case R3ResolvedDependencyType.Token:
            case R3ResolvedDependencyType.ChangeDetectorRef:
                // Build up the injection flags according to the metadata.
                const flags = 0 /* Default */ | (dep.self ? 2 /* Self */ : 0) |
                    (dep.skipSelf ? 4 /* SkipSelf */ : 0) | (dep.host ? 1 /* Host */ : 0) |
                    (dep.optional ? 8 /* Optional */ : 0);
                // If this dependency is optional or otherwise has non-default flags, then additional
                // parameters describing how to inject the dependency must be passed to the inject function
                // that's being used.
                let flagsParam = (flags !== 0 /* Default */ || dep.optional) ? literal(flags) : null;
                // We have a separate instruction for injecting ChangeDetectorRef into a pipe.
                if (isPipe && dep.resolved === R3ResolvedDependencyType.ChangeDetectorRef) {
                    return importExpr(Identifiers$1.injectPipeChangeDetectorRef).callFn(flagsParam ? [flagsParam] : []);
                }
                // Build up the arguments to the injectFn call.
                const injectArgs = [dep.token];
                if (flagsParam) {
                    injectArgs.push(flagsParam);
                }
                return importExpr(injectFn).callFn(injectArgs);
            case R3ResolvedDependencyType.Attribute:
                // In the case of attributes, the attribute name in question is given as the token.
                return importExpr(Identifiers$1.injectAttribute).callFn([dep.token]);
            case R3ResolvedDependencyType.Invalid:
                return importExpr(Identifiers$1.invalidFactoryDep).callFn([literal(index)]);
            default:
                return unsupported(`Unknown R3ResolvedDependencyType: ${R3ResolvedDependencyType[dep.resolved]}`);
        }
    }
    function createCtorDepsType(deps) {
        let hasTypes = false;
        const attributeTypes = deps.map(dep => {
            const type = createCtorDepType(dep);
            if (type !== null) {
                hasTypes = true;
                return type;
            }
            else {
                return literal(null);
            }
        });
        if (hasTypes) {
            return expressionType(literalArr(attributeTypes));
        }
        else {
            return NONE_TYPE;
        }
    }
    function createCtorDepType(dep) {
        const entries = [];
        if (dep.resolved === R3ResolvedDependencyType.Attribute) {
            if (dep.attribute !== null) {
                entries.push({ key: 'attribute', value: dep.attribute, quoted: false });
            }
        }
        if (dep.optional) {
            entries.push({ key: 'optional', value: literal(true), quoted: false });
        }
        if (dep.host) {
            entries.push({ key: 'host', value: literal(true), quoted: false });
        }
        if (dep.self) {
            entries.push({ key: 'self', value: literal(true), quoted: false });
        }
        if (dep.skipSelf) {
            entries.push({ key: 'skipSelf', value: literal(true), quoted: false });
        }
        return entries.length > 0 ? literalMap(entries) : null;
    }
    function isDelegatedMetadata(meta) {
        return meta.delegateType !== undefined;
    }
    function isExpressionFactoryMetadata(meta) {
        return meta.expression !== undefined;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function compileInjectable(meta) {
        let result = null;
        const factoryMeta = {
            name: meta.name,
            type: meta.type,
            internalType: meta.internalType,
            typeArgumentCount: meta.typeArgumentCount,
            deps: [],
            injectFn: Identifiers.inject,
            target: R3FactoryTarget.Injectable,
        };
        if (meta.useClass !== undefined) {
            // meta.useClass has two modes of operation. Either deps are specified, in which case `new` is
            // used to instantiate the class with dependencies injected, or deps are not specified and
            // the factory of the class is used to instantiate it.
            //
            // A special case exists for useClass: Type where Type is the injectable type itself and no
            // deps are specified, in which case 'useClass' is effectively ignored.
            const useClassOnSelf = meta.useClass.isEquivalent(meta.internalType);
            let deps = undefined;
            if (meta.userDeps !== undefined) {
                deps = meta.userDeps;
            }
            if (deps !== undefined) {
                // factory: () => new meta.useClass(...deps)
                result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), { delegate: meta.useClass, delegateDeps: deps, delegateType: R3FactoryDelegateType.Class }));
            }
            else if (useClassOnSelf) {
                result = compileFactoryFunction(factoryMeta);
            }
            else {
                result = delegateToFactory(meta.type.value, meta.useClass);
            }
        }
        else if (meta.useFactory !== undefined) {
            if (meta.userDeps !== undefined) {
                result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), { delegate: meta.useFactory, delegateDeps: meta.userDeps || [], delegateType: R3FactoryDelegateType.Function }));
            }
            else {
                result = {
                    statements: [],
                    factory: fn([], [new ReturnStatement(meta.useFactory.callFn([]))])
                };
            }
        }
        else if (meta.useValue !== undefined) {
            // Note: it's safe to use `meta.useValue` instead of the `USE_VALUE in meta` check used for
            // client code because meta.useValue is an Expression which will be defined even if the actual
            // value is undefined.
            result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), { expression: meta.useValue }));
        }
        else if (meta.useExisting !== undefined) {
            // useExisting is an `inject` call on the existing token.
            result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), { expression: importExpr(Identifiers.inject).callFn([meta.useExisting]) }));
        }
        else {
            result = delegateToFactory(meta.type.value, meta.internalType);
        }
        const token = meta.internalType;
        const injectableProps = { token, factory: result.factory };
        // Only generate providedIn property if it has a non-null value
        if (meta.providedIn.value !== null) {
            injectableProps.providedIn = meta.providedIn;
        }
        const expression = importExpr(Identifiers.defineInjectable).callFn([mapToMapExpression(injectableProps)]);
        const type = new ExpressionType(importExpr(Identifiers.InjectableDef, [typeWithParameters(meta.type.type, meta.typeArgumentCount)]));
        return {
            expression,
            type,
            statements: result.statements,
        };
    }
    function delegateToFactory(type, internalType) {
        return {
            statements: [],
            // If types are the same, we can generate `factory: type.fac`
            // If types are different, we have to generate a wrapper function to ensure
            // the internal type has been resolved (`factory: function(t) { return type.fac(t); }`)
            factory: type.node === internalType.node ?
                internalType.prop('fac') :
                fn([new FnParam('t', DYNAMIC_TYPE)], [new ReturnStatement(internalType.callMethod('fac', [variable('t')]))])
        };
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const UNUSABLE_INTERPOLATION_REGEXPS = [
        /^\s*$/,
        /[<>]/,
        /^[{}]$/,
        /&(#|[a-z])/i,
        /^\/\//,
    ];
    function assertInterpolationSymbols(identifier, value) {
        if (value != null && !(Array.isArray(value) && value.length == 2)) {
            throw new Error(`Expected '${identifier}' to be an array, [start, end].`);
        }
        else if (value != null) {
            const start = value[0];
            const end = value[1];
            // Check for unusable interpolation symbols
            UNUSABLE_INTERPOLATION_REGEXPS.forEach(regexp => {
                if (regexp.test(start) || regexp.test(end)) {
                    throw new Error(`['${start}', '${end}'] contains unusable interpolation symbol.`);
                }
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class InterpolationConfig {
        constructor(start, end) {
            this.start = start;
            this.end = end;
        }
        static fromArray(markers) {
            if (!markers) {
                return DEFAULT_INTERPOLATION_CONFIG;
            }
            assertInterpolationSymbols('interpolation', markers);
            return new InterpolationConfig(markers[0], markers[1]);
        }
    }
    const DEFAULT_INTERPOLATION_CONFIG = new InterpolationConfig('{{', '}}');

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit
    const VERSION = 3;
    const JS_B64_PREFIX = '# sourceMappingURL=data:application/json;base64,';
    class SourceMapGenerator {
        constructor(file = null) {
            this.file = file;
            this.sourcesContent = new Map();
            this.lines = [];
            this.lastCol0 = 0;
            this.hasMappings = false;
        }
        // The content is `null` when the content is expected to be loaded using the URL
        addSource(url, content = null) {
            if (!this.sourcesContent.has(url)) {
                this.sourcesContent.set(url, content);
            }
            return this;
        }
        addLine() {
            this.lines.push([]);
            this.lastCol0 = 0;
            return this;
        }
        addMapping(col0, sourceUrl, sourceLine0, sourceCol0) {
            if (!this.currentLine) {
                throw new Error(`A line must be added before mappings can be added`);
            }
            if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {
                throw new Error(`Unknown source file "${sourceUrl}"`);
            }
            if (col0 == null) {
                throw new Error(`The column in the generated code must be provided`);
            }
            if (col0 < this.lastCol0) {
                throw new Error(`Mapping should be added in output order`);
            }
            if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {
                throw new Error(`The source location must be provided when a source url is provided`);
            }
            this.hasMappings = true;
            this.lastCol0 = col0;
            this.currentLine.push({ col0, sourceUrl, sourceLine0, sourceCol0 });
            return this;
        }
        /**
         * @internal strip this from published d.ts files due to
         * https://github.com/microsoft/TypeScript/issues/36216
         */
        get currentLine() {
            return this.lines.slice(-1)[0];
        }
        toJSON() {
            if (!this.hasMappings) {
                return null;
            }
            const sourcesIndex = new Map();
            const sources = [];
            const sourcesContent = [];
            Array.from(this.sourcesContent.keys()).forEach((url, i) => {
                sourcesIndex.set(url, i);
                sources.push(url);
                sourcesContent.push(this.sourcesContent.get(url) || null);
            });
            let mappings = '';
            let lastCol0 = 0;
            let lastSourceIndex = 0;
            let lastSourceLine0 = 0;
            let lastSourceCol0 = 0;
            this.lines.forEach(segments => {
                lastCol0 = 0;
                mappings += segments
                    .map(segment => {
                    // zero-based starting column of the line in the generated code
                    let segAsStr = toBase64VLQ(segment.col0 - lastCol0);
                    lastCol0 = segment.col0;
                    if (segment.sourceUrl != null) {
                        // zero-based index into the sources list
                        segAsStr +=
                            toBase64VLQ(sourcesIndex.get(segment.sourceUrl) - lastSourceIndex);
                        lastSourceIndex = sourcesIndex.get(segment.sourceUrl);
                        // the zero-based starting line in the original source
                        segAsStr += toBase64VLQ(segment.sourceLine0 - lastSourceLine0);
                        lastSourceLine0 = segment.sourceLine0;
                        // the zero-based starting column in the original source
                        segAsStr += toBase64VLQ(segment.sourceCol0 - lastSourceCol0);
                        lastSourceCol0 = segment.sourceCol0;
                    }
                    return segAsStr;
                })
                    .join(',');
                mappings += ';';
            });
            mappings = mappings.slice(0, -1);
            return {
                'file': this.file || '',
                'version': VERSION,
                'sourceRoot': '',
                'sources': sources,
                'sourcesContent': sourcesContent,
                'mappings': mappings,
            };
        }
        toJsComment() {
            return this.hasMappings ? '//' + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0)) :
                '';
        }
    }
    function toBase64String(value) {
        let b64 = '';
        value = utf8Encode(value);
        for (let i = 0; i < value.length;) {
            const i1 = value.charCodeAt(i++);
            const i2 = value.charCodeAt(i++);
            const i3 = value.charCodeAt(i++);
            b64 += toBase64Digit(i1 >> 2);
            b64 += toBase64Digit(((i1 & 3) << 4) | (isNaN(i2) ? 0 : i2 >> 4));
            b64 += isNaN(i2) ? '=' : toBase64Digit(((i2 & 15) << 2) | (i3 >> 6));
            b64 += isNaN(i2) || isNaN(i3) ? '=' : toBase64Digit(i3 & 63);
        }
        return b64;
    }
    function toBase64VLQ(value) {
        value = value < 0 ? ((-value) << 1) + 1 : value << 1;
        let out = '';
        do {
            let digit = value & 31;
            value = value >> 5;
            if (value > 0) {
                digit = digit | 32;
            }
            out += toBase64Digit(digit);
        } while (value > 0);
        return out;
    }
    const B64_DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    function toBase64Digit(value) {
        if (value < 0 || value >= 64) {
            throw new Error(`Can only encode value in the range [0, 63]`);
        }
        return B64_DIGITS[value];
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\|\n|\r|\$/g;
    const _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;
    const _INDENT_WITH = '  ';
    const CATCH_ERROR_VAR$1 = variable('error', null, null);
    const CATCH_STACK_VAR$1 = variable('stack', null, null);
    class _EmittedLine {
        constructor(indent) {
            this.indent = indent;
            this.partsLength = 0;
            this.parts = [];
            this.srcSpans = [];
        }
    }
    class EmitterVisitorContext {
        constructor(_indent) {
            this._indent = _indent;
            this._classes = [];
            this._preambleLineCount = 0;
            this._lines = [new _EmittedLine(_indent)];
        }
        static createRoot() {
            return new EmitterVisitorContext(0);
        }
        /**
         * @internal strip this from published d.ts files due to
         * https://github.com/microsoft/TypeScript/issues/36216
         */
        get _currentLine() {
            return this._lines[this._lines.length - 1];
        }
        println(from, lastPart = '') {
            this.print(from || null, lastPart, true);
        }
        lineIsEmpty() {
            return this._currentLine.parts.length === 0;
        }
        lineLength() {
            return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;
        }
        print(from, part, newLine = false) {
            if (part.length > 0) {
                this._currentLine.parts.push(part);
                this._currentLine.partsLength += part.length;
                this._currentLine.srcSpans.push(from && from.sourceSpan || null);
            }
            if (newLine) {
                this._lines.push(new _EmittedLine(this._indent));
            }
        }
        removeEmptyLastLine() {
            if (this.lineIsEmpty()) {
                this._lines.pop();
            }
        }
        incIndent() {
            this._indent++;
            if (this.lineIsEmpty()) {
                this._currentLine.indent = this._indent;
            }
        }
        decIndent() {
            this._indent--;
            if (this.lineIsEmpty()) {
                this._currentLine.indent = this._indent;
            }
        }
        pushClass(clazz) {
            this._classes.push(clazz);
        }
        popClass() {
            return this._classes.pop();
        }
        get currentClass() {
            return this._classes.length > 0 ? this._classes[this._classes.length - 1] : null;
        }
        toSource() {
            return this.sourceLines
                .map(l => l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : '')
                .join('\n');
        }
        toSourceMapGenerator(genFilePath, startsAtLine = 0) {
            const map = new SourceMapGenerator(genFilePath);
            let firstOffsetMapped = false;
            const mapFirstOffsetIfNeeded = () => {
                if (!firstOffsetMapped) {
                    // Add a single space so that tools won't try to load the file from disk.
                    // Note: We are using virtual urls like `ng:///`, so we have to
                    // provide a content here.
                    map.addSource(genFilePath, ' ').addMapping(0, genFilePath, 0, 0);
                    firstOffsetMapped = true;
                }
            };
            for (let i = 0; i < startsAtLine; i++) {
                map.addLine();
                mapFirstOffsetIfNeeded();
            }
            this.sourceLines.forEach((line, lineIdx) => {
                map.addLine();
                const spans = line.srcSpans;
                const parts = line.parts;
                let col0 = line.indent * _INDENT_WITH.length;
                let spanIdx = 0;
                // skip leading parts without source spans
                while (spanIdx < spans.length && !spans[spanIdx]) {
                    col0 += parts[spanIdx].length;
                    spanIdx++;
                }
                if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {
                    firstOffsetMapped = true;
                }
                else {
                    mapFirstOffsetIfNeeded();
                }
                while (spanIdx < spans.length) {
                    const span = spans[spanIdx];
                    const source = span.start.file;
                    const sourceLine = span.start.line;
                    const sourceCol = span.start.col;
                    map.addSource(source.url, source.content)
                        .addMapping(col0, source.url, sourceLine, sourceCol);
                    col0 += parts[spanIdx].length;
                    spanIdx++;
                    // assign parts without span or the same span to the previous segment
                    while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {
                        col0 += parts[spanIdx].length;
                        spanIdx++;
                    }
                }
            });
            return map;
        }
        setPreambleLineCount(count) {
            return this._preambleLineCount = count;
        }
        spanOf(line, column) {
            const emittedLine = this._lines[line - this._preambleLineCount];
            if (emittedLine) {
                let columnsLeft = column - _createIndent(emittedLine.indent).length;
                for (let partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {
                    const part = emittedLine.parts[partIndex];
                    if (part.length > columnsLeft) {
                        return emittedLine.srcSpans[partIndex];
                    }
                    columnsLeft -= part.length;
                }
            }
            return null;
        }
        /**
         * @internal strip this from published d.ts files due to
         * https://github.com/microsoft/TypeScript/issues/36216
         */
        get sourceLines() {
            if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {
                return this._lines.slice(0, -1);
            }
            return this._lines;
        }
    }
    class AbstractEmitterVisitor {
        constructor(_escapeDollarInStrings) {
            this._escapeDollarInStrings = _escapeDollarInStrings;
        }
        visitExpressionStmt(stmt, ctx) {
            stmt.expr.visitExpression(this, ctx);
            ctx.println(stmt, ';');
            return null;
        }
        visitReturnStmt(stmt, ctx) {
            ctx.print(stmt, `return `);
            stmt.value.visitExpression(this, ctx);
            ctx.println(stmt, ';');
            return null;
        }
        visitIfStmt(stmt, ctx) {
            ctx.print(stmt, `if (`);
            stmt.condition.visitExpression(this, ctx);
            ctx.print(stmt, `) {`);
            const hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;
            if (stmt.trueCase.length <= 1 && !hasElseCase) {
                ctx.print(stmt, ` `);
                this.visitAllStatements(stmt.trueCase, ctx);
                ctx.removeEmptyLastLine();
                ctx.print(stmt, ` `);
            }
            else {
                ctx.println();
                ctx.incIndent();
                this.visitAllStatements(stmt.trueCase, ctx);
                ctx.decIndent();
                if (hasElseCase) {
                    ctx.println(stmt, `} else {`);
                    ctx.incIndent();
                    this.visitAllStatements(stmt.falseCase, ctx);
                    ctx.decIndent();
                }
            }
            ctx.println(stmt, `}`);
            return null;
        }
        visitThrowStmt(stmt, ctx) {
            ctx.print(stmt, `throw `);
            stmt.error.visitExpression(this, ctx);
            ctx.println(stmt, `;`);
            return null;
        }
        visitCommentStmt(stmt, ctx) {
            if (stmt.multiline) {
                ctx.println(stmt, `/* ${stmt.comment} */`);
            }
            else {
                stmt.comment.split('\n').forEach((line) => {
                    ctx.println(stmt, `// ${line}`);
                });
            }
            return null;
        }
        visitJSDocCommentStmt(stmt, ctx) {
            ctx.println(stmt, `/*${stmt.toString()}*/`);
            return null;
        }
        visitWriteVarExpr(expr, ctx) {
            const lineWasEmpty = ctx.lineIsEmpty();
            if (!lineWasEmpty) {
                ctx.print(expr, '(');
            }
            ctx.print(expr, `${expr.name} = `);
            expr.value.visitExpression(this, ctx);
            if (!lineWasEmpty) {
                ctx.print(expr, ')');
            }
            return null;
        }
        visitWriteKeyExpr(expr, ctx) {
            const lineWasEmpty = ctx.lineIsEmpty();
            if (!lineWasEmpty) {
                ctx.print(expr, '(');
            }
            expr.receiver.visitExpression(this, ctx);
            ctx.print(expr, `[`);
            expr.index.visitExpression(this, ctx);
            ctx.print(expr, `] = `);
            expr.value.visitExpression(this, ctx);
            if (!lineWasEmpty) {
                ctx.print(expr, ')');
            }
            return null;
        }
        visitWritePropExpr(expr, ctx) {
            const lineWasEmpty = ctx.lineIsEmpty();
            if (!lineWasEmpty) {
                ctx.print(expr, '(');
            }
            expr.receiver.visitExpression(this, ctx);
            ctx.print(expr, `.${expr.name} = `);
            expr.value.visitExpression(this, ctx);
            if (!lineWasEmpty) {
                ctx.print(expr, ')');
            }
            return null;
        }
        visitInvokeMethodExpr(expr, ctx) {
            expr.receiver.visitExpression(this, ctx);
            let name = expr.name;
            if (expr.builtin != null) {
                name = this.getBuiltinMethodName(expr.builtin);
                if (name == null) {
                    // some builtins just mean to skip the call.
                    return null;
                }
            }
            ctx.print(expr, `.${name}(`);
            this.visitAllExpressions(expr.args, ctx, `,`);
            ctx.print(expr, `)`);
            return null;
        }
        visitInvokeFunctionExpr(expr, ctx) {
            expr.fn.visitExpression(this, ctx);
            ctx.print(expr, `(`);
            this.visitAllExpressions(expr.args, ctx, ',');
            ctx.print(expr, `)`);
            return null;
        }
        visitWrappedNodeExpr(ast, ctx) {
            throw new Error('Abstract emitter cannot visit WrappedNodeExpr.');
        }
        visitTypeofExpr(expr, ctx) {
            ctx.print(expr, 'typeof ');
            expr.expr.visitExpression(this, ctx);
        }
        visitReadVarExpr(ast, ctx) {
            let varName = ast.name;
            if (ast.builtin != null) {
                switch (ast.builtin) {
                    case BuiltinVar.Super:
                        varName = 'super';
                        break;
                    case BuiltinVar.This:
                        varName = 'this';
                        break;
                    case BuiltinVar.CatchError:
                        varName = CATCH_ERROR_VAR$1.name;
                        break;
                    case BuiltinVar.CatchStack:
                        varName = CATCH_STACK_VAR$1.name;
                        break;
                    default:
                        throw new Error(`Unknown builtin variable ${ast.builtin}`);
                }
            }
            ctx.print(ast, varName);
            return null;
        }
        visitInstantiateExpr(ast, ctx) {
            ctx.print(ast, `new `);
            ast.classExpr.visitExpression(this, ctx);
            ctx.print(ast, `(`);
            this.visitAllExpressions(ast.args, ctx, ',');
            ctx.print(ast, `)`);
            return null;
        }
        visitLiteralExpr(ast, ctx) {
            const value = ast.value;
            if (typeof value === 'string') {
                ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));
            }
            else {
                ctx.print(ast, `${value}`);
            }
            return null;
        }
        visitLocalizedString(ast, ctx) {
            const head = ast.serializeI18nHead();
            ctx.print(ast, '$localize `' + head.raw);
            for (let i = 1; i < ast.messageParts.length; i++) {
                ctx.print(ast, '${');
                ast.expressions[i - 1].visitExpression(this, ctx);
                ctx.print(ast, `}${ast.serializeI18nTemplatePart(i).raw}`);
            }
            ctx.print(ast, '`');
            return null;
        }
        visitConditionalExpr(ast, ctx) {
            ctx.print(ast, `(`);
            ast.condition.visitExpression(this, ctx);
            ctx.print(ast, '? ');
            ast.trueCase.visitExpression(this, ctx);
            ctx.print(ast, ': ');
            ast.falseCase.visitExpression(this, ctx);
            ctx.print(ast, `)`);
            return null;
        }
        visitNotExpr(ast, ctx) {
            ctx.print(ast, '!');
            ast.condition.visitExpression(this, ctx);
            return null;
        }
        visitAssertNotNullExpr(ast, ctx) {
            ast.condition.visitExpression(this, ctx);
            return null;
        }
        visitBinaryOperatorExpr(ast, ctx) {
            let opStr;
            switch (ast.operator) {
                case BinaryOperator.Equals:
                    opStr = '==';
                    break;
                case BinaryOperator.Identical:
                    opStr = '===';
                    break;
                case BinaryOperator.NotEquals:
                    opStr = '!=';
                    break;
                case BinaryOperator.NotIdentical:
                    opStr = '!==';
                    break;
                case BinaryOperator.And:
                    opStr = '&&';
                    break;
                case BinaryOperator.BitwiseAnd:
                    opStr = '&';
                    break;
                case BinaryOperator.Or:
                    opStr = '||';
                    break;
                case BinaryOperator.Plus:
                    opStr = '+';
                    break;
                case BinaryOperator.Minus:
                    opStr = '-';
                    break;
                case BinaryOperator.Divide:
                    opStr = '/';
                    break;
                case BinaryOperator.Multiply:
                    opStr = '*';
                    break;
                case BinaryOperator.Modulo:
                    opStr = '%';
                    break;
                case BinaryOperator.Lower:
                    opStr = '<';
                    break;
                case BinaryOperator.LowerEquals:
                    opStr = '<=';
                    break;
                case BinaryOperator.Bigger:
                    opStr = '>';
                    break;
                case BinaryOperator.BiggerEquals:
                    opStr = '>=';
                    break;
                default:
                    throw new Error(`Unknown operator ${ast.operator}`);
            }
            if (ast.parens)
                ctx.print(ast, `(`);
            ast.lhs.visitExpression(this, ctx);
            ctx.print(ast, ` ${opStr} `);
            ast.rhs.visitExpression(this, ctx);
            if (ast.parens)
                ctx.print(ast, `)`);
            return null;
        }
        visitReadPropExpr(ast, ctx) {
            ast.receiver.visitExpression(this, ctx);
            ctx.print(ast, `.`);
            ctx.print(ast, ast.name);
            return null;
        }
        visitReadKeyExpr(ast, ctx) {
            ast.receiver.visitExpression(this, ctx);
            ctx.print(ast, `[`);
            ast.index.visitExpression(this, ctx);
            ctx.print(ast, `]`);
            return null;
        }
        visitLiteralArrayExpr(ast, ctx) {
            ctx.print(ast, `[`);
            this.visitAllExpressions(ast.entries, ctx, ',');
            ctx.print(ast, `]`);
            return null;
        }
        visitLiteralMapExpr(ast, ctx) {
            ctx.print(ast, `{`);
            this.visitAllObjects(entry => {
                ctx.print(ast, `${escapeIdentifier(entry.key, this._escapeDollarInStrings, entry.quoted)}:`);
                entry.value.visitExpression(this, ctx);
            }, ast.entries, ctx, ',');
            ctx.print(ast, `}`);
            return null;
        }
        visitCommaExpr(ast, ctx) {
            ctx.print(ast, '(');
            this.visitAllExpressions(ast.parts, ctx, ',');
            ctx.print(ast, ')');
            return null;
        }
        visitAllExpressions(expressions, ctx, separator) {
            this.visitAllObjects(expr => expr.visitExpression(this, ctx), expressions, ctx, separator);
        }
        visitAllObjects(handler, expressions, ctx, separator) {
            let incrementedIndent = false;
            for (let i = 0; i < expressions.length; i++) {
                if (i > 0) {
                    if (ctx.lineLength() > 80) {
                        ctx.print(null, separator, true);
                        if (!incrementedIndent) {
                            // continuation are marked with double indent.
                            ctx.incIndent();
                            ctx.incIndent();
                            incrementedIndent = true;
                        }
                    }
                    else {
                        ctx.print(null, separator, false);
                    }
                }
                handler(expressions[i]);
            }
            if (incrementedIndent) {
                // continuation are marked with double indent.
                ctx.decIndent();
                ctx.decIndent();
            }
        }
        visitAllStatements(statements, ctx) {
            statements.forEach((stmt) => stmt.visitStatement(this, ctx));
        }
    }
    function escapeIdentifier(input, escapeDollar, alwaysQuote = true) {
        if (input == null) {
            return null;
        }
        const body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, (...match) => {
            if (match[0] == '$') {
                return escapeDollar ? '\\$' : '$';
            }
            else if (match[0] == '\n') {
                return '\\n';
            }
            else if (match[0] == '\r') {
                return '\\r';
            }
            else {
                return `\\${match[0]}`;
            }
        });
        const requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);
        return requiresQuotes ? `'${body}'` : body;
    }
    function _createIndent(count) {
        let res = '';
        for (let i = 0; i < count; i++) {
            res += _INDENT_WITH;
        }
        return res;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class AbstractJsEmitterVisitor extends AbstractEmitterVisitor {
        constructor() {
            super(false);
        }
        visitDeclareClassStmt(stmt, ctx) {
            ctx.pushClass(stmt);
            this._visitClassConstructor(stmt, ctx);
            if (stmt.parent != null) {
                ctx.print(stmt, `${stmt.name}.prototype = Object.create(`);
                stmt.parent.visitExpression(this, ctx);
                ctx.println(stmt, `.prototype);`);
            }
            stmt.getters.forEach((getter) => this._visitClassGetter(stmt, getter, ctx));
            stmt.methods.forEach((method) => this._visitClassMethod(stmt, method, ctx));
            ctx.popClass();
            return null;
        }
        _visitClassConstructor(stmt, ctx) {
            ctx.print(stmt, `function ${stmt.name}(`);
            if (stmt.constructorMethod != null) {
                this._visitParams(stmt.constructorMethod.params, ctx);
            }
            ctx.println(stmt, `) {`);
            ctx.incIndent();
            if (stmt.constructorMethod != null) {
                if (stmt.constructorMethod.body.length > 0) {
                    ctx.println(stmt, `var self = this;`);
                    this.visitAllStatements(stmt.constructorMethod.body, ctx);
                }
            }
            ctx.decIndent();
            ctx.println(stmt, `}`);
        }
        _visitClassGetter(stmt, getter, ctx) {
            ctx.println(stmt, `Object.defineProperty(${stmt.name}.prototype, '${getter.name}', { get: function() {`);
            ctx.incIndent();
            if (getter.body.length > 0) {
                ctx.println(stmt, `var self = this;`);
                this.visitAllStatements(getter.body, ctx);
            }
            ctx.decIndent();
            ctx.println(stmt, `}});`);
        }
        _visitClassMethod(stmt, method, ctx) {
            ctx.print(stmt, `${stmt.name}.prototype.${method.name} = function(`);
            this._visitParams(method.params, ctx);
            ctx.println(stmt, `) {`);
            ctx.incIndent();
            if (method.body.length > 0) {
                ctx.println(stmt, `var self = this;`);
                this.visitAllStatements(method.body, ctx);
            }
            ctx.decIndent();
            ctx.println(stmt, `};`);
        }
        visitWrappedNodeExpr(ast, ctx) {
            throw new Error('Cannot emit a WrappedNodeExpr in Javascript.');
        }
        visitReadVarExpr(ast, ctx) {
            if (ast.builtin === BuiltinVar.This) {
                ctx.print(ast, 'self');
            }
            else if (ast.builtin === BuiltinVar.Super) {
                throw new Error(`'super' needs to be handled at a parent ast node, not at the variable level!`);
            }
            else {
                super.visitReadVarExpr(ast, ctx);
            }
            return null;
        }
        visitDeclareVarStmt(stmt, ctx) {
            ctx.print(stmt, `var ${stmt.name}`);
            if (stmt.value) {
                ctx.print(stmt, ' = ');
                stmt.value.visitExpression(this, ctx);
            }
            ctx.println(stmt, `;`);
            return null;
        }
        visitCastExpr(ast, ctx) {
            ast.value.visitExpression(this, ctx);
            return null;
        }
        visitInvokeFunctionExpr(expr, ctx) {
            const fnExpr = expr.fn;
            if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {
                ctx.currentClass.parent.visitExpression(this, ctx);
                ctx.print(expr, `.call(this`);
                if (expr.args.length > 0) {
                    ctx.print(expr, `, `);
                    this.visitAllExpressions(expr.args, ctx, ',');
                }
                ctx.print(expr, `)`);
            }
            else {
                super.visitInvokeFunctionExpr(expr, ctx);
            }
            return null;
        }
        visitFunctionExpr(ast, ctx) {
            ctx.print(ast, `function${ast.name ? ' ' + ast.name : ''}(`);
            this._visitParams(ast.params, ctx);
            ctx.println(ast, `) {`);
            ctx.incIndent();
            this.visitAllStatements(ast.statements, ctx);
            ctx.decIndent();
            ctx.print(ast, `}`);
            return null;
        }
        visitDeclareFunctionStmt(stmt, ctx) {
            ctx.print(stmt, `function ${stmt.name}(`);
            this._visitParams(stmt.params, ctx);
            ctx.println(stmt, `) {`);
            ctx.incIndent();
            this.visitAllStatements(stmt.statements, ctx);
            ctx.decIndent();
            ctx.println(stmt, `}`);
            return null;
        }
        visitTryCatchStmt(stmt, ctx) {
            ctx.println(stmt, `try {`);
            ctx.incIndent();
            this.visitAllStatements(stmt.bodyStmts, ctx);
            ctx.decIndent();
            ctx.println(stmt, `} catch (${CATCH_ERROR_VAR$1.name}) {`);
            ctx.incIndent();
            const catchStmts = [CATCH_STACK_VAR$1.set(CATCH_ERROR_VAR$1.prop('stack')).toDeclStmt(null, [
                    StmtModifier.Final
                ])].concat(stmt.catchStmts);
            this.visitAllStatements(catchStmts, ctx);
            ctx.decIndent();
            ctx.println(stmt, `}`);
            return null;
        }
        visitLocalizedString(ast, ctx) {
            // The following convoluted piece of code is effectively the downlevelled equivalent of
            // ```
            // $localize `...`
            // ```
            // which is effectively like:
            // ```
            // $localize(__makeTemplateObject(cooked, raw), expression1, expression2, ...);
            // ```
            //
            // The `$localize` function expects a "template object", which is an array of "cooked" strings
            // plus a `raw` property that contains an array of "raw" strings.
            //
            // In some environments a helper function called `__makeTemplateObject(cooked, raw)` might be
            // available, in which case we use that. Otherwise we must create our own helper function
            // inline.
            //
            // In the inline function, if `Object.defineProperty` is available we use that to attach the
            // `raw` array.
            ctx.print(ast, '$localize((this&&this.__makeTemplateObject||function(e,t){return Object.defineProperty?Object.defineProperty(e,"raw",{value:t}):e.raw=t,e})(');
            const parts = [ast.serializeI18nHead()];
            for (let i = 1; i < ast.messageParts.length; i++) {
                parts.push(ast.serializeI18nTemplatePart(i));
            }
            ctx.print(ast, `[${parts.map(part => escapeIdentifier(part.cooked, false)).join(', ')}], `);
            ctx.print(ast, `[${parts.map(part => escapeIdentifier(part.raw, false)).join(', ')}])`);
            ast.expressions.forEach(expression => {
                ctx.print(ast, ', ');
                expression.visitExpression(this, ctx);
            });
            ctx.print(ast, ')');
            return null;
        }
        _visitParams(params, ctx) {
            this.visitAllObjects(param => ctx.print(null, param.name), params, ctx, ',');
        }
        getBuiltinMethodName(method) {
            let name;
            switch (method) {
                case BuiltinMethod.ConcatArray:
                    name = 'concat';
                    break;
                case BuiltinMethod.SubscribeObservable:
                    name = 'subscribe';
                    break;
                case BuiltinMethod.Bind:
                    name = 'bind';
                    break;
                default:
                    throw new Error(`Unknown builtin method: ${method}`);
            }
            return name;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A helper class to manage the evaluation of JIT generated code.
     */
    class JitEvaluator {
        /**
         *
         * @param sourceUrl The URL of the generated code.
         * @param statements An array of Angular statement AST nodes to be evaluated.
         * @param reflector A helper used when converting the statements to executable code.
         * @param createSourceMaps If true then create a source-map for the generated code and include it
         * inline as a source-map comment.
         * @returns A map of all the variables in the generated code.
         */
        evaluateStatements(sourceUrl, statements, reflector, createSourceMaps) {
            const converter = new JitEmitterVisitor(reflector);
            const ctx = EmitterVisitorContext.createRoot();
            // Ensure generated code is in strict mode
            if (statements.length > 0 && !isUseStrictStatement(statements[0])) {
                statements = [
                    literal('use strict').toStmt(),
                    ...statements,
                ];
            }
            converter.visitAllStatements(statements, ctx);
            converter.createReturnStmt(ctx);
            return this.evaluateCode(sourceUrl, ctx, converter.getArgs(), createSourceMaps);
        }
        /**
         * Evaluate a piece of JIT generated code.
         * @param sourceUrl The URL of this generated code.
         * @param ctx A context object that contains an AST of the code to be evaluated.
         * @param vars A map containing the names and values of variables that the evaluated code might
         * reference.
         * @param createSourceMap If true then create a source-map for the generated code and include it
         * inline as a source-map comment.
         * @returns The result of evaluating the code.
         */
        evaluateCode(sourceUrl, ctx, vars, createSourceMap) {
            let fnBody = `"use strict";${ctx.toSource()}\n//# sourceURL=${sourceUrl}`;
            const fnArgNames = [];
            const fnArgValues = [];
            for (const argName in vars) {
                fnArgValues.push(vars[argName]);
                fnArgNames.push(argName);
            }
            if (createSourceMap) {
                // using `new Function(...)` generates a header, 1 line of no arguments, 2 lines otherwise
                // E.g. ```
                // function anonymous(a,b,c
                // /**/) { ... }```
                // We don't want to hard code this fact, so we auto detect it via an empty function first.
                const emptyFn = new Function(...fnArgNames.concat('return null;')).toString();
                const headerLines = emptyFn.slice(0, emptyFn.indexOf('return null;')).split('\n').length - 1;
                fnBody += `\n${ctx.toSourceMapGenerator(sourceUrl, headerLines).toJsComment()}`;
            }
            const fn = new Function(...fnArgNames.concat(fnBody));
            return this.executeFunction(fn, fnArgValues);
        }
        /**
         * Execute a JIT generated function by calling it.
         *
         * This method can be overridden in tests to capture the functions that are generated
         * by this `JitEvaluator` class.
         *
         * @param fn A function to execute.
         * @param args The arguments to pass to the function being executed.
         * @returns The return value of the executed function.
         */
        executeFunction(fn, args) {
            return fn(...args);
        }
    }
    /**
     * An Angular AST visitor that converts AST nodes into executable JavaScript code.
     */
    class JitEmitterVisitor extends AbstractJsEmitterVisitor {
        constructor(reflector) {
            super();
            this.reflector = reflector;
            this._evalArgNames = [];
            this._evalArgValues = [];
            this._evalExportedVars = [];
        }
        createReturnStmt(ctx) {
            const stmt = new ReturnStatement(new LiteralMapExpr(this._evalExportedVars.map(resultVar => new LiteralMapEntry(resultVar, variable(resultVar), false))));
            stmt.visitStatement(this, ctx);
        }
        getArgs() {
            const result = {};
            for (let i = 0; i < this._evalArgNames.length; i++) {
                result[this._evalArgNames[i]] = this._evalArgValues[i];
            }
            return result;
        }
        visitExternalExpr(ast, ctx) {
            this._emitReferenceToExternal(ast, this.reflector.resolveExternalReference(ast.value), ctx);
            return null;
        }
        visitWrappedNodeExpr(ast, ctx) {
            this._emitReferenceToExternal(ast, ast.node, ctx);
            return null;
        }
        visitDeclareVarStmt(stmt, ctx) {
            if (stmt.hasModifier(StmtModifier.Exported)) {
                this._evalExportedVars.push(stmt.name);
            }
            return super.visitDeclareVarStmt(stmt, ctx);
        }
        visitDeclareFunctionStmt(stmt, ctx) {
            if (stmt.hasModifier(StmtModifier.Exported)) {
                this._evalExportedVars.push(stmt.name);
            }
            return super.visitDeclareFunctionStmt(stmt, ctx);
        }
        visitDeclareClassStmt(stmt, ctx) {
            if (stmt.hasModifier(StmtModifier.Exported)) {
                this._evalExportedVars.push(stmt.name);
            }
            return super.visitDeclareClassStmt(stmt, ctx);
        }
        _emitReferenceToExternal(ast, value, ctx) {
            let id = this._evalArgValues.indexOf(value);
            if (id === -1) {
                id = this._evalArgValues.length;
                this._evalArgValues.push(value);
                const name = identifierName({ reference: value }) || 'val';
                this._evalArgNames.push(`jit_${name}_${id}`);
            }
            ctx.print(ast, this._evalArgNames[id]);
        }
    }
    function isUseStrictStatement(statement) {
        return statement.isEquivalent(literal('use strict').toStmt());
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Implementation of `CompileReflector` which resolves references to @angular/core
     * symbols at runtime, according to a consumer-provided mapping.
     *
     * Only supports `resolveExternalReference`, all other methods throw.
     */
    class R3JitReflector {
        constructor(context) {
            this.context = context;
        }
        resolveExternalReference(ref) {
            // This reflector only handles @angular/core imports.
            if (ref.moduleName !== '@angular/core') {
                throw new Error(`Cannot resolve external reference to ${ref.moduleName}, only references to @angular/core are supported.`);
            }
            if (!this.context.hasOwnProperty(ref.name)) {
                throw new Error(`No value provided for @angular/core symbol '${ref.name}'.`);
            }
            return this.context[ref.name];
        }
        parameters(typeOrFunc) {
            throw new Error('Not implemented.');
        }
        annotations(typeOrFunc) {
            throw new Error('Not implemented.');
        }
        shallowAnnotations(typeOrFunc) {
            throw new Error('Not implemented.');
        }
        tryAnnotations(typeOrFunc) {
            throw new Error('Not implemented.');
        }
        propMetadata(typeOrFunc) {
            throw new Error('Not implemented.');
        }
        hasLifecycleHook(type, lcProperty) {
            throw new Error('Not implemented.');
        }
        guards(typeOrFunc) {
            throw new Error('Not implemented.');
        }
        componentModuleUrl(type, cmpMetadata) {
            throw new Error('Not implemented.');
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function mapLiteral(obj, quoted = false) {
        return literalMap(Object.keys(obj).map(key => ({
            key,
            quoted,
            value: obj[key],
        })));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Construct an `R3NgModuleDef` for the given `R3NgModuleMetadata`.
     */
    function compileNgModule(meta) {
        const { internalType, type: moduleType, bootstrap, declarations, imports, exports, schemas, containsForwardDecls, emitInline, id } = meta;
        const additionalStatements = [];
        const definitionMap = { type: internalType };
        // Only generate the keys in the metadata if the arrays have values.
        if (bootstrap.length) {
            definitionMap.bootstrap = refsToArray(bootstrap, containsForwardDecls);
        }
        // If requested to emit scope information inline, pass the declarations, imports and exports to
        // the `defineNgModule` call. The JIT compilation uses this.
        if (emitInline) {
            if (declarations.length) {
                definitionMap.declarations = refsToArray(declarations, containsForwardDecls);
            }
            if (imports.length) {
                definitionMap.imports = refsToArray(imports, containsForwardDecls);
            }
            if (exports.length) {
                definitionMap.exports = refsToArray(exports, containsForwardDecls);
            }
        }
        // If not emitting inline, the scope information is not passed into `defineNgModule` as it would
        // prevent tree-shaking of the declarations, imports and exports references.
        else {
            const setNgModuleScopeCall = generateSetNgModuleScopeCall(meta);
            if (setNgModuleScopeCall !== null) {
                additionalStatements.push(setNgModuleScopeCall);
            }
        }
        if (schemas && schemas.length) {
            definitionMap.schemas = literalArr(schemas.map(ref => ref.value));
        }
        if (id) {
            definitionMap.id = id;
        }
        const expression = importExpr(Identifiers$1.defineNgModule).callFn([mapToMapExpression(definitionMap)]);
        const type = new ExpressionType(importExpr(Identifiers$1.NgModuleDefWithMeta, [
            new ExpressionType(moduleType.type), tupleTypeOf(declarations), tupleTypeOf(imports),
            tupleTypeOf(exports)
        ]));
        return { expression, type, additionalStatements };
    }
    /**
     * Generates a function call to `setNgModuleScope` with all necessary information so that the
     * transitive module scope can be computed during runtime in JIT mode. This call is marked pure
     * such that the references to declarations, imports and exports may be elided causing these
     * symbols to become tree-shakeable.
     */
    function generateSetNgModuleScopeCall(meta) {
        const { adjacentType: moduleType, declarations, imports, exports, containsForwardDecls } = meta;
        const scopeMap = {};
        if (declarations.length) {
            scopeMap.declarations = refsToArray(declarations, containsForwardDecls);
        }
        if (imports.length) {
            scopeMap.imports = refsToArray(imports, containsForwardDecls);
        }
        if (exports.length) {
            scopeMap.exports = refsToArray(exports, containsForwardDecls);
        }
        if (Object.keys(scopeMap).length === 0) {
            return null;
        }
        // setNgModuleScope(...)
        const fnCall = new InvokeFunctionExpr(
        /* fn */ importExpr(Identifiers$1.setNgModuleScope), 
        /* args */ [moduleType, mapToMapExpression(scopeMap)]);
        // (ngJitMode guard) && setNgModuleScope(...)
        const guardedCall = jitOnlyGuardedExpression(fnCall);
        // function() { (ngJitMode guard) && setNgModuleScope(...); }
        const iife = new FunctionExpr(
        /* params */ [], 
        /* statements */ [guardedCall.toStmt()]);
        // (function() { (ngJitMode guard) && setNgModuleScope(...); })()
        const iifeCall = new InvokeFunctionExpr(
        /* fn */ iife, 
        /* args */ []);
        return iifeCall.toStmt();
    }
    function compileInjector(meta) {
        const result = compileFactoryFunction({
            name: meta.name,
            type: meta.type,
            internalType: meta.internalType,
            typeArgumentCount: 0,
            deps: meta.deps,
            injectFn: Identifiers$1.inject,
            target: R3FactoryTarget.NgModule,
        });
        const definitionMap = {
            factory: result.factory,
        };
        if (meta.providers !== null) {
            definitionMap.providers = meta.providers;
        }
        if (meta.imports.length > 0) {
            definitionMap.imports = literalArr(meta.imports);
        }
        const expression = importExpr(Identifiers$1.defineInjector).callFn([mapToMapExpression(definitionMap)]);
        const type = new ExpressionType(importExpr(Identifiers$1.InjectorDef, [new ExpressionType(meta.type.type)]));
        return { expression, type, statements: result.statements };
    }
    function tupleTypeOf(exp) {
        const types = exp.map(ref => typeofExpr(ref.type));
        return exp.length > 0 ? expressionType(literalArr(types)) : NONE_TYPE;
    }
    function refsToArray(refs, shouldForwardDeclare) {
        const values = literalArr(refs.map(ref => ref.value));
        return shouldForwardDeclare ? fn([], [new ReturnStatement(values)]) : values;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function compilePipeFromMetadata(metadata) {
        const definitionMapValues = [];
        // e.g. `name: 'myPipe'`
        definitionMapValues.push({ key: 'name', value: literal(metadata.pipeName), quoted: false });
        // e.g. `type: MyPipe`
        definitionMapValues.push({ key: 'type', value: metadata.type.value, quoted: false });
        // e.g. `pure: true`
        definitionMapValues.push({ key: 'pure', value: literal(metadata.pure), quoted: false });
        const expression = importExpr(Identifiers$1.definePipe).callFn([literalMap(definitionMapValues)]);
        const type = new ExpressionType(importExpr(Identifiers$1.PipeDefWithMeta, [
            typeWithParameters(metadata.type.type, metadata.typeArgumentCount),
            new ExpressionType(new LiteralExpr(metadata.pipeName)),
        ]));
        return { expression, type };
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class ParserError {
        constructor(message, input, errLocation, ctxLocation) {
            this.input = input;
            this.errLocation = errLocation;
            this.ctxLocation = ctxLocation;
            this.message = `Parser Error: ${message} ${errLocation} [${input}] in ${ctxLocation}`;
        }
    }
    class ParseSpan {
        constructor(start, end) {
            this.start = start;
            this.end = end;
        }
        toAbsolute(absoluteOffset) {
            return new AbsoluteSourceSpan(absoluteOffset + this.start, absoluteOffset + this.end);
        }
    }
    class AST {
        constructor(span, 
        /**
         * Absolute location of the expression AST in a source code file.
         */
        sourceSpan) {
            this.span = span;
            this.sourceSpan = sourceSpan;
        }
        visit(visitor, context = null) {
            return null;
        }
        toString() {
            return 'AST';
        }
    }
    class ASTWithName extends AST {
        constructor(span, sourceSpan, nameSpan) {
            super(span, sourceSpan);
            this.nameSpan = nameSpan;
        }
    }
    /**
     * Represents a quoted expression of the form:
     *
     * quote = prefix `:` uninterpretedExpression
     * prefix = identifier
     * uninterpretedExpression = arbitrary string
     *
     * A quoted expression is meant to be pre-processed by an AST transformer that
     * converts it into another AST that no longer contains quoted expressions.
     * It is meant to allow third-party developers to extend Angular template
     * expression language. The `uninterpretedExpression` part of the quote is
     * therefore not interpreted by the Angular's own expression parser.
     */
    class Quote extends AST {
        constructor(span, sourceSpan, prefix, uninterpretedExpression, location) {
            super(span, sourceSpan);
            this.prefix = prefix;
            this.uninterpretedExpression = uninterpretedExpression;
            this.location = location;
        }
        visit(visitor, context = null) {
            return visitor.visitQuote(this, context);
        }
        toString() {
            return 'Quote';
        }
    }
    class EmptyExpr extends AST {
        visit(visitor, context = null) {
            // do nothing
        }
    }
    class ImplicitReceiver extends AST {
        visit(visitor, context = null) {
            return visitor.visitImplicitReceiver(this, context);
        }
    }
    /**
     * Multiple expressions separated by a semicolon.
     */
    class Chain extends AST {
        constructor(span, sourceSpan, expressions) {
            super(span, sourceSpan);
            this.expressions = expressions;
        }
        visit(visitor, context = null) {
            return visitor.visitChain(this, context);
        }
    }
    class Conditional extends AST {
        constructor(span, sourceSpan, condition, trueExp, falseExp) {
            super(span, sourceSpan);
            this.condition = condition;
            this.trueExp = trueExp;
            this.falseExp = falseExp;
        }
        visit(visitor, context = null) {
            return visitor.visitConditional(this, context);
        }
    }
    class PropertyRead extends ASTWithName {
        constructor(span, sourceSpan, nameSpan, receiver, name) {
            super(span, sourceSpan, nameSpan);
            this.receiver = receiver;
            this.name = name;
        }
        visit(visitor, context = null) {
            return visitor.visitPropertyRead(this, context);
        }
    }
    class PropertyWrite extends ASTWithName {
        constructor(span, sourceSpan, nameSpan, receiver, name, value) {
            super(span, sourceSpan, nameSpan);
            this.receiver = receiver;
            this.name = name;
            this.value = value;
        }
        visit(visitor, context = null) {
            return visitor.visitPropertyWrite(this, context);
        }
    }
    class SafePropertyRead extends ASTWithName {
        constructor(span, sourceSpan, nameSpan, receiver, name) {
            super(span, sourceSpan, nameSpan);
            this.receiver = receiver;
            this.name = name;
        }
        visit(visitor, context = null) {
            return visitor.visitSafePropertyRead(this, context);
        }
    }
    class KeyedRead extends AST {
        constructor(span, sourceSpan, obj, key) {
            super(span, sourceSpan);
            this.obj = obj;
            this.key = key;
        }
        visit(visitor, context = null) {
            return visitor.visitKeyedRead(this, context);
        }
    }
    class KeyedWrite extends AST {
        constructor(span, sourceSpan, obj, key, value) {
            super(span, sourceSpan);
            this.obj = obj;
            this.key = key;
            this.value = value;
        }
        visit(visitor, context = null) {
            return visitor.visitKeyedWrite(this, context);
        }
    }
    class BindingPipe extends ASTWithName {
        constructor(span, sourceSpan, exp, name, args, nameSpan) {
            super(span, sourceSpan, nameSpan);
            this.exp = exp;
            this.name = name;
            this.args = args;
        }
        visit(visitor, context = null) {
            return visitor.visitPipe(this, context);
        }
    }
    class LiteralPrimitive extends AST {
        constructor(span, sourceSpan, value) {
            super(span, sourceSpan);
            this.value = value;
        }
        visit(visitor, context = null) {
            return visitor.visitLiteralPrimitive(this, context);
        }
    }
    class LiteralArray extends AST {
        constructor(span, sourceSpan, expressions) {
            super(span, sourceSpan);
            this.expressions = expressions;
        }
        visit(visitor, context = null) {
            return visitor.visitLiteralArray(this, context);
        }
    }
    class LiteralMap extends AST {
        constructor(span, sourceSpan, keys, values) {
            super(span, sourceSpan);
            this.keys = keys;
            this.values = values;
        }
        visit(visitor, context = null) {
            return visitor.visitLiteralMap(this, context);
        }
    }
    class Interpolation extends AST {
        constructor(span, sourceSpan, strings, expressions) {
            super(span, sourceSpan);
            this.strings = strings;
            this.expressions = expressions;
        }
        visit(visitor, context = null) {
            return visitor.visitInterpolation(this, context);
        }
    }
    class Binary extends AST {
        constructor(span, sourceSpan, operation, left, right) {
            super(span, sourceSpan);
            this.operation = operation;
            this.left = left;
            this.right = right;
        }
        visit(visitor, context = null) {
            return visitor.visitBinary(this, context);
        }
    }
    class PrefixNot extends AST {
        constructor(span, sourceSpan, expression) {
            super(span, sourceSpan);
            this.expression = expression;
        }
        visit(visitor, context = null) {
            return visitor.visitPrefixNot(this, context);
        }
    }
    class NonNullAssert extends AST {
        constructor(span, sourceSpan, expression) {
            super(span, sourceSpan);
            this.expression = expression;
        }
        visit(visitor, context = null) {
            return visitor.visitNonNullAssert(this, context);
        }
    }
    class MethodCall extends ASTWithName {
        constructor(span, sourceSpan, nameSpan, receiver, name, args) {
            super(span, sourceSpan, nameSpan);
            this.receiver = receiver;
            this.name = name;
            this.args = args;
        }
        visit(visitor, context = null) {
            return visitor.visitMethodCall(this, context);
        }
    }
    class SafeMethodCall extends ASTWithName {
        constructor(span, sourceSpan, nameSpan, receiver, name, args) {
            super(span, sourceSpan, nameSpan);
            this.receiver = receiver;
            this.name = name;
            this.args = args;
        }
        visit(visitor, context = null) {
            return visitor.visitSafeMethodCall(this, context);
        }
    }
    class FunctionCall extends AST {
        constructor(span, sourceSpan, target, args) {
            super(span, sourceSpan);
            this.target = target;
            this.args = args;
        }
        visit(visitor, context = null) {
            return visitor.visitFunctionCall(this, context);
        }
    }
    /**
     * Records the absolute position of a text span in a source file, where `start` and `end` are the
     * starting and ending byte offsets, respectively, of the text span in a source file.
     */
    class AbsoluteSourceSpan {
        constructor(start, end) {
            this.start = start;
            this.end = end;
        }
    }
    class ASTWithSource extends AST {
        constructor(ast, source, location, absoluteOffset, errors) {
            super(new ParseSpan(0, source === null ? 0 : source.length), new AbsoluteSourceSpan(absoluteOffset, source === null ? absoluteOffset : absoluteOffset + source.length));
            this.ast = ast;
            this.source = source;
            this.location = location;
            this.errors = errors;
        }
        visit(visitor, context = null) {
            if (visitor.visitASTWithSource) {
                return visitor.visitASTWithSource(this, context);
            }
            return this.ast.visit(visitor, context);
        }
        toString() {
            return `${this.source} in ${this.location}`;
        }
    }
    class VariableBinding {
        /**
         * @param sourceSpan entire span of the binding.
         * @param key name of the LHS along with its span.
         * @param value optional value for the RHS along with its span.
         */
        constructor(sourceSpan, key, value) {
            this.sourceSpan = sourceSpan;
            this.key = key;
            this.value = value;
        }
    }
    class ExpressionBinding {
        /**
         * @param sourceSpan entire span of the binding.
         * @param key binding name, like ngForOf, ngForTrackBy, ngIf, along with its
         * span. Note that the length of the span may not be the same as
         * `key.source.length`. For example,
         * 1. key.source = ngFor, key.span is for "ngFor"
         * 2. key.source = ngForOf, key.span is for "of"
         * 3. key.source = ngForTrackBy, key.span is for "trackBy"
         * @param value optional expression for the RHS.
         */
        constructor(sourceSpan, key, value) {
            this.sourceSpan = sourceSpan;
            this.key = key;
            this.value = value;
        }
    }
    class RecursiveAstVisitor {
        visit(ast, context) {
            // The default implementation just visits every node.
            // Classes that extend RecursiveAstVisitor should override this function
            // to selectively visit the specified node.
            ast.visit(this, context);
        }
        visitBinary(ast, context) {
            this.visit(ast.left, context);
            this.visit(ast.right, context);
        }
        visitChain(ast, context) {
            this.visitAll(ast.expressions, context);
        }
        visitConditional(ast, context) {
            this.visit(ast.condition, context);
            this.visit(ast.trueExp, context);
            this.visit(ast.falseExp, context);
        }
        visitPipe(ast, context) {
            this.visit(ast.exp, context);
            this.visitAll(ast.args, context);
        }
        visitFunctionCall(ast, context) {
            if (ast.target) {
                this.visit(ast.target, context);
            }
            this.visitAll(ast.args, context);
        }
        visitImplicitReceiver(ast, context) { }
        visitInterpolation(ast, context) {
            this.visitAll(ast.expressions, context);
        }
        visitKeyedRead(ast, context) {
            this.visit(ast.obj, context);
            this.visit(ast.key, context);
        }
        visitKeyedWrite(ast, context) {
            this.visit(ast.obj, context);
            this.visit(ast.key, context);
            this.visit(ast.value, context);
        }
        visitLiteralArray(ast, context) {
            this.visitAll(ast.expressions, context);
        }
        visitLiteralMap(ast, context) {
            this.visitAll(ast.values, context);
        }
        visitLiteralPrimitive(ast, context) { }
        visitMethodCall(ast, context) {
            this.visit(ast.receiver, context);
            this.visitAll(ast.args, context);
        }
        visitPrefixNot(ast, context) {
            this.visit(ast.expression, context);
        }
        visitNonNullAssert(ast, context) {
            this.visit(ast.expression, context);
        }
        visitPropertyRead(ast, context) {
            this.visit(ast.receiver, context);
        }
        visitPropertyWrite(ast, context) {
            this.visit(ast.receiver, context);
            this.visit(ast.value, context);
        }
        visitSafePropertyRead(ast, context) {
            this.visit(ast.receiver, context);
        }
        visitSafeMethodCall(ast, context) {
            this.visit(ast.receiver, context);
            this.visitAll(ast.args, context);
        }
        visitQuote(ast, context) { }
        // This is not part of the AstVisitor interface, just a helper method
        visitAll(asts, context) {
            for (const ast of asts) {
                this.visit(ast, context);
            }
        }
    }
    class AstTransformer {
        visitImplicitReceiver(ast, context) {
            return ast;
        }
        visitInterpolation(ast, context) {
            return new Interpolation(ast.span, ast.sourceSpan, ast.strings, this.visitAll(ast.expressions));
        }
        visitLiteralPrimitive(ast, context) {
            return new LiteralPrimitive(ast.span, ast.sourceSpan, ast.value);
        }
        visitPropertyRead(ast, context) {
            return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);
        }
        visitPropertyWrite(ast, context) {
            return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name, ast.value.visit(this));
        }
        visitSafePropertyRead(ast, context) {
            return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);
        }
        visitMethodCall(ast, context) {
            return new MethodCall(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));
        }
        visitSafeMethodCall(ast, context) {
            return new SafeMethodCall(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));
        }
        visitFunctionCall(ast, context) {
            return new FunctionCall(ast.span, ast.sourceSpan, ast.target.visit(this), this.visitAll(ast.args));
        }
        visitLiteralArray(ast, context) {
            return new LiteralArray(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));
        }
        visitLiteralMap(ast, context) {
            return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, this.visitAll(ast.values));
        }
        visitBinary(ast, context) {
            return new Binary(ast.span, ast.sourceSpan, ast.operation, ast.left.visit(this), ast.right.visit(this));
        }
        visitPrefixNot(ast, context) {
            return new PrefixNot(ast.span, ast.sourceSpan, ast.expression.visit(this));
        }
        visitNonNullAssert(ast, context) {
            return new NonNullAssert(ast.span, ast.sourceSpan, ast.expression.visit(this));
        }
        visitConditional(ast, context) {
            return new Conditional(ast.span, ast.sourceSpan, ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));
        }
        visitPipe(ast, context) {
            return new BindingPipe(ast.span, ast.sourceSpan, ast.exp.visit(this), ast.name, this.visitAll(ast.args), ast.nameSpan);
        }
        visitKeyedRead(ast, context) {
            return new KeyedRead(ast.span, ast.sourceSpan, ast.obj.visit(this), ast.key.visit(this));
        }
        visitKeyedWrite(ast, context) {
            return new KeyedWrite(ast.span, ast.sourceSpan, ast.obj.visit(this), ast.key.visit(this), ast.value.visit(this));
        }
        visitAll(asts) {
            const res = [];
            for (let i = 0; i < asts.length; ++i) {
                res[i] = asts[i].visit(this);
            }
            return res;
        }
        visitChain(ast, context) {
            return new Chain(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));
        }
        visitQuote(ast, context) {
            return new Quote(ast.span, ast.sourceSpan, ast.prefix, ast.uninterpretedExpression, ast.location);
        }
    }
    // A transformer that only creates new nodes if the transformer makes a change or
    // a change is made a child node.
    class AstMemoryEfficientTransformer {
        visitImplicitReceiver(ast, context) {
            return ast;
        }
        visitInterpolation(ast, context) {
            const expressions = this.visitAll(ast.expressions);
            if (expressions !== ast.expressions)
                return new Interpolation(ast.span, ast.sourceSpan, ast.strings, expressions);
            return ast;
        }
        visitLiteralPrimitive(ast, context) {
            return ast;
        }
        visitPropertyRead(ast, context) {
            const receiver = ast.receiver.visit(this);
            if (receiver !== ast.receiver) {
                return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);
            }
            return ast;
        }
        visitPropertyWrite(ast, context) {
            const receiver = ast.receiver.visit(this);
            const value = ast.value.visit(this);
            if (receiver !== ast.receiver || value !== ast.value) {
                return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, value);
            }
            return ast;
        }
        visitSafePropertyRead(ast, context) {
            const receiver = ast.receiver.visit(this);
            if (receiver !== ast.receiver) {
                return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);
            }
            return ast;
        }
        visitMethodCall(ast, context) {
            const receiver = ast.receiver.visit(this);
            const args = this.visitAll(ast.args);
            if (receiver !== ast.receiver || args !== ast.args) {
                return new MethodCall(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, args);
            }
            return ast;
        }
        visitSafeMethodCall(ast, context) {
            const receiver = ast.receiver.visit(this);
            const args = this.visitAll(ast.args);
            if (receiver !== ast.receiver || args !== ast.args) {
                return new SafeMethodCall(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, args);
            }
            return ast;
        }
        visitFunctionCall(ast, context) {
            const target = ast.target && ast.target.visit(this);
            const args = this.visitAll(ast.args);
            if (target !== ast.target || args !== ast.args) {
                return new FunctionCall(ast.span, ast.sourceSpan, target, args);
            }
            return ast;
        }
        visitLiteralArray(ast, context) {
            const expressions = this.visitAll(ast.expressions);
            if (expressions !== ast.expressions) {
                return new LiteralArray(ast.span, ast.sourceSpan, expressions);
            }
            return ast;
        }
        visitLiteralMap(ast, context) {
            const values = this.visitAll(ast.values);
            if (values !== ast.values) {
                return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, values);
            }
            return ast;
        }
        visitBinary(ast, context) {
            const left = ast.left.visit(this);
            const right = ast.right.visit(this);
            if (left !== ast.left || right !== ast.right) {
                return new Binary(ast.span, ast.sourceSpan, ast.operation, left, right);
            }
            return ast;
        }
        visitPrefixNot(ast, context) {
            const expression = ast.expression.visit(this);
            if (expression !== ast.expression) {
                return new PrefixNot(ast.span, ast.sourceSpan, expression);
            }
            return ast;
        }
        visitNonNullAssert(ast, context) {
            const expression = ast.expression.visit(this);
            if (expression !== ast.expression) {
                return new NonNullAssert(ast.span, ast.sourceSpan, expression);
            }
            return ast;
        }
        visitConditional(ast, context) {
            const condition = ast.condition.visit(this);
            const trueExp = ast.trueExp.visit(this);
            const falseExp = ast.falseExp.visit(this);
            if (condition !== ast.condition || trueExp !== ast.trueExp || falseExp !== ast.falseExp) {
                return new Conditional(ast.span, ast.sourceSpan, condition, trueExp, falseExp);
            }
            return ast;
        }
        visitPipe(ast, context) {
            const exp = ast.exp.visit(this);
            const args = this.visitAll(ast.args);
            if (exp !== ast.exp || args !== ast.args) {
                return new BindingPipe(ast.span, ast.sourceSpan, exp, ast.name, args, ast.nameSpan);
            }
            return ast;
        }
        visitKeyedRead(ast, context) {
            const obj = ast.obj.visit(this);
            const key = ast.key.visit(this);
            if (obj !== ast.obj || key !== ast.key) {
                return new KeyedRead(ast.span, ast.sourceSpan, obj, key);
            }
            return ast;
        }
        visitKeyedWrite(ast, context) {
            const obj = ast.obj.visit(this);
            const key = ast.key.visit(this);
            const value = ast.value.visit(this);
            if (obj !== ast.obj || key !== ast.key || value !== ast.value) {
                return new KeyedWrite(ast.span, ast.sourceSpan, obj, key, value);
            }
            return ast;
        }
        visitAll(asts) {
            const res = [];
            let modified = false;
            for (let i = 0; i < asts.length; ++i) {
                const original = asts[i];
                const value = original.visit(this);
                res[i] = value;
                modified = modified || value !== original;
            }
            return modified ? res : asts;
        }
        visitChain(ast, context) {
            const expressions = this.visitAll(ast.expressions);
            if (expressions !== ast.expressions) {
                return new Chain(ast.span, ast.sourceSpan, expressions);
            }
            return ast;
        }
        visitQuote(ast, context) {
            return ast;
        }
    }
    // Bindings
    class ParsedProperty {
        constructor(name, expression, type, sourceSpan, valueSpan) {
            this.name = name;
            this.expression = expression;
            this.type = type;
            this.sourceSpan = sourceSpan;
            this.valueSpan = valueSpan;
            this.isLiteral = this.type === ParsedPropertyType.LITERAL_ATTR;
            this.isAnimation = this.type === ParsedPropertyType.ANIMATION;
        }
    }
    var ParsedPropertyType;
    (function (ParsedPropertyType) {
        ParsedPropertyType[ParsedPropertyType["DEFAULT"] = 0] = "DEFAULT";
        ParsedPropertyType[ParsedPropertyType["LITERAL_ATTR"] = 1] = "LITERAL_ATTR";
        ParsedPropertyType[ParsedPropertyType["ANIMATION"] = 2] = "ANIMATION";
    })(ParsedPropertyType || (ParsedPropertyType = {}));
    class ParsedEvent {
        // Regular events have a target
        // Animation events have a phase
        constructor(name, targetOrPhase, type, handler, sourceSpan, handlerSpan) {
            this.name = name;
            this.targetOrPhase = targetOrPhase;
            this.type = type;
            this.handler = handler;
            this.sourceSpan = sourceSpan;
            this.handlerSpan = handlerSpan;
        }
    }
    /**
     * ParsedVariable represents a variable declaration in a microsyntax expression.
     */
    class ParsedVariable {
        constructor(name, value, sourceSpan, keySpan, valueSpan) {
            this.name = name;
            this.value = value;
            this.sourceSpan = sourceSpan;
            this.keySpan = keySpan;
            this.valueSpan = valueSpan;
        }
    }
    class BoundElementProperty {
        constructor(name, type, securityContext, value, unit, sourceSpan, valueSpan) {
            this.name = name;
            this.type = type;
            this.securityContext = securityContext;
            this.value = value;
            this.unit = unit;
            this.sourceSpan = sourceSpan;
            this.valueSpan = valueSpan;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class EventHandlerVars {
    }
    EventHandlerVars.event = variable('$event');
    class ConvertActionBindingResult {
        constructor(
        /**
         * Render2 compatible statements,
         */
        stmts, 
        /**
         * Variable name used with render2 compatible statements.
         */
        allowDefault) {
            this.stmts = stmts;
            this.allowDefault = allowDefault;
            /**
             * This is bit of a hack. It converts statements which render2 expects to statements which are
             * expected by render3.
             *
             * Example: `<div click="doSomething($event)">` will generate:
             *
             * Render3:
             * ```
             * const pd_b:any = ((<any>ctx.doSomething($event)) !== false);
             * return pd_b;
             * ```
             *
             * but render2 expects:
             * ```
             * return ctx.doSomething($event);
             * ```
             */
            // TODO(misko): remove this hack once we no longer support ViewEngine.
            this.render3Stmts = stmts.map((statement) => {
                if (statement instanceof DeclareVarStmt && statement.name == allowDefault.name &&
                    statement.value instanceof BinaryOperatorExpr) {
                    const lhs = statement.value.lhs;
                    return new ReturnStatement(lhs.value);
                }
                return statement;
            });
        }
    }
    /**
     * Converts the given expression AST into an executable output AST, assuming the expression is
     * used in an action binding (e.g. an event handler).
     */
    function convertActionBinding(localResolver, implicitReceiver, action, bindingId, interpolationFunction, baseSourceSpan, implicitReceiverAccesses) {
        if (!localResolver) {
            localResolver = new DefaultLocalResolver();
        }
        const actionWithoutBuiltins = convertPropertyBindingBuiltins({
            createLiteralArrayConverter: (argCount) => {
                // Note: no caching for literal arrays in actions.
                return (args) => literalArr(args);
            },
            createLiteralMapConverter: (keys) => {
                // Note: no caching for literal maps in actions.
                return (values) => {
                    const entries = keys.map((k, i) => ({
                        key: k.key,
                        value: values[i],
                        quoted: k.quoted,
                    }));
                    return literalMap(entries);
                };
            },
            createPipeConverter: (name) => {
                throw new Error(`Illegal State: Actions are not allowed to contain pipes. Pipe: ${name}`);
            }
        }, action);
        const visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction, baseSourceSpan, implicitReceiverAccesses);
        const actionStmts = [];
        flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);
        prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);
        if (visitor.usesImplicitReceiver) {
            localResolver.notifyImplicitReceiverUse();
        }
        const lastIndex = actionStmts.length - 1;
        let preventDefaultVar = null;
        if (lastIndex >= 0) {
            const lastStatement = actionStmts[lastIndex];
            const returnExpr = convertStmtIntoExpression(lastStatement);
            if (returnExpr) {
                // Note: We need to cast the result of the method call to dynamic,
                // as it might be a void method!
                preventDefaultVar = createPreventDefaultVar(bindingId);
                actionStmts[lastIndex] =
                    preventDefaultVar.set(returnExpr.cast(DYNAMIC_TYPE).notIdentical(literal(false)))
                        .toDeclStmt(null, [StmtModifier.Final]);
            }
        }
        return new ConvertActionBindingResult(actionStmts, preventDefaultVar);
    }
    function convertPropertyBindingBuiltins(converterFactory, ast) {
        return convertBuiltins(converterFactory, ast);
    }
    class ConvertPropertyBindingResult {
        constructor(stmts, currValExpr) {
            this.stmts = stmts;
            this.currValExpr = currValExpr;
        }
    }
    var BindingForm;
    (function (BindingForm) {
        // The general form of binding expression, supports all expressions.
        BindingForm[BindingForm["General"] = 0] = "General";
        // Try to generate a simple binding (no temporaries or statements)
        // otherwise generate a general binding
        BindingForm[BindingForm["TrySimple"] = 1] = "TrySimple";
        // Inlines assignment of temporaries into the generated expression. The result may still
        // have statements attached for declarations of temporary variables.
        // This is the only relevant form for Ivy, the other forms are only used in ViewEngine.
        BindingForm[BindingForm["Expression"] = 2] = "Expression";
    })(BindingForm || (BindingForm = {}));
    /**
     * Converts the given expression AST into an executable output AST, assuming the expression
     * is used in property binding. The expression has to be preprocessed via
     * `convertPropertyBindingBuiltins`.
     */
    function convertPropertyBinding(localResolver, implicitReceiver, expressionWithoutBuiltins, bindingId, form, interpolationFunction) {
        if (!localResolver) {
            localResolver = new DefaultLocalResolver();
        }
        const visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction);
        const outputExpr = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);
        const stmts = getStatementsFromVisitor(visitor, bindingId);
        if (visitor.usesImplicitReceiver) {
            localResolver.notifyImplicitReceiverUse();
        }
        if (visitor.temporaryCount === 0 && form == BindingForm.TrySimple) {
            return new ConvertPropertyBindingResult([], outputExpr);
        }
        else if (form === BindingForm.Expression) {
            return new ConvertPropertyBindingResult(stmts, outputExpr);
        }
        const currValExpr = createCurrValueExpr(bindingId);
        stmts.push(currValExpr.set(outputExpr).toDeclStmt(DYNAMIC_TYPE, [StmtModifier.Final]));
        return new ConvertPropertyBindingResult(stmts, currValExpr);
    }
    /**
     * Given some expression, such as a binding or interpolation expression, and a context expression to
     * look values up on, visit each facet of the given expression resolving values from the context
     * expression such that a list of arguments can be derived from the found values that can be used as
     * arguments to an external update instruction.
     *
     * @param localResolver The resolver to use to look up expressions by name appropriately
     * @param contextVariableExpression The expression representing the context variable used to create
     * the final argument expressions
     * @param expressionWithArgumentsToExtract The expression to visit to figure out what values need to
     * be resolved and what arguments list to build.
     * @param bindingId A name prefix used to create temporary variable names if they're needed for the
     * arguments generated
     * @returns An array of expressions that can be passed as arguments to instruction expressions like
     * `o.importExpr(R3.propertyInterpolate).callFn(result)`
     */
    function convertUpdateArguments(localResolver, contextVariableExpression, expressionWithArgumentsToExtract, bindingId) {
        const visitor = new _AstToIrVisitor(localResolver, contextVariableExpression, bindingId, undefined);
        const outputExpr = expressionWithArgumentsToExtract.visit(visitor, _Mode.Expression);
        if (visitor.usesImplicitReceiver) {
            localResolver.notifyImplicitReceiverUse();
        }
        const stmts = getStatementsFromVisitor(visitor, bindingId);
        // Removing the first argument, because it was a length for ViewEngine, not Ivy.
        let args = outputExpr.args.slice(1);
        if (expressionWithArgumentsToExtract instanceof Interpolation) {
            // If we're dealing with an interpolation of 1 value with an empty prefix and suffix, reduce the
            // args returned to just the value, because we're going to pass it to a special instruction.
            const strings = expressionWithArgumentsToExtract.strings;
            if (args.length === 3 && strings[0] === '' && strings[1] === '') {
                // Single argument interpolate instructions.
                args = [args[1]];
            }
            else if (args.length >= 19) {
                // 19 or more arguments must be passed to the `interpolateV`-style instructions, which accept
                // an array of arguments
                args = [literalArr(args)];
            }
        }
        return { stmts, args };
    }
    function getStatementsFromVisitor(visitor, bindingId) {
        const stmts = [];
        for (let i = 0; i < visitor.temporaryCount; i++) {
            stmts.push(temporaryDeclaration(bindingId, i));
        }
        return stmts;
    }
    function convertBuiltins(converterFactory, ast) {
        const visitor = new _BuiltinAstConverter(converterFactory);
        return ast.visit(visitor);
    }
    function temporaryName(bindingId, temporaryNumber) {
        return `tmp_${bindingId}_${temporaryNumber}`;
    }
    function temporaryDeclaration(bindingId, temporaryNumber) {
        return new DeclareVarStmt(temporaryName(bindingId, temporaryNumber), NULL_EXPR);
    }
    function prependTemporaryDecls(temporaryCount, bindingId, statements) {
        for (let i = temporaryCount - 1; i >= 0; i--) {
            statements.unshift(temporaryDeclaration(bindingId, i));
        }
    }
    var _Mode;
    (function (_Mode) {
        _Mode[_Mode["Statement"] = 0] = "Statement";
        _Mode[_Mode["Expression"] = 1] = "Expression";
    })(_Mode || (_Mode = {}));
    function ensureStatementMode(mode, ast) {
        if (mode !== _Mode.Statement) {
            throw new Error(`Expected a statement, but saw ${ast}`);
        }
    }
    function ensureExpressionMode(mode, ast) {
        if (mode !== _Mode.Expression) {
            throw new Error(`Expected an expression, but saw ${ast}`);
        }
    }
    function convertToStatementIfNeeded(mode, expr) {
        if (mode === _Mode.Statement) {
            return expr.toStmt();
        }
        else {
            return expr;
        }
    }
    class _BuiltinAstConverter extends AstTransformer {
        constructor(_converterFactory) {
            super();
            this._converterFactory = _converterFactory;
        }
        visitPipe(ast, context) {
            const args = [ast.exp, ...ast.args].map(ast => ast.visit(this, context));
            return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createPipeConverter(ast.name, args.length));
        }
        visitLiteralArray(ast, context) {
            const args = ast.expressions.map(ast => ast.visit(this, context));
            return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralArrayConverter(ast.expressions.length));
        }
        visitLiteralMap(ast, context) {
            const args = ast.values.map(ast => ast.visit(this, context));
            return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralMapConverter(ast.keys));
        }
    }
    class _AstToIrVisitor {
        constructor(_localResolver, _implicitReceiver, bindingId, interpolationFunction, baseSourceSpan, implicitReceiverAccesses) {
            this._localResolver = _localResolver;
            this._implicitReceiver = _implicitReceiver;
            this.bindingId = bindingId;
            this.interpolationFunction = interpolationFunction;
            this.baseSourceSpan = baseSourceSpan;
            this.implicitReceiverAccesses = implicitReceiverAccesses;
            this._nodeMap = new Map();
            this._resultMap = new Map();
            this._currentTemporary = 0;
            this.temporaryCount = 0;
            this.usesImplicitReceiver = false;
        }
        visitBinary(ast, mode) {
            let op;
            switch (ast.operation) {
                case '+':
                    op = BinaryOperator.Plus;
                    break;
                case '-':
                    op = BinaryOperator.Minus;
                    break;
                case '*':
                    op = BinaryOperator.Multiply;
                    break;
                case '/':
                    op = BinaryOperator.Divide;
                    break;
                case '%':
                    op = BinaryOperator.Modulo;
                    break;
                case '&&':
                    op = BinaryOperator.And;
                    break;
                case '||':
                    op = BinaryOperator.Or;
                    break;
                case '==':
                    op = BinaryOperator.Equals;
                    break;
                case '!=':
                    op = BinaryOperator.NotEquals;
                    break;
                case '===':
                    op = BinaryOperator.Identical;
                    break;
                case '!==':
                    op = BinaryOperator.NotIdentical;
                    break;
                case '<':
                    op = BinaryOperator.Lower;
                    break;
                case '>':
                    op = BinaryOperator.Bigger;
                    break;
                case '<=':
                    op = BinaryOperator.LowerEquals;
                    break;
                case '>=':
                    op = BinaryOperator.BiggerEquals;
                    break;
                default:
                    throw new Error(`Unsupported operation ${ast.operation}`);
            }
            return convertToStatementIfNeeded(mode, new BinaryOperatorExpr(op, this._visit(ast.left, _Mode.Expression), this._visit(ast.right, _Mode.Expression), undefined, this.convertSourceSpan(ast.span)));
        }
        visitChain(ast, mode) {
            ensureStatementMode(mode, ast);
            return this.visitAll(ast.expressions, mode);
        }
        visitConditional(ast, mode) {
            const value = this._visit(ast.condition, _Mode.Expression);
            return convertToStatementIfNeeded(mode, value.conditional(this._visit(ast.trueExp, _Mode.Expression), this._visit(ast.falseExp, _Mode.Expression), this.convertSourceSpan(ast.span)));
        }
        visitPipe(ast, mode) {
            throw new Error(`Illegal state: Pipes should have been converted into functions. Pipe: ${ast.name}`);
        }
        visitFunctionCall(ast, mode) {
            const convertedArgs = this.visitAll(ast.args, _Mode.Expression);
            let fnResult;
            if (ast instanceof BuiltinFunctionCall) {
                fnResult = ast.converter(convertedArgs);
            }
            else {
                fnResult = this._visit(ast.target, _Mode.Expression)
                    .callFn(convertedArgs, this.convertSourceSpan(ast.span));
            }
            return convertToStatementIfNeeded(mode, fnResult);
        }
        visitImplicitReceiver(ast, mode) {
            ensureExpressionMode(mode, ast);
            this.usesImplicitReceiver = true;
            return this._implicitReceiver;
        }
        visitInterpolation(ast, mode) {
            ensureExpressionMode(mode, ast);
            const args = [literal(ast.expressions.length)];
            for (let i = 0; i < ast.strings.length - 1; i++) {
                args.push(literal(ast.strings[i]));
                args.push(this._visit(ast.expressions[i], _Mode.Expression));
            }
            args.push(literal(ast.strings[ast.strings.length - 1]));
            if (this.interpolationFunction) {
                return this.interpolationFunction(args);
            }
            return ast.expressions.length <= 9 ?
                importExpr(Identifiers.inlineInterpolate).callFn(args) :
                importExpr(Identifiers.interpolate).callFn([
                    args[0], literalArr(args.slice(1), undefined, this.convertSourceSpan(ast.span))
                ]);
        }
        visitKeyedRead(ast, mode) {
            const leftMostSafe = this.leftMostSafeNode(ast);
            if (leftMostSafe) {
                return this.convertSafeAccess(ast, leftMostSafe, mode);
            }
            else {
                return convertToStatementIfNeeded(mode, this._visit(ast.obj, _Mode.Expression).key(this._visit(ast.key, _Mode.Expression)));
            }
        }
        visitKeyedWrite(ast, mode) {
            const obj = this._visit(ast.obj, _Mode.Expression);
            const key = this._visit(ast.key, _Mode.Expression);
            const value = this._visit(ast.value, _Mode.Expression);
            return convertToStatementIfNeeded(mode, obj.key(key).set(value));
        }
        visitLiteralArray(ast, mode) {
            throw new Error(`Illegal State: literal arrays should have been converted into functions`);
        }
        visitLiteralMap(ast, mode) {
            throw new Error(`Illegal State: literal maps should have been converted into functions`);
        }
        visitLiteralPrimitive(ast, mode) {
            // For literal values of null, undefined, true, or false allow type interference
            // to infer the type.
            const type = ast.value === null || ast.value === undefined || ast.value === true || ast.value === true ?
                INFERRED_TYPE :
                undefined;
            return convertToStatementIfNeeded(mode, literal(ast.value, type, this.convertSourceSpan(ast.span)));
        }
        _getLocal(name) {
            return this._localResolver.getLocal(name);
        }
        visitMethodCall(ast, mode) {
            if (ast.receiver instanceof ImplicitReceiver && ast.name == '$any') {
                const args = this.visitAll(ast.args, _Mode.Expression);
                if (args.length != 1) {
                    throw new Error(`Invalid call to $any, expected 1 argument but received ${args.length || 'none'}`);
                }
                return args[0].cast(DYNAMIC_TYPE, this.convertSourceSpan(ast.span));
            }
            const leftMostSafe = this.leftMostSafeNode(ast);
            if (leftMostSafe) {
                return this.convertSafeAccess(ast, leftMostSafe, mode);
            }
            else {
                const args = this.visitAll(ast.args, _Mode.Expression);
                const prevUsesImplicitReceiver = this.usesImplicitReceiver;
                let result = null;
                const receiver = this._visit(ast.receiver, _Mode.Expression);
                if (receiver === this._implicitReceiver) {
                    const varExpr = this._getLocal(ast.name);
                    if (varExpr) {
                        // Restore the previous "usesImplicitReceiver" state since the implicit
                        // receiver has been replaced with a resolved local expression.
                        this.usesImplicitReceiver = prevUsesImplicitReceiver;
                        result = varExpr.callFn(args);
                    }
                    this.addImplicitReceiverAccess(ast.name);
                }
                if (result == null) {
                    result = receiver.callMethod(ast.name, args, this.convertSourceSpan(ast.span));
                }
                return convertToStatementIfNeeded(mode, result);
            }
        }
        visitPrefixNot(ast, mode) {
            return convertToStatementIfNeeded(mode, not(this._visit(ast.expression, _Mode.Expression)));
        }
        visitNonNullAssert(ast, mode) {
            return convertToStatementIfNeeded(mode, assertNotNull(this._visit(ast.expression, _Mode.Expression)));
        }
        visitPropertyRead(ast, mode) {
            const leftMostSafe = this.leftMostSafeNode(ast);
            if (leftMostSafe) {
                return this.convertSafeAccess(ast, leftMostSafe, mode);
            }
            else {
                let result = null;
                const prevUsesImplicitReceiver = this.usesImplicitReceiver;
                const receiver = this._visit(ast.receiver, _Mode.Expression);
                if (receiver === this._implicitReceiver) {
                    result = this._getLocal(ast.name);
                    if (result) {
                        // Restore the previous "usesImplicitReceiver" state since the implicit
                        // receiver has been replaced with a resolved local expression.
                        this.usesImplicitReceiver = prevUsesImplicitReceiver;
                    }
                    this.addImplicitReceiverAccess(ast.name);
                }
                if (result == null) {
                    result = receiver.prop(ast.name);
                }
                return convertToStatementIfNeeded(mode, result);
            }
        }
        visitPropertyWrite(ast, mode) {
            const receiver = this._visit(ast.receiver, _Mode.Expression);
            const prevUsesImplicitReceiver = this.usesImplicitReceiver;
            let varExpr = null;
            if (receiver === this._implicitReceiver) {
                const localExpr = this._getLocal(ast.name);
                if (localExpr) {
                    if (localExpr instanceof ReadPropExpr) {
                        // If the local variable is a property read expression, it's a reference
                        // to a 'context.property' value and will be used as the target of the
                        // write expression.
                        varExpr = localExpr;
                        // Restore the previous "usesImplicitReceiver" state since the implicit
                        // receiver has been replaced with a resolved local expression.
                        this.usesImplicitReceiver = prevUsesImplicitReceiver;
                        this.addImplicitReceiverAccess(ast.name);
                    }
                    else {
                        // Otherwise it's an error.
                        const receiver = ast.name;
                        const value = (ast.value instanceof PropertyRead) ? ast.value.name : undefined;
                        throw new Error(`Cannot assign value "${value}" to template variable "${receiver}". Template variables are read-only.`);
                    }
                }
            }
            // If no local expression could be produced, use the original receiver's
            // property as the target.
            if (varExpr === null) {
                varExpr = receiver.prop(ast.name);
            }
            return convertToStatementIfNeeded(mode, varExpr.set(this._visit(ast.value, _Mode.Expression)));
        }
        visitSafePropertyRead(ast, mode) {
            return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
        }
        visitSafeMethodCall(ast, mode) {
            return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
        }
        visitAll(asts, mode) {
            return asts.map(ast => this._visit(ast, mode));
        }
        visitQuote(ast, mode) {
            throw new Error(`Quotes are not supported for evaluation!
        Statement: ${ast.uninterpretedExpression} located at ${ast.location}`);
        }
        _visit(ast, mode) {
            const result = this._resultMap.get(ast);
            if (result)
                return result;
            return (this._nodeMap.get(ast) || ast).visit(this, mode);
        }
        convertSafeAccess(ast, leftMostSafe, mode) {
            // If the expression contains a safe access node on the left it needs to be converted to
            // an expression that guards the access to the member by checking the receiver for blank. As
            // execution proceeds from left to right, the left most part of the expression must be guarded
            // first but, because member access is left associative, the right side of the expression is at
            // the top of the AST. The desired result requires lifting a copy of the left part of the
            // expression up to test it for blank before generating the unguarded version.
            // Consider, for example the following expression: a?.b.c?.d.e
            // This results in the ast:
            //         .
            //        / \
            //       ?.   e
            //      /  \
            //     .    d
            //    / \
            //   ?.  c
            //  /  \
            // a    b
            // The following tree should be generated:
            //
            //        /---- ? ----\
            //       /      |      \
            //     a   /--- ? ---\  null
            //        /     |     \
            //       .      .     null
            //      / \    / \
            //     .  c   .   e
            //    / \    / \
            //   a   b  .   d
            //         / \
            //        .   c
            //       / \
            //      a   b
            //
            // Notice that the first guard condition is the left hand of the left most safe access node
            // which comes in as leftMostSafe to this routine.
            let guardedExpression = this._visit(leftMostSafe.receiver, _Mode.Expression);
            let temporary = undefined;
            if (this.needsTemporary(leftMostSafe.receiver)) {
                // If the expression has method calls or pipes then we need to save the result into a
                // temporary variable to avoid calling stateful or impure code more than once.
                temporary = this.allocateTemporary();
                // Preserve the result in the temporary variable
                guardedExpression = temporary.set(guardedExpression);
                // Ensure all further references to the guarded expression refer to the temporary instead.
                this._resultMap.set(leftMostSafe.receiver, temporary);
            }
            const condition = guardedExpression.isBlank();
            // Convert the ast to an unguarded access to the receiver's member. The map will substitute
            // leftMostNode with its unguarded version in the call to `this.visit()`.
            if (leftMostSafe instanceof SafeMethodCall) {
                this._nodeMap.set(leftMostSafe, new MethodCall(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.nameSpan, leftMostSafe.receiver, leftMostSafe.name, leftMostSafe.args));
            }
            else {
                this._nodeMap.set(leftMostSafe, new PropertyRead(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.nameSpan, leftMostSafe.receiver, leftMostSafe.name));
            }
            // Recursively convert the node now without the guarded member access.
            const access = this._visit(ast, _Mode.Expression);
            // Remove the mapping. This is not strictly required as the converter only traverses each node
            // once but is safer if the conversion is changed to traverse the nodes more than once.
            this._nodeMap.delete(leftMostSafe);
            // If we allocated a temporary, release it.
            if (temporary) {
                this.releaseTemporary(temporary);
            }
            // Produce the conditional
            return convertToStatementIfNeeded(mode, condition.conditional(literal(null), access));
        }
        // Given an expression of the form a?.b.c?.d.e then the left most safe node is
        // the (a?.b). The . and ?. are left associative thus can be rewritten as:
        // ((((a?.c).b).c)?.d).e. This returns the most deeply nested safe read or
        // safe method call as this needs to be transformed initially to:
        //   a == null ? null : a.c.b.c?.d.e
        // then to:
        //   a == null ? null : a.b.c == null ? null : a.b.c.d.e
        leftMostSafeNode(ast) {
            const visit = (visitor, ast) => {
                return (this._nodeMap.get(ast) || ast).visit(visitor);
            };
            return ast.visit({
                visitBinary(ast) {
                    return null;
                },
                visitChain(ast) {
                    return null;
                },
                visitConditional(ast) {
                    return null;
                },
                visitFunctionCall(ast) {
                    return null;
                },
                visitImplicitReceiver(ast) {
                    return null;
                },
                visitInterpolation(ast) {
                    return null;
                },
                visitKeyedRead(ast) {
                    return visit(this, ast.obj);
                },
                visitKeyedWrite(ast) {
                    return null;
                },
                visitLiteralArray(ast) {
                    return null;
                },
                visitLiteralMap(ast) {
                    return null;
                },
                visitLiteralPrimitive(ast) {
                    return null;
                },
                visitMethodCall(ast) {
                    return visit(this, ast.receiver);
                },
                visitPipe(ast) {
                    return null;
                },
                visitPrefixNot(ast) {
                    return null;
                },
                visitNonNullAssert(ast) {
                    return null;
                },
                visitPropertyRead(ast) {
                    return visit(this, ast.receiver);
                },
                visitPropertyWrite(ast) {
                    return null;
                },
                visitQuote(ast) {
                    return null;
                },
                visitSafeMethodCall(ast) {
                    return visit(this, ast.receiver) || ast;
                },
                visitSafePropertyRead(ast) {
                    return visit(this, ast.receiver) || ast;
                }
            });
        }
        // Returns true of the AST includes a method or a pipe indicating that, if the
        // expression is used as the target of a safe property or method access then
        // the expression should be stored into a temporary variable.
        needsTemporary(ast) {
            const visit = (visitor, ast) => {
                return ast && (this._nodeMap.get(ast) || ast).visit(visitor);
            };
            const visitSome = (visitor, ast) => {
                return ast.some(ast => visit(visitor, ast));
            };
            return ast.visit({
                visitBinary(ast) {
                    return visit(this, ast.left) || visit(this, ast.right);
                },
                visitChain(ast) {
                    return false;
                },
                visitConditional(ast) {
                    return visit(this, ast.condition) || visit(this, ast.trueExp) || visit(this, ast.falseExp);
                },
                visitFunctionCall(ast) {
                    return true;
                },
                visitImplicitReceiver(ast) {
                    return false;
                },
                visitInterpolation(ast) {
                    return visitSome(this, ast.expressions);
                },
                visitKeyedRead(ast) {
                    return false;
                },
                visitKeyedWrite(ast) {
                    return false;
                },
                visitLiteralArray(ast) {
                    return true;
                },
                visitLiteralMap(ast) {
                    return true;
                },
                visitLiteralPrimitive(ast) {
                    return false;
                },
                visitMethodCall(ast) {
                    return true;
                },
                visitPipe(ast) {
                    return true;
                },
                visitPrefixNot(ast) {
                    return visit(this, ast.expression);
                },
                visitNonNullAssert(ast) {
                    return visit(this, ast.expression);
                },
                visitPropertyRead(ast) {
                    return false;
                },
                visitPropertyWrite(ast) {
                    return false;
                },
                visitQuote(ast) {
                    return false;
                },
                visitSafeMethodCall(ast) {
                    return true;
                },
                visitSafePropertyRead(ast) {
                    return false;
                }
            });
        }
        allocateTemporary() {
            const tempNumber = this._currentTemporary++;
            this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);
            return new ReadVarExpr(temporaryName(this.bindingId, tempNumber));
        }
        releaseTemporary(temporary) {
            this._currentTemporary--;
            if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {
                throw new Error(`Temporary ${temporary.name} released out of order`);
            }
        }
        /**
         * Creates an absolute `ParseSourceSpan` from the relative `ParseSpan`.
         *
         * `ParseSpan` objects are relative to the start of the expression.
         * This method converts these to full `ParseSourceSpan` objects that
         * show where the span is within the overall source file.
         *
         * @param span the relative span to convert.
         * @returns a `ParseSourceSpan` for the given span or null if no
         * `baseSourceSpan` was provided to this class.
         */
        convertSourceSpan(span) {
            if (this.baseSourceSpan) {
                const start = this.baseSourceSpan.start.moveBy(span.start);
                const end = this.baseSourceSpan.start.moveBy(span.end);
                return new ParseSourceSpan(start, end);
            }
            else {
                return null;
            }
        }
        /** Adds the name of an AST to the list of implicit receiver accesses. */
        addImplicitReceiverAccess(name) {
            if (this.implicitReceiverAccesses) {
                this.implicitReceiverAccesses.add(name);
            }
        }
    }
    function flattenStatements(arg, output) {
        if (Array.isArray(arg)) {
            arg.forEach((entry) => flattenStatements(entry, output));
        }
        else {
            output.push(arg);
        }
    }
    class DefaultLocalResolver {
        notifyImplicitReceiverUse() { }
        getLocal(name) {
            if (name === EventHandlerVars.event.name) {
                return EventHandlerVars.event;
            }
            return null;
        }
    }
    function createCurrValueExpr(bindingId) {
        return variable(`currVal_${bindingId}`); // fix syntax highlighting: `
    }
    function createPreventDefaultVar(bindingId) {
        return variable(`pd_${bindingId}`);
    }
    function convertStmtIntoExpression(stmt) {
        if (stmt instanceof ExpressionStatement) {
            return stmt.expr;
        }
        else if (stmt instanceof ReturnStatement) {
            return stmt.value;
        }
        return null;
    }
    class BuiltinFunctionCall extends FunctionCall {
        constructor(span, sourceSpan, args, converter) {
            super(span, sourceSpan, null, args);
            this.args = args;
            this.converter = converter;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * This file is a port of shadowCSS from webcomponents.js to TypeScript.
     *
     * Please make sure to keep to edits in sync with the source file.
     *
     * Source:
     * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js
     *
     * The original file level comment is reproduced below
     */
    /*
      This is a limited shim for ShadowDOM css styling.
      https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#styles

      The intention here is to support only the styling features which can be
      relatively simply implemented. The goal is to allow users to avoid the
      most obvious pitfalls and do so without compromising performance significantly.
      For ShadowDOM styling that's not covered here, a set of best practices
      can be provided that should allow users to accomplish more complex styling.

      The following is a list of specific ShadowDOM styling features and a brief
      discussion of the approach used to shim.

      Shimmed features:

      * :host, :host-context: ShadowDOM allows styling of the shadowRoot's host
      element using the :host rule. To shim this feature, the :host styles are
      reformatted and prefixed with a given scope name and promoted to a
      document level stylesheet.
      For example, given a scope name of .foo, a rule like this:

        :host {
            background: red;
          }
        }

      becomes:

        .foo {
          background: red;
        }

      * encapsulation: Styles defined within ShadowDOM, apply only to
      dom inside the ShadowDOM. Polymer uses one of two techniques to implement
      this feature.

      By default, rules are prefixed with the host element tag name
      as a descendant selector. This ensures styling does not leak out of the 'top'
      of the element's ShadowDOM. For example,

      div {
          font-weight: bold;
        }

      becomes:

      x-foo div {
          font-weight: bold;
        }

      becomes:


      Alternatively, if WebComponents.ShadowCSS.strictStyling is set to true then
      selectors are scoped by adding an attribute selector suffix to each
      simple selector that contains the host element tag name. Each element
      in the element's ShadowDOM template is also given the scope attribute.
      Thus, these rules match only elements that have the scope attribute.
      For example, given a scope name of x-foo, a rule like this:

        div {
          font-weight: bold;
        }

      becomes:

        div[x-foo] {
          font-weight: bold;
        }

      Note that elements that are dynamically added to a scope must have the scope
      selector added to them manually.

      * upper/lower bound encapsulation: Styles which are defined outside a
      shadowRoot should not cross the ShadowDOM boundary and should not apply
      inside a shadowRoot.

      This styling behavior is not emulated. Some possible ways to do this that
      were rejected due to complexity and/or performance concerns include: (1) reset
      every possible property for every possible selector for a given scope name;
      (2) re-implement css in javascript.

      As an alternative, users should make sure to use selectors
      specific to the scope in which they are working.

      * ::distributed: This behavior is not emulated. It's often not necessary
      to style the contents of a specific insertion point and instead, descendants
      of the host element can be styled selectively. Users can also create an
      extra node around an insertion point and style that node's contents
      via descendent selectors. For example, with a shadowRoot like this:

        <style>
          ::content(div) {
            background: red;
          }
        </style>
        <content></content>

      could become:

        <style>
          / *@polyfill .content-container div * /
          ::content(div) {
            background: red;
          }
        </style>
        <div class="content-container">
          <content></content>
        </div>

      Note the use of @polyfill in the comment above a ShadowDOM specific style
      declaration. This is a directive to the styling shim to use the selector
      in comments in lieu of the next selector when running under polyfill.
    */
    class ShadowCss {
        constructor() {
            this.strictStyling = true;
        }
        /*
         * Shim some cssText with the given selector. Returns cssText that can
         * be included in the document via WebComponents.ShadowCSS.addCssToDocument(css).
         *
         * When strictStyling is true:
         * - selector is the attribute added to all elements inside the host,
         * - hostSelector is the attribute added to the host itself.
         */
        shimCssText(cssText, selector, hostSelector = '') {
            const commentsWithHash = extractCommentsWithHash(cssText);
            cssText = stripComments(cssText);
            cssText = this._insertDirectives(cssText);
            const scopedCssText = this._scopeCssText(cssText, selector, hostSelector);
            return [scopedCssText, ...commentsWithHash].join('\n');
        }
        _insertDirectives(cssText) {
            cssText = this._insertPolyfillDirectivesInCssText(cssText);
            return this._insertPolyfillRulesInCssText(cssText);
        }
        /*
         * Process styles to convert native ShadowDOM rules that will trip
         * up the css parser; we rely on decorating the stylesheet with inert rules.
         *
         * For example, we convert this rule:
         *
         * polyfill-next-selector { content: ':host menu-item'; }
         * ::content menu-item {
         *
         * to this:
         *
         * scopeName menu-item {
         *
         **/
        _insertPolyfillDirectivesInCssText(cssText) {
            // Difference with webcomponents.js: does not handle comments
            return cssText.replace(_cssContentNextSelectorRe, function (...m) {
                return m[2] + '{';
            });
        }
        /*
         * Process styles to add rules which will only apply under the polyfill
         *
         * For example, we convert this rule:
         *
         * polyfill-rule {
         *   content: ':host menu-item';
         * ...
         * }
         *
         * to this:
         *
         * scopeName menu-item {...}
         *
         **/
        _insertPolyfillRulesInCssText(cssText) {
            // Difference with webcomponents.js: does not handle comments
            return cssText.replace(_cssContentRuleRe, (...m) => {
                const rule = m[0].replace(m[1], '').replace(m[2], '');
                return m[4] + rule;
            });
        }
        /* Ensure styles are scoped. Pseudo-scoping takes a rule like:
         *
         *  .foo {... }
         *
         *  and converts this to
         *
         *  scopeName .foo { ... }
         */
        _scopeCssText(cssText, scopeSelector, hostSelector) {
            const unscopedRules = this._extractUnscopedRulesFromCssText(cssText);
            // replace :host and :host-context -shadowcsshost and -shadowcsshost respectively
            cssText = this._insertPolyfillHostInCssText(cssText);
            cssText = this._convertColonHost(cssText);
            cssText = this._convertColonHostContext(cssText);
            cssText = this._convertShadowDOMSelectors(cssText);
            if (scopeSelector) {
                cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);
            }
            cssText = cssText + '\n' + unscopedRules;
            return cssText.trim();
        }
        /*
         * Process styles to add rules which will only apply under the polyfill
         * and do not process via CSSOM. (CSSOM is destructive to rules on rare
         * occasions, e.g. -webkit-calc on Safari.)
         * For example, we convert this rule:
         *
         * @polyfill-unscoped-rule {
         *   content: 'menu-item';
         * ... }
         *
         * to this:
         *
         * menu-item {...}
         *
         **/
        _extractUnscopedRulesFromCssText(cssText) {
            // Difference with webcomponents.js: does not handle comments
            let r = '';
            let m;
            _cssContentUnscopedRuleRe.lastIndex = 0;
            while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {
                const rule = m[0].replace(m[2], '').replace(m[1], m[4]);
                r += rule + '\n\n';
            }
            return r;
        }
        /*
         * convert a rule like :host(.foo) > .bar { }
         *
         * to
         *
         * .foo<scopeName> > .bar
         */
        _convertColonHost(cssText) {
            return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);
        }
        /*
         * convert a rule like :host-context(.foo) > .bar { }
         *
         * to
         *
         * .foo<scopeName> > .bar, .foo scopeName > .bar { }
         *
         * and
         *
         * :host-context(.foo:host) .bar { ... }
         *
         * to
         *
         * .foo<scopeName> .bar { ... }
         */
        _convertColonHostContext(cssText) {
            return this._convertColonRule(cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);
        }
        _convertColonRule(cssText, regExp, partReplacer) {
            // m[1] = :host(-context), m[2] = contents of (), m[3] rest of rule
            return cssText.replace(regExp, function (...m) {
                if (m[2]) {
                    const parts = m[2].split(',');
                    const r = [];
                    for (let i = 0; i < parts.length; i++) {
                        const p = parts[i].trim();
                        if (!p)
                            break;
                        r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));
                    }
                    return r.join(',');
                }
                else {
                    return _polyfillHostNoCombinator + m[3];
                }
            });
        }
        _colonHostContextPartReplacer(host, part, suffix) {
            if (part.indexOf(_polyfillHost) > -1) {
                return this._colonHostPartReplacer(host, part, suffix);
            }
            else {
                return host + part + suffix + ', ' + part + ' ' + host + suffix;
            }
        }
        _colonHostPartReplacer(host, part, suffix) {
            return host + part.replace(_polyfillHost, '') + suffix;
        }
        /*
         * Convert combinators like ::shadow and pseudo-elements like ::content
         * by replacing with space.
         */
        _convertShadowDOMSelectors(cssText) {
            return _shadowDOMSelectorsRe.reduce((result, pattern) => result.replace(pattern, ' '), cssText);
        }
        // change a selector like 'div' to 'name div'
        _scopeSelectors(cssText, scopeSelector, hostSelector) {
            return processRules(cssText, (rule) => {
                let selector = rule.selector;
                let content = rule.content;
                if (rule.selector[0] != '@') {
                    selector =
                        this._scopeSelector(rule.selector, scopeSelector, hostSelector, this.strictStyling);
                }
                else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') ||
                    rule.selector.startsWith('@page') || rule.selector.startsWith('@document')) {
                    content = this._scopeSelectors(rule.content, scopeSelector, hostSelector);
                }
                return new CssRule(selector, content);
            });
        }
        _scopeSelector(selector, scopeSelector, hostSelector, strict) {
            return selector.split(',')
                .map(part => part.trim().split(_shadowDeepSelectors))
                .map((deepParts) => {
                const [shallowPart, ...otherParts] = deepParts;
                const applyScope = (shallowPart) => {
                    if (this._selectorNeedsScoping(shallowPart, scopeSelector)) {
                        return strict ?
                            this._applyStrictSelectorScope(shallowPart, scopeSelector, hostSelector) :
                            this._applySelectorScope(shallowPart, scopeSelector, hostSelector);
                    }
                    else {
                        return shallowPart;
                    }
                };
                return [applyScope(shallowPart), ...otherParts].join(' ');
            })
                .join(', ');
        }
        _selectorNeedsScoping(selector, scopeSelector) {
            const re = this._makeScopeMatcher(scopeSelector);
            return !re.test(selector);
        }
        _makeScopeMatcher(scopeSelector) {
            const lre = /\[/g;
            const rre = /\]/g;
            scopeSelector = scopeSelector.replace(lre, '\\[').replace(rre, '\\]');
            return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');
        }
        _applySelectorScope(selector, scopeSelector, hostSelector) {
            // Difference from webcomponents.js: scopeSelector could not be an array
            return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);
        }
        // scope via name and [is=name]
        _applySimpleSelectorScope(selector, scopeSelector, hostSelector) {
            // In Android browser, the lastIndex is not reset when the regex is used in String.replace()
            _polyfillHostRe.lastIndex = 0;
            if (_polyfillHostRe.test(selector)) {
                const replaceBy = this.strictStyling ? `[${hostSelector}]` : scopeSelector;
                return selector
                    .replace(_polyfillHostNoCombinatorRe, (hnc, selector) => {
                    return selector.replace(/([^:]*)(:*)(.*)/, (_, before, colon, after) => {
                        return before + replaceBy + colon + after;
                    });
                })
                    .replace(_polyfillHostRe, replaceBy + ' ');
            }
            return scopeSelector + ' ' + selector;
        }
        // return a selector with [name] suffix on each simple selector
        // e.g. .foo.bar > .zot becomes .foo[name].bar[name] > .zot[name]  /** @internal */
        _applyStrictSelectorScope(selector, scopeSelector, hostSelector) {
            const isRe = /\[is=([^\]]*)\]/g;
            scopeSelector = scopeSelector.replace(isRe, (_, ...parts) => parts[0]);
            const attrName = '[' + scopeSelector + ']';
            const _scopeSelectorPart = (p) => {
                let scopedP = p.trim();
                if (!scopedP) {
                    return '';
                }
                if (p.indexOf(_polyfillHostNoCombinator) > -1) {
                    scopedP = this._applySimpleSelectorScope(p, scopeSelector, hostSelector);
                }
                else {
                    // remove :host since it should be unnecessary
                    const t = p.replace(_polyfillHostRe, '');
                    if (t.length > 0) {
                        const matches = t.match(/([^:]*)(:*)(.*)/);
                        if (matches) {
                            scopedP = matches[1] + attrName + matches[2] + matches[3];
                        }
                    }
                }
                return scopedP;
            };
            const safeContent = new SafeSelector(selector);
            selector = safeContent.content();
            let scopedSelector = '';
            let startIndex = 0;
            let res;
            const sep = /( |>|\+|~(?!=))\s*/g;
            // If a selector appears before :host it should not be shimmed as it
            // matches on ancestor elements and not on elements in the host's shadow
            // `:host-context(div)` is transformed to
            // `-shadowcsshost-no-combinatordiv, div -shadowcsshost-no-combinator`
            // the `div` is not part of the component in the 2nd selectors and should not be scoped.
            // Historically `component-tag:host` was matching the component so we also want to preserve
            // this behavior to avoid breaking legacy apps (it should not match).
            // The behavior should be:
            // - `tag:host` -> `tag[h]` (this is to avoid breaking legacy apps, should not match anything)
            // - `tag :host` -> `tag [h]` (`tag` is not scoped because it's considered part of a
            //   `:host-context(tag)`)
            const hasHost = selector.indexOf(_polyfillHostNoCombinator) > -1;
            // Only scope parts after the first `-shadowcsshost-no-combinator` when it is present
            let shouldScope = !hasHost;
            while ((res = sep.exec(selector)) !== null) {
                const separator = res[1];
                const part = selector.slice(startIndex, res.index).trim();
                shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;
                const scopedPart = shouldScope ? _scopeSelectorPart(part) : part;
                scopedSelector += `${scopedPart} ${separator} `;
                startIndex = sep.lastIndex;
            }
            const part = selector.substring(startIndex);
            shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;
            scopedSelector += shouldScope ? _scopeSelectorPart(part) : part;
            // replace the placeholders with their original values
            return safeContent.restore(scopedSelector);
        }
        _insertPolyfillHostInCssText(selector) {
            return selector.replace(_colonHostContextRe, _polyfillHostContext)
                .replace(_colonHostRe, _polyfillHost);
        }
    }
    class SafeSelector {
        constructor(selector) {
            this.placeholders = [];
            this.index = 0;
            // Replaces attribute selectors with placeholders.
            // The WS in [attr="va lue"] would otherwise be interpreted as a selector separator.
            selector = selector.replace(/(\[[^\]]*\])/g, (_, keep) => {
                const replaceBy = `__ph-${this.index}__`;
                this.placeholders.push(keep);
                this.index++;
                return replaceBy;
            });
            // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.
            // WS and "+" would otherwise be interpreted as selector separators.
            this._content = selector.replace(/(:nth-[-\w]+)(\([^)]+\))/g, (_, pseudo, exp) => {
                const replaceBy = `__ph-${this.index}__`;
                this.placeholders.push(exp);
                this.index++;
                return pseudo + replaceBy;
            });
        }
        restore(content) {
            return content.replace(/__ph-(\d+)__/g, (ph, index) => this.placeholders[+index]);
        }
        content() {
            return this._content;
        }
    }
    const _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\s]*?(['"])(.*?)\1[;\s]*}([^{]*?){/gim;
    const _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim;
    const _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim;
    const _polyfillHost = '-shadowcsshost';
    // note: :host-context pre-processed to -shadowcsshostcontext.
    const _polyfillHostContext = '-shadowcsscontext';
    const _parenSuffix = ')(?:\\((' +
        '(?:\\([^)(]*\\)|[^)(]*)+?' +
        ')\\))?([^,{]*)';
    const _cssColonHostRe = new RegExp('(' + _polyfillHost + _parenSuffix, 'gim');
    const _cssColonHostContextRe = new RegExp('(' + _polyfillHostContext + _parenSuffix, 'gim');
    const _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';
    const _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\s]*)/;
    const _shadowDOMSelectorsRe = [
        /::shadow/g,
        /::content/g,
        // Deprecated selectors
        /\/shadow-deep\//g,
        /\/shadow\//g,
    ];
    // The deep combinator is deprecated in the CSS spec
    // Support for `>>>`, `deep`, `::ng-deep` is then also deprecated and will be removed in the future.
    // see https://github.com/angular/angular/pull/17677
    const _shadowDeepSelectors = /(?:>>>)|(?:\/deep\/)|(?:::ng-deep)/g;
    const _selectorReSuffix = '([>\\s~+\[.,{:][\\s\\S]*)?$';
    const _polyfillHostRe = /-shadowcsshost/gim;
    const _colonHostRe = /:host/gim;
    const _colonHostContextRe = /:host-context/gim;
    const _commentRe = /\/\*\s*[\s\S]*?\*\//g;
    function stripComments(input) {
        return input.replace(_commentRe, '');
    }
    const _commentWithHashRe = /\/\*\s*#\s*source(Mapping)?URL=[\s\S]+?\*\//g;
    function extractCommentsWithHash(input) {
        return input.match(_commentWithHashRe) || [];
    }
    const _ruleRe = /(\s*)([^;\{\}]+?)(\s*)((?:{%BLOCK%}?\s*;?)|(?:\s*;))/g;
    const _curlyRe = /([{}])/g;
    const OPEN_CURLY = '{';
    const CLOSE_CURLY = '}';
    const BLOCK_PLACEHOLDER = '%BLOCK%';
    class CssRule {
        constructor(selector, content) {
            this.selector = selector;
            this.content = content;
        }
    }
    function processRules(input, ruleCallback) {
        const inputWithEscapedBlocks = escapeBlocks(input);
        let nextBlockIndex = 0;
        return inputWithEscapedBlocks.escapedString.replace(_ruleRe, function (...m) {
            const selector = m[2];
            let content = '';
            let suffix = m[4];
            let contentPrefix = '';
            if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {
                content = inputWithEscapedBlocks.blocks[nextBlockIndex++];
                suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);
                contentPrefix = '{';
            }
            const rule = ruleCallback(new CssRule(selector, content));
            return `${m[1]}${rule.selector}${m[3]}${contentPrefix}${rule.content}${suffix}`;
        });
    }
    class StringWithEscapedBlocks {
        constructor(escapedString, blocks) {
            this.escapedString = escapedString;
            this.blocks = blocks;
        }
    }
    function escapeBlocks(input) {
        const inputParts = input.split(_curlyRe);
        const resultParts = [];
        const escapedBlocks = [];
        let bracketCount = 0;
        let currentBlockParts = [];
        for (let partIndex = 0; partIndex < inputParts.length; partIndex++) {
            const part = inputParts[partIndex];
            if (part == CLOSE_CURLY) {
                bracketCount--;
            }
            if (bracketCount > 0) {
                currentBlockParts.push(part);
            }
            else {
                if (currentBlockParts.length > 0) {
                    escapedBlocks.push(currentBlockParts.join(''));
                    resultParts.push(BLOCK_PLACEHOLDER);
                    currentBlockParts = [];
                }
                resultParts.push(part);
            }
            if (part == OPEN_CURLY) {
                bracketCount++;
            }
        }
        if (currentBlockParts.length > 0) {
            escapedBlocks.push(currentBlockParts.join(''));
            resultParts.push(BLOCK_PLACEHOLDER);
        }
        return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const COMPONENT_VARIABLE = '%COMP%';
    const HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;
    const CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class NodeWithI18n {
        constructor(sourceSpan, i18n) {
            this.sourceSpan = sourceSpan;
            this.i18n = i18n;
        }
    }
    class Text$2 extends NodeWithI18n {
        constructor(value, sourceSpan, i18n) {
            super(sourceSpan, i18n);
            this.value = value;
        }
        visit(visitor, context) {
            return visitor.visitText(this, context);
        }
    }
    class Expansion extends NodeWithI18n {
        constructor(switchValue, type, cases, sourceSpan, switchValueSourceSpan, i18n) {
            super(sourceSpan, i18n);
            this.switchValue = switchValue;
            this.type = type;
            this.cases = cases;
            this.switchValueSourceSpan = switchValueSourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitExpansion(this, context);
        }
    }
    class ExpansionCase {
        constructor(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {
            this.value = value;
            this.expression = expression;
            this.sourceSpan = sourceSpan;
            this.valueSourceSpan = valueSourceSpan;
            this.expSourceSpan = expSourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitExpansionCase(this, context);
        }
    }
    class Attribute extends NodeWithI18n {
        constructor(name, value, sourceSpan, valueSpan, i18n) {
            super(sourceSpan, i18n);
            this.name = name;
            this.value = value;
            this.valueSpan = valueSpan;
        }
        visit(visitor, context) {
            return visitor.visitAttribute(this, context);
        }
    }
    class Element$1 extends NodeWithI18n {
        constructor(name, attrs, children, sourceSpan, startSourceSpan = null, endSourceSpan = null, i18n) {
            super(sourceSpan, i18n);
            this.name = name;
            this.attrs = attrs;
            this.children = children;
            this.startSourceSpan = startSourceSpan;
            this.endSourceSpan = endSourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitElement(this, context);
        }
    }
    class Comment {
        constructor(value, sourceSpan) {
            this.value = value;
            this.sourceSpan = sourceSpan;
        }
        visit(visitor, context) {
            return visitor.visitComment(this, context);
        }
    }
    function visitAll$1(visitor, nodes, context = null) {
        const result = [];
        const visit = visitor.visit ?
            (ast) => visitor.visit(ast, context) || ast.visit(visitor, context) :
            (ast) => ast.visit(visitor, context);
        nodes.forEach(ast => {
            const astResult = visit(ast);
            if (astResult) {
                result.push(astResult);
            }
        });
        return result;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var TokenType;
    (function (TokenType) {
        TokenType[TokenType["TAG_OPEN_START"] = 0] = "TAG_OPEN_START";
        TokenType[TokenType["TAG_OPEN_END"] = 1] = "TAG_OPEN_END";
        TokenType[TokenType["TAG_OPEN_END_VOID"] = 2] = "TAG_OPEN_END_VOID";
        TokenType[TokenType["TAG_CLOSE"] = 3] = "TAG_CLOSE";
        TokenType[TokenType["TEXT"] = 4] = "TEXT";
        TokenType[TokenType["ESCAPABLE_RAW_TEXT"] = 5] = "ESCAPABLE_RAW_TEXT";
        TokenType[TokenType["RAW_TEXT"] = 6] = "RAW_TEXT";
        TokenType[TokenType["COMMENT_START"] = 7] = "COMMENT_START";
        TokenType[TokenType["COMMENT_END"] = 8] = "COMMENT_END";
        TokenType[TokenType["CDATA_START"] = 9] = "CDATA_START";
        TokenType[TokenType["CDATA_END"] = 10] = "CDATA_END";
        TokenType[TokenType["ATTR_NAME"] = 11] = "ATTR_NAME";
        TokenType[TokenType["ATTR_QUOTE"] = 12] = "ATTR_QUOTE";
        TokenType[TokenType["ATTR_VALUE"] = 13] = "ATTR_VALUE";
        TokenType[TokenType["DOC_TYPE"] = 14] = "DOC_TYPE";
        TokenType[TokenType["EXPANSION_FORM_START"] = 15] = "EXPANSION_FORM_START";
        TokenType[TokenType["EXPANSION_CASE_VALUE"] = 16] = "EXPANSION_CASE_VALUE";
        TokenType[TokenType["EXPANSION_CASE_EXP_START"] = 17] = "EXPANSION_CASE_EXP_START";
        TokenType[TokenType["EXPANSION_CASE_EXP_END"] = 18] = "EXPANSION_CASE_EXP_END";
        TokenType[TokenType["EXPANSION_FORM_END"] = 19] = "EXPANSION_FORM_END";
        TokenType[TokenType["EOF"] = 20] = "EOF";
    })(TokenType || (TokenType = {}));
    class Token {
        constructor(type, parts, sourceSpan) {
            this.type = type;
            this.parts = parts;
            this.sourceSpan = sourceSpan;
        }
    }
    class TokenError extends ParseError {
        constructor(errorMsg, tokenType, span) {
            super(span, errorMsg);
            this.tokenType = tokenType;
        }
    }
    class TokenizeResult {
        constructor(tokens, errors, nonNormalizedIcuExpressions) {
            this.tokens = tokens;
            this.errors = errors;
            this.nonNormalizedIcuExpressions = nonNormalizedIcuExpressions;
        }
    }
    function tokenize(source, url, getTagDefinition, options = {}) {
        const tokenizer = new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, options);
        tokenizer.tokenize();
        return new TokenizeResult(mergeTextTokens(tokenizer.tokens), tokenizer.errors, tokenizer.nonNormalizedIcuExpressions);
    }
    const _CR_OR_CRLF_REGEXP = /\r\n?/g;
    function _unexpectedCharacterErrorMsg(charCode) {
        const char = charCode === $EOF ? 'EOF' : String.fromCharCode(charCode);
        return `Unexpected character "${char}"`;
    }
    function _unknownEntityErrorMsg(entitySrc) {
        return `Unknown entity "${entitySrc}" - use the "&#<decimal>;" or  "&#x<hex>;" syntax`;
    }
    function _unparsableEntityErrorMsg(type, entityStr) {
        return `Unable to parse entity "${entityStr}" - ${type} character reference entities must end with ";"`;
    }
    var CharacterReferenceType;
    (function (CharacterReferenceType) {
        CharacterReferenceType["HEX"] = "hexadecimal";
        CharacterReferenceType["DEC"] = "decimal";
    })(CharacterReferenceType || (CharacterReferenceType = {}));
    class _ControlFlowError {
        constructor(error) {
            this.error = error;
        }
    }
    // See http://www.w3.org/TR/html51/syntax.html#writing
    class _Tokenizer {
        /**
         * @param _file The html source file being tokenized.
         * @param _getTagDefinition A function that will retrieve a tag definition for a given tag name.
         * @param options Configuration of the tokenization.
         */
        constructor(_file, _getTagDefinition, options) {
            this._getTagDefinition = _getTagDefinition;
            this._currentTokenStart = null;
            this._currentTokenType = null;
            this._expansionCaseStack = [];
            this._inInterpolation = false;
            this.tokens = [];
            this.errors = [];
            this.nonNormalizedIcuExpressions = [];
            this._tokenizeIcu = options.tokenizeExpansionForms || false;
            this._interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;
            this._leadingTriviaCodePoints =
                options.leadingTriviaChars && options.leadingTriviaChars.map(c => c.codePointAt(0) || 0);
            const range = options.range || { endPos: _file.content.length, startPos: 0, startLine: 0, startCol: 0 };
            this._cursor = options.escapedString ? new EscapedCharacterCursor(_file, range) :
                new PlainCharacterCursor(_file, range);
            this._preserveLineEndings = options.preserveLineEndings || false;
            this._escapedString = options.escapedString || false;
            this._i18nNormalizeLineEndingsInICUs = options.i18nNormalizeLineEndingsInICUs || false;
            try {
                this._cursor.init();
            }
            catch (e) {
                this.handleError(e);
            }
        }
        _processCarriageReturns(content) {
            if (this._preserveLineEndings) {
                return content;
            }
            // http://www.w3.org/TR/html5/syntax.html#preprocessing-the-input-stream
            // In order to keep the original position in the source, we can not
            // pre-process it.
            // Instead CRs are processed right before instantiating the tokens.
            return content.replace(_CR_OR_CRLF_REGEXP, '\n');
        }
        tokenize() {
            while (this._cursor.peek() !== $EOF) {
                const start = this._cursor.clone();
                try {
                    if (this._attemptCharCode($LT)) {
                        if (this._attemptCharCode($BANG)) {
                            if (this._attemptCharCode($LBRACKET)) {
                                this._consumeCdata(start);
                            }
                            else if (this._attemptCharCode($MINUS)) {
                                this._consumeComment(start);
                            }
                            else {
                                this._consumeDocType(start);
                            }
                        }
                        else if (this._attemptCharCode($SLASH)) {
                            this._consumeTagClose(start);
                        }
                        else {
                            this._consumeTagOpen(start);
                        }
                    }
                    else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {
                        this._consumeText();
                    }
                }
                catch (e) {
                    this.handleError(e);
                }
            }
            this._beginToken(TokenType.EOF);
            this._endToken([]);
        }
        /**
         * @returns whether an ICU token has been created
         * @internal
         */
        _tokenizeExpansionForm() {
            if (this.isExpansionFormStart()) {
                this._consumeExpansionFormStart();
                return true;
            }
            if (isExpansionCaseStart(this._cursor.peek()) && this._isInExpansionForm()) {
                this._consumeExpansionCaseStart();
                return true;
            }
            if (this._cursor.peek() === $RBRACE) {
                if (this._isInExpansionCase()) {
                    this._consumeExpansionCaseEnd();
                    return true;
                }
                if (this._isInExpansionForm()) {
                    this._consumeExpansionFormEnd();
                    return true;
                }
            }
            return false;
        }
        _beginToken(type, start = this._cursor.clone()) {
            this._currentTokenStart = start;
            this._currentTokenType = type;
        }
        _endToken(parts, end) {
            if (this._currentTokenStart === null) {
                throw new TokenError('Programming error - attempted to end a token when there was no start to the token', this._currentTokenType, this._cursor.getSpan(end));
            }
            if (this._currentTokenType === null) {
                throw new TokenError('Programming error - attempted to end a token which has no token type', null, this._cursor.getSpan(this._currentTokenStart));
            }
            const token = new Token(this._currentTokenType, parts, this._cursor.getSpan(this._currentTokenStart, this._leadingTriviaCodePoints));
            this.tokens.push(token);
            this._currentTokenStart = null;
            this._currentTokenType = null;
            return token;
        }
        _createError(msg, span) {
            if (this._isInExpansionForm()) {
                msg += ` (Do you have an unescaped "{" in your template? Use "{{ '{' }}") to escape it.)`;
            }
            const error = new TokenError(msg, this._currentTokenType, span);
            this._currentTokenStart = null;
            this._currentTokenType = null;
            return new _ControlFlowError(error);
        }
        handleError(e) {
            if (e instanceof CursorError) {
                e = this._createError(e.msg, this._cursor.getSpan(e.cursor));
            }
            if (e instanceof _ControlFlowError) {
                this.errors.push(e.error);
            }
            else {
                throw e;
            }
        }
        _attemptCharCode(charCode) {
            if (this._cursor.peek() === charCode) {
                this._cursor.advance();
                return true;
            }
            return false;
        }
        _attemptCharCodeCaseInsensitive(charCode) {
            if (compareCharCodeCaseInsensitive(this._cursor.peek(), charCode)) {
                this._cursor.advance();
                return true;
            }
            return false;
        }
        _requireCharCode(charCode) {
            const location = this._cursor.clone();
            if (!this._attemptCharCode(charCode)) {
                throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));
            }
        }
        _attemptStr(chars) {
            const len = chars.length;
            if (this._cursor.charsLeft() < len) {
                return false;
            }
            const initialPosition = this._cursor.clone();
            for (let i = 0; i < len; i++) {
                if (!this._attemptCharCode(chars.charCodeAt(i))) {
                    // If attempting to parse the string fails, we want to reset the parser
                    // to where it was before the attempt
                    this._cursor = initialPosition;
                    return false;
                }
            }
            return true;
        }
        _attemptStrCaseInsensitive(chars) {
            for (let i = 0; i < chars.length; i++) {
                if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {
                    return false;
                }
            }
            return true;
        }
        _requireStr(chars) {
            const location = this._cursor.clone();
            if (!this._attemptStr(chars)) {
                throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));
            }
        }
        _attemptCharCodeUntilFn(predicate) {
            while (!predicate(this._cursor.peek())) {
                this._cursor.advance();
            }
        }
        _requireCharCodeUntilFn(predicate, len) {
            const start = this._cursor.clone();
            this._attemptCharCodeUntilFn(predicate);
            if (this._cursor.diff(start) < len) {
                throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));
            }
        }
        _attemptUntilChar(char) {
            while (this._cursor.peek() !== char) {
                this._cursor.advance();
            }
        }
        _readChar(decodeEntities) {
            if (decodeEntities && this._cursor.peek() === $AMPERSAND) {
                return this._decodeEntity();
            }
            else {
                // Don't rely upon reading directly from `_input` as the actual char value
                // may have been generated from an escape sequence.
                const char = String.fromCodePoint(this._cursor.peek());
                this._cursor.advance();
                return char;
            }
        }
        _decodeEntity() {
            const start = this._cursor.clone();
            this._cursor.advance();
            if (this._attemptCharCode($HASH)) {
                const isHex = this._attemptCharCode($x) || this._attemptCharCode($X);
                const codeStart = this._cursor.clone();
                this._attemptCharCodeUntilFn(isDigitEntityEnd);
                if (this._cursor.peek() != $SEMICOLON) {
                    // Advance cursor to include the peeked character in the string provided to the error
                    // message.
                    this._cursor.advance();
                    const entityType = isHex ? CharacterReferenceType.HEX : CharacterReferenceType.DEC;
                    throw this._createError(_unparsableEntityErrorMsg(entityType, this._cursor.getChars(start)), this._cursor.getSpan());
                }
                const strNum = this._cursor.getChars(codeStart);
                this._cursor.advance();
                try {
                    const charCode = parseInt(strNum, isHex ? 16 : 10);
                    return String.fromCharCode(charCode);
                }
                catch (_a) {
                    throw this._createError(_unknownEntityErrorMsg(this._cursor.getChars(start)), this._cursor.getSpan());
                }
            }
            else {
                const nameStart = this._cursor.clone();
                this._attemptCharCodeUntilFn(isNamedEntityEnd);
                if (this._cursor.peek() != $SEMICOLON) {
                    this._cursor = nameStart;
                    return '&';
                }
                const name = this._cursor.getChars(nameStart);
                this._cursor.advance();
                const char = NAMED_ENTITIES[name];
                if (!char) {
                    throw this._createError(_unknownEntityErrorMsg(name), this._cursor.getSpan(start));
                }
                return char;
            }
        }
        _consumeRawText(decodeEntities, endMarkerPredicate) {
            this._beginToken(decodeEntities ? TokenType.ESCAPABLE_RAW_TEXT : TokenType.RAW_TEXT);
            const parts = [];
            while (true) {
                const tagCloseStart = this._cursor.clone();
                const foundEndMarker = endMarkerPredicate();
                this._cursor = tagCloseStart;
                if (foundEndMarker) {
                    break;
                }
                parts.push(this._readChar(decodeEntities));
            }
            return this._endToken([this._processCarriageReturns(parts.join(''))]);
        }
        _consumeComment(start) {
            this._beginToken(TokenType.COMMENT_START, start);
            this._requireCharCode($MINUS);
            this._endToken([]);
            this._consumeRawText(false, () => this._attemptStr('-->'));
            this._beginToken(TokenType.COMMENT_END);
            this._requireStr('-->');
            this._endToken([]);
        }
        _consumeCdata(start) {
            this._beginToken(TokenType.CDATA_START, start);
            this._requireStr('CDATA[');
            this._endToken([]);
            this._consumeRawText(false, () => this._attemptStr(']]>'));
            this._beginToken(TokenType.CDATA_END);
            this._requireStr(']]>');
            this._endToken([]);
        }
        _consumeDocType(start) {
            this._beginToken(TokenType.DOC_TYPE, start);
            const contentStart = this._cursor.clone();
            this._attemptUntilChar($GT);
            const content = this._cursor.getChars(contentStart);
            this._cursor.advance();
            this._endToken([content]);
        }
        _consumePrefixAndName() {
            const nameOrPrefixStart = this._cursor.clone();
            let prefix = '';
            while (this._cursor.peek() !== $COLON && !isPrefixEnd(this._cursor.peek())) {
                this._cursor.advance();
            }
            let nameStart;
            if (this._cursor.peek() === $COLON) {
                prefix = this._cursor.getChars(nameOrPrefixStart);
                this._cursor.advance();
                nameStart = this._cursor.clone();
            }
            else {
                nameStart = nameOrPrefixStart;
            }
            this._requireCharCodeUntilFn(isNameEnd, prefix === '' ? 0 : 1);
            const name = this._cursor.getChars(nameStart);
            return [prefix, name];
        }
        _consumeTagOpen(start) {
            let tagName;
            let prefix;
            let openTagToken;
            let tokensBeforeTagOpen = this.tokens.length;
            const innerStart = this._cursor.clone();
            try {
                if (!isAsciiLetter(this._cursor.peek())) {
                    throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));
                }
                openTagToken = this._consumeTagOpenStart(start);
                prefix = openTagToken.parts[0];
                tagName = openTagToken.parts[1];
                this._attemptCharCodeUntilFn(isNotWhitespace);
                while (this._cursor.peek() !== $SLASH && this._cursor.peek() !== $GT) {
                    this._consumeAttributeName();
                    this._attemptCharCodeUntilFn(isNotWhitespace);
                    if (this._attemptCharCode($EQ)) {
                        this._attemptCharCodeUntilFn(isNotWhitespace);
                        this._consumeAttributeValue();
                    }
                    this._attemptCharCodeUntilFn(isNotWhitespace);
                }
                this._consumeTagOpenEnd();
            }
            catch (e) {
                if (e instanceof _ControlFlowError) {
                    // When the start tag is invalid (including invalid "attributes"), assume we want a "<"
                    this._cursor = innerStart;
                    if (openTagToken) {
                        this.tokens.length = tokensBeforeTagOpen;
                    }
                    // Back to back text tokens are merged at the end
                    this._beginToken(TokenType.TEXT, start);
                    this._endToken(['<']);
                    return;
                }
                throw e;
            }
            const contentTokenType = this._getTagDefinition(tagName).contentType;
            if (contentTokenType === TagContentType.RAW_TEXT) {
                this._consumeRawTextWithTagClose(prefix, tagName, false);
            }
            else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {
                this._consumeRawTextWithTagClose(prefix, tagName, true);
            }
        }
        _consumeRawTextWithTagClose(prefix, tagName, decodeEntities) {
            const textToken = this._consumeRawText(decodeEntities, () => {
                if (!this._attemptCharCode($LT))
                    return false;
                if (!this._attemptCharCode($SLASH))
                    return false;
                this._attemptCharCodeUntilFn(isNotWhitespace);
                if (!this._attemptStrCaseInsensitive(tagName))
                    return false;
                this._attemptCharCodeUntilFn(isNotWhitespace);
                return this._attemptCharCode($GT);
            });
            this._beginToken(TokenType.TAG_CLOSE);
            this._requireCharCodeUntilFn(code => code === $GT, 3);
            this._cursor.advance(); // Consume the `>`
            this._endToken([prefix, tagName]);
        }
        _consumeTagOpenStart(start) {
            this._beginToken(TokenType.TAG_OPEN_START, start);
            const parts = this._consumePrefixAndName();
            return this._endToken(parts);
        }
        _consumeAttributeName() {
            const attrNameStart = this._cursor.peek();
            if (attrNameStart === $SQ || attrNameStart === $DQ) {
                throw this._createError(_unexpectedCharacterErrorMsg(attrNameStart), this._cursor.getSpan());
            }
            this._beginToken(TokenType.ATTR_NAME);
            const prefixAndName = this._consumePrefixAndName();
            this._endToken(prefixAndName);
        }
        _consumeAttributeValue() {
            let value;
            if (this._cursor.peek() === $SQ || this._cursor.peek() === $DQ) {
                this._beginToken(TokenType.ATTR_QUOTE);
                const quoteChar = this._cursor.peek();
                this._cursor.advance();
                this._endToken([String.fromCodePoint(quoteChar)]);
                this._beginToken(TokenType.ATTR_VALUE);
                const parts = [];
                while (this._cursor.peek() !== quoteChar) {
                    parts.push(this._readChar(true));
                }
                value = parts.join('');
                this._endToken([this._processCarriageReturns(value)]);
                this._beginToken(TokenType.ATTR_QUOTE);
                this._cursor.advance();
                this._endToken([String.fromCodePoint(quoteChar)]);
            }
            else {
                this._beginToken(TokenType.ATTR_VALUE);
                const valueStart = this._cursor.clone();
                this._requireCharCodeUntilFn(isNameEnd, 1);
                value = this._cursor.getChars(valueStart);
                this._endToken([this._processCarriageReturns(value)]);
            }
        }
        _consumeTagOpenEnd() {
            const tokenType = this._attemptCharCode($SLASH) ? TokenType.TAG_OPEN_END_VOID : TokenType.TAG_OPEN_END;
            this._beginToken(tokenType);
            this._requireCharCode($GT);
            this._endToken([]);
        }
        _consumeTagClose(start) {
            this._beginToken(TokenType.TAG_CLOSE, start);
            this._attemptCharCodeUntilFn(isNotWhitespace);
            const prefixAndName = this._consumePrefixAndName();
            this._attemptCharCodeUntilFn(isNotWhitespace);
            this._requireCharCode($GT);
            this._endToken(prefixAndName);
        }
        _consumeExpansionFormStart() {
            this._beginToken(TokenType.EXPANSION_FORM_START);
            this._requireCharCode($LBRACE);
            this._endToken([]);
            this._expansionCaseStack.push(TokenType.EXPANSION_FORM_START);
            this._beginToken(TokenType.RAW_TEXT);
            const condition = this._readUntil($COMMA);
            const normalizedCondition = this._processCarriageReturns(condition);
            if (this._escapedString || this._i18nNormalizeLineEndingsInICUs) {
                // Either the template is inline or,
                // we explicitly want to normalize line endings for this text.
                this._endToken([normalizedCondition]);
            }
            else {
                // The expression is in an external template and, for backward compatibility,
                // we are not normalizing line endings.
                const conditionToken = this._endToken([condition]);
                if (normalizedCondition !== condition) {
                    this.nonNormalizedIcuExpressions.push(conditionToken);
                }
            }
            this._requireCharCode($COMMA);
            this._attemptCharCodeUntilFn(isNotWhitespace);
            this._beginToken(TokenType.RAW_TEXT);
            const type = this._readUntil($COMMA);
            this._endToken([type]);
            this._requireCharCode($COMMA);
            this._attemptCharCodeUntilFn(isNotWhitespace);
        }
        _consumeExpansionCaseStart() {
            this._beginToken(TokenType.EXPANSION_CASE_VALUE);
            const value = this._readUntil($LBRACE).trim();
            this._endToken([value]);
            this._attemptCharCodeUntilFn(isNotWhitespace);
            this._beginToken(TokenType.EXPANSION_CASE_EXP_START);
            this._requireCharCode($LBRACE);
            this._endToken([]);
            this._attemptCharCodeUntilFn(isNotWhitespace);
            this._expansionCaseStack.push(TokenType.EXPANSION_CASE_EXP_START);
        }
        _consumeExpansionCaseEnd() {
            this._beginToken(TokenType.EXPANSION_CASE_EXP_END);
            this._requireCharCode($RBRACE);
            this._endToken([]);
            this._attemptCharCodeUntilFn(isNotWhitespace);
            this._expansionCaseStack.pop();
        }
        _consumeExpansionFormEnd() {
            this._beginToken(TokenType.EXPANSION_FORM_END);
            this._requireCharCode($RBRACE);
            this._endToken([]);
            this._expansionCaseStack.pop();
        }
        _consumeText() {
            const start = this._cursor.clone();
            this._beginToken(TokenType.TEXT, start);
            const parts = [];
            do {
                if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {
                    parts.push(this._interpolationConfig.start);
                    this._inInterpolation = true;
                }
                else if (this._interpolationConfig && this._inInterpolation &&
                    this._attemptStr(this._interpolationConfig.end)) {
                    parts.push(this._interpolationConfig.end);
                    this._inInterpolation = false;
                }
                else {
                    parts.push(this._readChar(true));
                }
            } while (!this._isTextEnd());
            this._endToken([this._processCarriageReturns(parts.join(''))]);
        }
        _isTextEnd() {
            if (this._cursor.peek() === $LT || this._cursor.peek() === $EOF) {
                return true;
            }
            if (this._tokenizeIcu && !this._inInterpolation) {
                if (this.isExpansionFormStart()) {
                    // start of an expansion form
                    return true;
                }
                if (this._cursor.peek() === $RBRACE && this._isInExpansionCase()) {
                    // end of and expansion case
                    return true;
                }
            }
            return false;
        }
        _readUntil(char) {
            const start = this._cursor.clone();
            this._attemptUntilChar(char);
            return this._cursor.getChars(start);
        }
        _isInExpansionCase() {
            return this._expansionCaseStack.length > 0 &&
                this._expansionCaseStack[this._expansionCaseStack.length - 1] ===
                    TokenType.EXPANSION_CASE_EXP_START;
        }
        _isInExpansionForm() {
            return this._expansionCaseStack.length > 0 &&
                this._expansionCaseStack[this._expansionCaseStack.length - 1] ===
                    TokenType.EXPANSION_FORM_START;
        }
        isExpansionFormStart() {
            if (this._cursor.peek() !== $LBRACE) {
                return false;
            }
            if (this._interpolationConfig) {
                const start = this._cursor.clone();
                const isInterpolation = this._attemptStr(this._interpolationConfig.start);
                this._cursor = start;
                return !isInterpolation;
            }
            return true;
        }
    }
    function isNotWhitespace(code) {
        return !isWhitespace(code) || code === $EOF;
    }
    function isNameEnd(code) {
        return isWhitespace(code) || code === $GT || code === $SLASH ||
            code === $SQ || code === $DQ || code === $EQ;
    }
    function isPrefixEnd(code) {
        return (code < $a || $z < code) && (code < $A || $Z < code) &&
            (code < $0 || code > $9);
    }
    function isDigitEntityEnd(code) {
        return code == $SEMICOLON || code == $EOF || !isAsciiHexDigit(code);
    }
    function isNamedEntityEnd(code) {
        return code == $SEMICOLON || code == $EOF || !isAsciiLetter(code);
    }
    function isExpansionCaseStart(peek) {
        return peek !== $RBRACE;
    }
    function compareCharCodeCaseInsensitive(code1, code2) {
        return toUpperCaseCharCode(code1) == toUpperCaseCharCode(code2);
    }
    function toUpperCaseCharCode(code) {
        return code >= $a && code <= $z ? code - $a + $A : code;
    }
    function mergeTextTokens(srcTokens) {
        const dstTokens = [];
        let lastDstToken = undefined;
        for (let i = 0; i < srcTokens.length; i++) {
            const token = srcTokens[i];
            if (lastDstToken && lastDstToken.type == TokenType.TEXT && token.type == TokenType.TEXT) {
                lastDstToken.parts[0] += token.parts[0];
                lastDstToken.sourceSpan.end = token.sourceSpan.end;
            }
            else {
                lastDstToken = token;
                dstTokens.push(lastDstToken);
            }
        }
        return dstTokens;
    }
    class PlainCharacterCursor {
        constructor(fileOrCursor, range) {
            if (fileOrCursor instanceof PlainCharacterCursor) {
                this.file = fileOrCursor.file;
                this.input = fileOrCursor.input;
                this.end = fileOrCursor.end;
                const state = fileOrCursor.state;
                // Note: avoid using `{...fileOrCursor.state}` here as that has a severe performance penalty.
                // In ES5 bundles the object spread operator is translated into the `__assign` helper, which
                // is not optimized by VMs as efficiently as a raw object literal. Since this constructor is
                // called in tight loops, this difference matters.
                this.state = {
                    peek: state.peek,
                    offset: state.offset,
                    line: state.line,
                    column: state.column,
                };
            }
            else {
                if (!range) {
                    throw new Error('Programming error: the range argument must be provided with a file argument.');
                }
                this.file = fileOrCursor;
                this.input = fileOrCursor.content;
                this.end = range.endPos;
                this.state = {
                    peek: -1,
                    offset: range.startPos,
                    line: range.startLine,
                    column: range.startCol,
                };
            }
        }
        clone() {
            return new PlainCharacterCursor(this);
        }
        peek() {
            return this.state.peek;
        }
        charsLeft() {
            return this.end - this.state.offset;
        }
        diff(other) {
            return this.state.offset - other.state.offset;
        }
        advance() {
            this.advanceState(this.state);
        }
        init() {
            this.updatePeek(this.state);
        }
        getSpan(start, leadingTriviaCodePoints) {
            start = start || this;
            let cloned = false;
            if (leadingTriviaCodePoints) {
                while (this.diff(start) > 0 && leadingTriviaCodePoints.indexOf(start.peek()) !== -1) {
                    if (!cloned) {
                        start = start.clone();
                        cloned = true;
                    }
                    start.advance();
                }
            }
            return new ParseSourceSpan(new ParseLocation(start.file, start.state.offset, start.state.line, start.state.column), new ParseLocation(this.file, this.state.offset, this.state.line, this.state.column));
        }
        getChars(start) {
            return this.input.substring(start.state.offset, this.state.offset);
        }
        charAt(pos) {
            return this.input.charCodeAt(pos);
        }
        advanceState(state) {
            if (state.offset >= this.end) {
                this.state = state;
                throw new CursorError('Unexpected character "EOF"', this);
            }
            const currentChar = this.charAt(state.offset);
            if (currentChar === $LF) {
                state.line++;
                state.column = 0;
            }
            else if (!isNewLine(currentChar)) {
                state.column++;
            }
            state.offset++;
            this.updatePeek(state);
        }
        updatePeek(state) {
            state.peek = state.offset >= this.end ? $EOF : this.charAt(state.offset);
        }
    }
    class EscapedCharacterCursor extends PlainCharacterCursor {
        constructor(fileOrCursor, range) {
            if (fileOrCursor instanceof EscapedCharacterCursor) {
                super(fileOrCursor);
                this.internalState = Object.assign({}, fileOrCursor.internalState);
            }
            else {
                super(fileOrCursor, range);
                this.internalState = this.state;
            }
        }
        advance() {
            this.state = this.internalState;
            super.advance();
            this.processEscapeSequence();
        }
        init() {
            super.init();
            this.processEscapeSequence();
        }
        clone() {
            return new EscapedCharacterCursor(this);
        }
        getChars(start) {
            const cursor = start.clone();
            let chars = '';
            while (cursor.internalState.offset < this.internalState.offset) {
                chars += String.fromCodePoint(cursor.peek());
                cursor.advance();
            }
            return chars;
        }
        /**
         * Process the escape sequence that starts at the current position in the text.
         *
         * This method is called to ensure that `peek` has the unescaped value of escape sequences.
         */
        processEscapeSequence() {
            const peek = () => this.internalState.peek;
            if (peek() === $BACKSLASH) {
                // We have hit an escape sequence so we need the internal state to become independent
                // of the external state.
                this.internalState = Object.assign({}, this.state);
                // Move past the backslash
                this.advanceState(this.internalState);
                // First check for standard control char sequences
                if (peek() === $n) {
                    this.state.peek = $LF;
                }
                else if (peek() === $r) {
                    this.state.peek = $CR;
                }
                else if (peek() === $v) {
                    this.state.peek = $VTAB;
                }
                else if (peek() === $t) {
                    this.state.peek = $TAB;
                }
                else if (peek() === $b) {
                    this.state.peek = $BSPACE;
                }
                else if (peek() === $f) {
                    this.state.peek = $FF;
                }
                // Now consider more complex sequences
                else if (peek() === $u) {
                    // Unicode code-point sequence
                    this.advanceState(this.internalState); // advance past the `u` char
                    if (peek() === $LBRACE) {
                        // Variable length Unicode, e.g. `\x{123}`
                        this.advanceState(this.internalState); // advance past the `{` char
                        // Advance past the variable number of hex digits until we hit a `}` char
                        const digitStart = this.clone();
                        let length = 0;
                        while (peek() !== $RBRACE) {
                            this.advanceState(this.internalState);
                            length++;
                        }
                        this.state.peek = this.decodeHexDigits(digitStart, length);
                    }
                    else {
                        // Fixed length Unicode, e.g. `\u1234`
                        const digitStart = this.clone();
                        this.advanceState(this.internalState);
                        this.advanceState(this.internalState);
                        this.advanceState(this.internalState);
                        this.state.peek = this.decodeHexDigits(digitStart, 4);
                    }
                }
                else if (peek() === $x) {
                    // Hex char code, e.g. `\x2F`
                    this.advanceState(this.internalState); // advance past the `x` char
                    const digitStart = this.clone();
                    this.advanceState(this.internalState);
                    this.state.peek = this.decodeHexDigits(digitStart, 2);
                }
                else if (isOctalDigit(peek())) {
                    // Octal char code, e.g. `\012`,
                    let octal = '';
                    let length = 0;
                    let previous = this.clone();
                    while (isOctalDigit(peek()) && length < 3) {
                        previous = this.clone();
                        octal += String.fromCodePoint(peek());
                        this.advanceState(this.internalState);
                        length++;
                    }
                    this.state.peek = parseInt(octal, 8);
                    // Backup one char
                    this.internalState = previous.internalState;
                }
                else if (isNewLine(this.internalState.peek)) {
                    // Line continuation `\` followed by a new line
                    this.advanceState(this.internalState); // advance over the newline
                    this.state = this.internalState;
                }
                else {
                    // If none of the `if` blocks were executed then we just have an escaped normal character.
                    // In that case we just, effectively, skip the backslash from the character.
                    this.state.peek = this.internalState.peek;
                }
            }
        }
        decodeHexDigits(start, length) {
            const hex = this.input.substr(start.internalState.offset, length);
            const charCode = parseInt(hex, 16);
            if (!isNaN(charCode)) {
                return charCode;
            }
            else {
                start.state = start.internalState;
                throw new CursorError('Invalid hexadecimal escape sequence', start);
            }
        }
    }
    class CursorError {
        constructor(msg, cursor) {
            this.msg = msg;
            this.cursor = cursor;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class TreeError extends ParseError {
        constructor(elementName, span, msg) {
            super(span, msg);
            this.elementName = elementName;
        }
        static create(elementName, span, msg) {
            return new TreeError(elementName, span, msg);
        }
    }
    class ParseTreeResult {
        constructor(rootNodes, errors) {
            this.rootNodes = rootNodes;
            this.errors = errors;
        }
    }
    class Parser {
        constructor(getTagDefinition) {
            this.getTagDefinition = getTagDefinition;
        }
        parse(source, url, options) {
            const tokenizeResult = tokenize(source, url, this.getTagDefinition, options);
            const parser = new _TreeBuilder(tokenizeResult.tokens, this.getTagDefinition);
            parser.build();
            return new ParseTreeResult(parser.rootNodes, tokenizeResult.errors.concat(parser.errors));
        }
    }
    class _TreeBuilder {
        constructor(tokens, getTagDefinition) {
            this.tokens = tokens;
            this.getTagDefinition = getTagDefinition;
            this._index = -1;
            this._elementStack = [];
            this.rootNodes = [];
            this.errors = [];
            this._advance();
        }
        build() {
            while (this._peek.type !== TokenType.EOF) {
                if (this._peek.type === TokenType.TAG_OPEN_START) {
                    this._consumeStartTag(this._advance());
                }
                else if (this._peek.type === TokenType.TAG_CLOSE) {
                    this._consumeEndTag(this._advance());
                }
                else if (this._peek.type === TokenType.CDATA_START) {
                    this._closeVoidElement();
                    this._consumeCdata(this._advance());
                }
                else if (this._peek.type === TokenType.COMMENT_START) {
                    this._closeVoidElement();
                    this._consumeComment(this._advance());
                }
                else if (this._peek.type === TokenType.TEXT || this._peek.type === TokenType.RAW_TEXT ||
                    this._peek.type === TokenType.ESCAPABLE_RAW_TEXT) {
                    this._closeVoidElement();
                    this._consumeText(this._advance());
                }
                else if (this._peek.type === TokenType.EXPANSION_FORM_START) {
                    this._consumeExpansion(this._advance());
                }
                else {
                    // Skip all other tokens...
                    this._advance();
                }
            }
        }
        _advance() {
            const prev = this._peek;
            if (this._index < this.tokens.length - 1) {
                // Note: there is always an EOF token at the end
                this._index++;
            }
            this._peek = this.tokens[this._index];
            return prev;
        }
        _advanceIf(type) {
            if (this._peek.type === type) {
                return this._advance();
            }
            return null;
        }
        _consumeCdata(_startToken) {
            this._consumeText(this._advance());
            this._advanceIf(TokenType.CDATA_END);
        }
        _consumeComment(token) {
            const text = this._advanceIf(TokenType.RAW_TEXT);
            this._advanceIf(TokenType.COMMENT_END);
            const value = text != null ? text.parts[0].trim() : null;
            this._addToParent(new Comment(value, token.sourceSpan));
        }
        _consumeExpansion(token) {
            const switchValue = this._advance();
            const type = this._advance();
            const cases = [];
            // read =
            while (this._peek.type === TokenType.EXPANSION_CASE_VALUE) {
                const expCase = this._parseExpansionCase();
                if (!expCase)
                    return; // error
                cases.push(expCase);
            }
            // read the final }
            if (this._peek.type !== TokenType.EXPANSION_FORM_END) {
                this.errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '}'.`));
                return;
            }
            const sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end);
            this._addToParent(new Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));
            this._advance();
        }
        _parseExpansionCase() {
            const value = this._advance();
            // read {
            if (this._peek.type !== TokenType.EXPANSION_CASE_EXP_START) {
                this.errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '{'.`));
                return null;
            }
            // read until }
            const start = this._advance();
            const exp = this._collectExpansionExpTokens(start);
            if (!exp)
                return null;
            const end = this._advance();
            exp.push(new Token(TokenType.EOF, [], end.sourceSpan));
            // parse everything in between { and }
            const expansionCaseParser = new _TreeBuilder(exp, this.getTagDefinition);
            expansionCaseParser.build();
            if (expansionCaseParser.errors.length > 0) {
                this.errors = this.errors.concat(expansionCaseParser.errors);
                return null;
            }
            const sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end);
            const expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end);
            return new ExpansionCase(value.parts[0], expansionCaseParser.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);
        }
        _collectExpansionExpTokens(start) {
            const exp = [];
            const expansionFormStack = [TokenType.EXPANSION_CASE_EXP_START];
            while (true) {
                if (this._peek.type === TokenType.EXPANSION_FORM_START ||
                    this._peek.type === TokenType.EXPANSION_CASE_EXP_START) {
                    expansionFormStack.push(this._peek.type);
                }
                if (this._peek.type === TokenType.EXPANSION_CASE_EXP_END) {
                    if (lastOnStack(expansionFormStack, TokenType.EXPANSION_CASE_EXP_START)) {
                        expansionFormStack.pop();
                        if (expansionFormStack.length == 0)
                            return exp;
                    }
                    else {
                        this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));
                        return null;
                    }
                }
                if (this._peek.type === TokenType.EXPANSION_FORM_END) {
                    if (lastOnStack(expansionFormStack, TokenType.EXPANSION_FORM_START)) {
                        expansionFormStack.pop();
                    }
                    else {
                        this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));
                        return null;
                    }
                }
                if (this._peek.type === TokenType.EOF) {
                    this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));
                    return null;
                }
                exp.push(this._advance());
            }
        }
        _consumeText(token) {
            let text = token.parts[0];
            if (text.length > 0 && text[0] == '\n') {
                const parent = this._getParentElement();
                if (parent != null && parent.children.length == 0 &&
                    this.getTagDefinition(parent.name).ignoreFirstLf) {
                    text = text.substring(1);
                }
            }
            if (text.length > 0) {
                this._addToParent(new Text$2(text, token.sourceSpan));
            }
        }
        _closeVoidElement() {
            const el = this._getParentElement();
            if (el && this.getTagDefinition(el.name).isVoid) {
                this._elementStack.pop();
            }
        }
        _consumeStartTag(startTagToken) {
            const prefix = startTagToken.parts[0];
            const name = startTagToken.parts[1];
            const attrs = [];
            while (this._peek.type === TokenType.ATTR_NAME) {
                attrs.push(this._consumeAttr(this._advance()));
            }
            const fullName = this._getElementFullName(prefix, name, this._getParentElement());
            let selfClosing = false;
            // Note: There could have been a tokenizer error
            // so that we don't get a token for the end tag...
            if (this._peek.type === TokenType.TAG_OPEN_END_VOID) {
                this._advance();
                selfClosing = true;
                const tagDef = this.getTagDefinition(fullName);
                if (!(tagDef.canSelfClose || getNsPrefix(fullName) !== null || tagDef.isVoid)) {
                    this.errors.push(TreeError.create(fullName, startTagToken.sourceSpan, `Only void and foreign elements can be self closed "${startTagToken.parts[1]}"`));
                }
            }
            else if (this._peek.type === TokenType.TAG_OPEN_END) {
                this._advance();
                selfClosing = false;
            }
            const end = this._peek.sourceSpan.start;
            const span = new ParseSourceSpan(startTagToken.sourceSpan.start, end);
            const el = new Element$1(fullName, attrs, [], span, span, undefined);
            this._pushElement(el);
            if (selfClosing) {
                // Elements that are self-closed have their `endSourceSpan` set to the full span, as the
                // element start tag also represents the end tag.
                this._popElement(fullName, span);
            }
        }
        _pushElement(el) {
            const parentEl = this._getParentElement();
            if (parentEl && this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {
                this._elementStack.pop();
            }
            this._addToParent(el);
            this._elementStack.push(el);
        }
        _consumeEndTag(endTagToken) {
            const fullName = this._getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());
            if (this.getTagDefinition(fullName).isVoid) {
                this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, `Void elements do not have end tags "${endTagToken.parts[1]}"`));
            }
            else if (!this._popElement(fullName, endTagToken.sourceSpan)) {
                const errMsg = `Unexpected closing tag "${fullName}". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;
                this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));
            }
        }
        _popElement(fullName, endSourceSpan) {
            for (let stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {
                const el = this._elementStack[stackIndex];
                if (el.name == fullName) {
                    // Record the parse span with the element that is being closed. Any elements that are
                    // removed from the element stack at this point are closed implicitly, so they won't get
                    // an end source span (as there is no explicit closing element).
                    el.endSourceSpan = endSourceSpan;
                    this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);
                    return true;
                }
                if (!this.getTagDefinition(el.name).closedByParent) {
                    return false;
                }
            }
            return false;
        }
        _consumeAttr(attrName) {
            const fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);
            let end = attrName.sourceSpan.end;
            let value = '';
            let valueSpan = undefined;
            if (this._peek.type === TokenType.ATTR_QUOTE) {
                this._advance();
            }
            if (this._peek.type === TokenType.ATTR_VALUE) {
                const valueToken = this._advance();
                value = valueToken.parts[0];
                end = valueToken.sourceSpan.end;
                valueSpan = valueToken.sourceSpan;
            }
            if (this._peek.type === TokenType.ATTR_QUOTE) {
                const quoteToken = this._advance();
                end = quoteToken.sourceSpan.end;
            }
            return new Attribute(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, end), valueSpan);
        }
        _getParentElement() {
            return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;
        }
        _addToParent(node) {
            const parent = this._getParentElement();
            if (parent != null) {
                parent.children.push(node);
            }
            else {
                this.rootNodes.push(node);
            }
        }
        _getElementFullName(prefix, localName, parentElement) {
            if (prefix === '') {
                prefix = this.getTagDefinition(localName).implicitNamespacePrefix || '';
                if (prefix === '' && parentElement != null) {
                    prefix = getNsPrefix(parentElement.name);
                }
            }
            return mergeNsAndName(prefix, localName);
        }
    }
    function lastOnStack(stack, element) {
        return stack.length > 0 && stack[stack.length - 1] === element;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class HtmlParser extends Parser {
        constructor() {
            super(getHtmlTagDefinition);
        }
        parse(source, url, options) {
            return super.parse(source, url, options);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const PRESERVE_WS_ATTR_NAME = 'ngPreserveWhitespaces';
    const SKIP_WS_TRIM_TAGS = new Set(['pre', 'template', 'textarea', 'script', 'style']);
    // Equivalent to \s with \u00a0 (non-breaking space) excluded.
    // Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp
    const WS_CHARS = ' \f\n\r\t\v\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff';
    const NO_WS_REGEXP = new RegExp(`[^${WS_CHARS}]`);
    const WS_REPLACE_REGEXP = new RegExp(`[${WS_CHARS}]{2,}`, 'g');
    function hasPreserveWhitespacesAttr(attrs) {
        return attrs.some((attr) => attr.name === PRESERVE_WS_ATTR_NAME);
    }
    /**
     * Angular Dart introduced &ngsp; as a placeholder for non-removable space, see:
     * https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart#L25-L32
     * In Angular Dart &ngsp; is converted to the 0xE500 PUA (Private Use Areas) unicode character
     * and later on replaced by a space. We are re-implementing the same idea here.
     */
    function replaceNgsp(value) {
        // lexer is replacing the &ngsp; pseudo-entity with NGSP_UNICODE
        return value.replace(new RegExp(NGSP_UNICODE, 'g'), ' ');
    }
    /**
     * This visitor can walk HTML parse tree and remove / trim text nodes using the following rules:
     * - consider spaces, tabs and new lines as whitespace characters;
     * - drop text nodes consisting of whitespace characters only;
     * - for all other text nodes replace consecutive whitespace characters with one space;
     * - convert &ngsp; pseudo-entity to a single space;
     *
     * Removal and trimming of whitespaces have positive performance impact (less code to generate
     * while compiling templates, faster view creation). At the same time it can be "destructive"
     * in some cases (whitespaces can influence layout). Because of the potential of breaking layout
     * this visitor is not activated by default in Angular 5 and people need to explicitly opt-in for
     * whitespace removal. The default option for whitespace removal will be revisited in Angular 6
     * and might be changed to "on" by default.
     */
    class WhitespaceVisitor {
        visitElement(element, context) {
            if (SKIP_WS_TRIM_TAGS.has(element.name) || hasPreserveWhitespacesAttr(element.attrs)) {
                // don't descent into elements where we need to preserve whitespaces
                // but still visit all attributes to eliminate one used as a market to preserve WS
                return new Element$1(element.name, visitAll$1(this, element.attrs), element.children, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
            }
            return new Element$1(element.name, element.attrs, visitAllWithSiblings(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
        }
        visitAttribute(attribute, context) {
            return attribute.name !== PRESERVE_WS_ATTR_NAME ? attribute : null;
        }
        visitText(text, context) {
            const isNotBlank = text.value.match(NO_WS_REGEXP);
            const hasExpansionSibling = context &&
                (context.prev instanceof Expansion || context.next instanceof Expansion);
            if (isNotBlank || hasExpansionSibling) {
                return new Text$2(replaceNgsp(text.value).replace(WS_REPLACE_REGEXP, ' '), text.sourceSpan, text.i18n);
            }
            return null;
        }
        visitComment(comment, context) {
            return comment;
        }
        visitExpansion(expansion, context) {
            return expansion;
        }
        visitExpansionCase(expansionCase, context) {
            return expansionCase;
        }
    }
    function visitAllWithSiblings(visitor, nodes) {
        const result = [];
        nodes.forEach((ast, i) => {
            const context = { prev: nodes[i - 1], next: nodes[i + 1] };
            const astResult = ast.visit(visitor, context);
            if (astResult) {
                result.push(astResult);
            }
        });
        return result;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var ProviderAstType;
    (function (ProviderAstType) {
        ProviderAstType[ProviderAstType["PublicService"] = 0] = "PublicService";
        ProviderAstType[ProviderAstType["PrivateService"] = 1] = "PrivateService";
        ProviderAstType[ProviderAstType["Component"] = 2] = "Component";
        ProviderAstType[ProviderAstType["Directive"] = 3] = "Directive";
        ProviderAstType[ProviderAstType["Builtin"] = 4] = "Builtin";
    })(ProviderAstType || (ProviderAstType = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function isStyleUrlResolvable(url) {
        if (url == null || url.length === 0 || url[0] == '/')
            return false;
        const schemeMatch = url.match(URL_WITH_SCHEMA_REGEXP);
        return schemeMatch === null || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';
    }
    const URL_WITH_SCHEMA_REGEXP = /^([^:/?#]+):/;

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const PROPERTY_PARTS_SEPARATOR = '.';
    const ATTRIBUTE_PREFIX = 'attr';
    const CLASS_PREFIX = 'class';
    const STYLE_PREFIX = 'style';
    const TEMPLATE_ATTR_PREFIX = '*';
    const ANIMATE_PROP_PREFIX = 'animate-';
    /**
     * Parses bindings in templates and in the directive host area.
     */
    class BindingParser {
        constructor(_exprParser, _interpolationConfig, _schemaRegistry, pipes, errors) {
            this._exprParser = _exprParser;
            this._interpolationConfig = _interpolationConfig;
            this._schemaRegistry = _schemaRegistry;
            this.errors = errors;
            this.pipesByName = null;
            this._usedPipes = new Map();
            // When the `pipes` parameter is `null`, do not check for used pipes
            // This is used in IVY when we might not know the available pipes at compile time
            if (pipes) {
                const pipesByName = new Map();
                pipes.forEach(pipe => pipesByName.set(pipe.name, pipe));
                this.pipesByName = pipesByName;
            }
        }
        get interpolationConfig() {
            return this._interpolationConfig;
        }
        getUsedPipes() {
            return Array.from(this._usedPipes.values());
        }
        createBoundHostProperties(dirMeta, sourceSpan) {
            if (dirMeta.hostProperties) {
                const boundProps = [];
                Object.keys(dirMeta.hostProperties).forEach(propName => {
                    const expression = dirMeta.hostProperties[propName];
                    if (typeof expression === 'string') {
                        this.parsePropertyBinding(propName, expression, true, sourceSpan, sourceSpan.start.offset, undefined, [], boundProps);
                    }
                    else {
                        this._reportError(`Value of the host property binding "${propName}" needs to be a string representing an expression but got "${expression}" (${typeof expression})`, sourceSpan);
                    }
                });
                return boundProps;
            }
            return null;
        }
        createDirectiveHostPropertyAsts(dirMeta, elementSelector, sourceSpan) {
            const boundProps = this.createBoundHostProperties(dirMeta, sourceSpan);
            return boundProps &&
                boundProps.map((prop) => this.createBoundElementProperty(elementSelector, prop));
        }
        createDirectiveHostEventAsts(dirMeta, sourceSpan) {
            if (dirMeta.hostListeners) {
                const targetEvents = [];
                Object.keys(dirMeta.hostListeners).forEach(propName => {
                    const expression = dirMeta.hostListeners[propName];
                    if (typeof expression === 'string') {
                        // TODO: pass a more accurate handlerSpan for this event.
                        this.parseEvent(propName, expression, sourceSpan, sourceSpan, [], targetEvents);
                    }
                    else {
                        this._reportError(`Value of the host listener "${propName}" needs to be a string representing an expression but got "${expression}" (${typeof expression})`, sourceSpan);
                    }
                });
                return targetEvents;
            }
            return null;
        }
        parseInterpolation(value, sourceSpan) {
            const sourceInfo = sourceSpan.start.toString();
            try {
                const ast = this._exprParser.parseInterpolation(value, sourceInfo, sourceSpan.start.offset, this._interpolationConfig);
                if (ast)
                    this._reportExpressionParserErrors(ast.errors, sourceSpan);
                this._checkPipes(ast, sourceSpan);
                return ast;
            }
            catch (e) {
                this._reportError(`${e}`, sourceSpan);
                return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, sourceSpan.start.offset);
            }
        }
        /**
         * Parses the bindings in a microsyntax expression, and converts them to
         * `ParsedProperty` or `ParsedVariable`.
         *
         * @param tplKey template binding name
         * @param tplValue template binding value
         * @param sourceSpan span of template binding relative to entire the template
         * @param absoluteValueOffset start of the tplValue relative to the entire template
         * @param targetMatchableAttrs potential attributes to match in the template
         * @param targetProps target property bindings in the template
         * @param targetVars target variables in the template
         */
        parseInlineTemplateBinding(tplKey, tplValue, sourceSpan, absoluteValueOffset, targetMatchableAttrs, targetProps, targetVars) {
            const absoluteKeyOffset = sourceSpan.start.offset + TEMPLATE_ATTR_PREFIX.length;
            const bindings = this._parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset);
            for (const binding of bindings) {
                // sourceSpan is for the entire HTML attribute. bindingSpan is for a particular
                // binding within the microsyntax expression so it's more narrow than sourceSpan.
                const bindingSpan = moveParseSourceSpan(sourceSpan, binding.sourceSpan);
                const key = binding.key.source;
                const keySpan = moveParseSourceSpan(sourceSpan, binding.key.span);
                if (binding instanceof VariableBinding) {
                    const value = binding.value ? binding.value.source : '$implicit';
                    const valueSpan = binding.value ? moveParseSourceSpan(sourceSpan, binding.value.span) : undefined;
                    targetVars.push(new ParsedVariable(key, value, bindingSpan, keySpan, valueSpan));
                }
                else if (binding.value) {
                    const valueSpan = moveParseSourceSpan(sourceSpan, binding.value.ast.sourceSpan);
                    this._parsePropertyAst(key, binding.value, sourceSpan, valueSpan, targetMatchableAttrs, targetProps);
                }
                else {
                    targetMatchableAttrs.push([key, '']);
                    this.parseLiteralAttr(key, null, sourceSpan, absoluteValueOffset, undefined, targetMatchableAttrs, targetProps);
                }
            }
        }
        /**
         * Parses the bindings in a microsyntax expression, e.g.
         * ```
         *    <tag *tplKey="let value1 = prop; let value2 = localVar">
         * ```
         *
         * @param tplKey template binding name
         * @param tplValue template binding value
         * @param sourceSpan span of template binding relative to entire the template
         * @param absoluteKeyOffset start of the `tplKey`
         * @param absoluteValueOffset start of the `tplValue`
         */
        _parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset) {
            const sourceInfo = sourceSpan.start.toString();
            try {
                const bindingsResult = this._exprParser.parseTemplateBindings(tplKey, tplValue, sourceInfo, absoluteKeyOffset, absoluteValueOffset);
                this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);
                bindingsResult.templateBindings.forEach((binding) => {
                    if (binding.value instanceof ASTWithSource) {
                        this._checkPipes(binding.value, sourceSpan);
                    }
                });
                bindingsResult.warnings.forEach((warning) => {
                    this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING);
                });
                return bindingsResult.templateBindings;
            }
            catch (e) {
                this._reportError(`${e}`, sourceSpan);
                return [];
            }
        }
        parseLiteralAttr(name, value, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps) {
            if (isAnimationLabel(name)) {
                name = name.substring(1);
                if (value) {
                    this._reportError(`Assigning animation triggers via @prop="exp" attributes with an expression is invalid.` +
                        ` Use property bindings (e.g. [@prop]="exp") or use an attribute without a value (e.g. @prop) instead.`, sourceSpan, ParseErrorLevel.ERROR);
                }
                this._parseAnimation(name, value, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps);
            }
            else {
                targetProps.push(new ParsedProperty(name, this._exprParser.wrapLiteralPrimitive(value, '', absoluteOffset), ParsedPropertyType.LITERAL_ATTR, sourceSpan, valueSpan));
            }
        }
        parsePropertyBinding(name, expression, isHost, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps) {
            if (name.length === 0) {
                this._reportError(`Property name is missing in binding`, sourceSpan);
            }
            let isAnimationProp = false;
            if (name.startsWith(ANIMATE_PROP_PREFIX)) {
                isAnimationProp = true;
                name = name.substring(ANIMATE_PROP_PREFIX.length);
            }
            else if (isAnimationLabel(name)) {
                isAnimationProp = true;
                name = name.substring(1);
            }
            if (isAnimationProp) {
                this._parseAnimation(name, expression, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps);
            }
            else {
                this._parsePropertyAst(name, this._parseBinding(expression, isHost, valueSpan || sourceSpan, absoluteOffset), sourceSpan, valueSpan, targetMatchableAttrs, targetProps);
            }
        }
        parsePropertyInterpolation(name, value, sourceSpan, valueSpan, targetMatchableAttrs, targetProps) {
            const expr = this.parseInterpolation(value, valueSpan || sourceSpan);
            if (expr) {
                this._parsePropertyAst(name, expr, sourceSpan, valueSpan, targetMatchableAttrs, targetProps);
                return true;
            }
            return false;
        }
        _parsePropertyAst(name, ast, sourceSpan, valueSpan, targetMatchableAttrs, targetProps) {
            targetMatchableAttrs.push([name, ast.source]);
            targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.DEFAULT, sourceSpan, valueSpan));
        }
        _parseAnimation(name, expression, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps) {
            if (name.length === 0) {
                this._reportError('Animation trigger is missing', sourceSpan);
            }
            // This will occur when a @trigger is not paired with an expression.
            // For animations it is valid to not have an expression since */void
            // states will be applied by angular when the element is attached/detached
            const ast = this._parseBinding(expression || 'undefined', false, valueSpan || sourceSpan, absoluteOffset);
            targetMatchableAttrs.push([name, ast.source]);
            targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.ANIMATION, sourceSpan, valueSpan));
        }
        _parseBinding(value, isHostBinding, sourceSpan, absoluteOffset) {
            const sourceInfo = (sourceSpan && sourceSpan.start || '(unknown)').toString();
            try {
                const ast = isHostBinding ?
                    this._exprParser.parseSimpleBinding(value, sourceInfo, absoluteOffset, this._interpolationConfig) :
                    this._exprParser.parseBinding(value, sourceInfo, absoluteOffset, this._interpolationConfig);
                if (ast)
                    this._reportExpressionParserErrors(ast.errors, sourceSpan);
                this._checkPipes(ast, sourceSpan);
                return ast;
            }
            catch (e) {
                this._reportError(`${e}`, sourceSpan);
                return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);
            }
        }
        createBoundElementProperty(elementSelector, boundProp, skipValidation = false, mapPropertyName = true) {
            if (boundProp.isAnimation) {
                return new BoundElementProperty(boundProp.name, 4 /* Animation */, SecurityContext.NONE, boundProp.expression, null, boundProp.sourceSpan, boundProp.valueSpan);
            }
            let unit = null;
            let bindingType = undefined;
            let boundPropertyName = null;
            const parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);
            let securityContexts = undefined;
            // Check for special cases (prefix style, attr, class)
            if (parts.length > 1) {
                if (parts[0] == ATTRIBUTE_PREFIX) {
                    boundPropertyName = parts.slice(1).join(PROPERTY_PARTS_SEPARATOR);
                    if (!skipValidation) {
                        this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);
                    }
                    securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, true);
                    const nsSeparatorIdx = boundPropertyName.indexOf(':');
                    if (nsSeparatorIdx > -1) {
                        const ns = boundPropertyName.substring(0, nsSeparatorIdx);
                        const name = boundPropertyName.substring(nsSeparatorIdx + 1);
                        boundPropertyName = mergeNsAndName(ns, name);
                    }
                    bindingType = 1 /* Attribute */;
                }
                else if (parts[0] == CLASS_PREFIX) {
                    boundPropertyName = parts[1];
                    bindingType = 2 /* Class */;
                    securityContexts = [SecurityContext.NONE];
                }
                else if (parts[0] == STYLE_PREFIX) {
                    unit = parts.length > 2 ? parts[2] : null;
                    boundPropertyName = parts[1];
                    bindingType = 3 /* Style */;
                    securityContexts = [SecurityContext.STYLE];
                }
            }
            // If not a special case, use the full property name
            if (boundPropertyName === null) {
                const mappedPropName = this._schemaRegistry.getMappedPropName(boundProp.name);
                boundPropertyName = mapPropertyName ? mappedPropName : boundProp.name;
                securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, mappedPropName, false);
                bindingType = 0 /* Property */;
                if (!skipValidation) {
                    this._validatePropertyOrAttributeName(mappedPropName, boundProp.sourceSpan, false);
                }
            }
            return new BoundElementProperty(boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit, boundProp.sourceSpan, boundProp.valueSpan);
        }
        parseEvent(name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents) {
            if (name.length === 0) {
                this._reportError(`Event name is missing in binding`, sourceSpan);
            }
            if (isAnimationLabel(name)) {
                name = name.substr(1);
                this._parseAnimationEvent(name, expression, sourceSpan, handlerSpan, targetEvents);
            }
            else {
                this._parseRegularEvent(name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents);
            }
        }
        calcPossibleSecurityContexts(selector, propName, isAttribute) {
            const prop = this._schemaRegistry.getMappedPropName(propName);
            return calcPossibleSecurityContexts(this._schemaRegistry, selector, prop, isAttribute);
        }
        _parseAnimationEvent(name, expression, sourceSpan, handlerSpan, targetEvents) {
            const matches = splitAtPeriod(name, [name, '']);
            const eventName = matches[0];
            const phase = matches[1].toLowerCase();
            if (phase) {
                switch (phase) {
                    case 'start':
                    case 'done':
                        const ast = this._parseAction(expression, handlerSpan);
                        targetEvents.push(new ParsedEvent(eventName, phase, 1 /* Animation */, ast, sourceSpan, handlerSpan));
                        break;
                    default:
                        this._reportError(`The provided animation output phase value "${phase}" for "@${eventName}" is not supported (use start or done)`, sourceSpan);
                        break;
                }
            }
            else {
                this._reportError(`The animation trigger output event (@${eventName}) is missing its phase value name (start or done are currently supported)`, sourceSpan);
            }
        }
        _parseRegularEvent(name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents) {
            // long format: 'target: eventName'
            const [target, eventName] = splitAtColon(name, [null, name]);
            const ast = this._parseAction(expression, handlerSpan);
            targetMatchableAttrs.push([name, ast.source]);
            targetEvents.push(new ParsedEvent(eventName, target, 0 /* Regular */, ast, sourceSpan, handlerSpan));
            // Don't detect directives for event names for now,
            // so don't add the event name to the matchableAttrs
        }
        _parseAction(value, sourceSpan) {
            const sourceInfo = (sourceSpan && sourceSpan.start || '(unknown').toString();
            const absoluteOffset = (sourceSpan && sourceSpan.start) ? sourceSpan.start.offset : 0;
            try {
                const ast = this._exprParser.parseAction(value, sourceInfo, absoluteOffset, this._interpolationConfig);
                if (ast) {
                    this._reportExpressionParserErrors(ast.errors, sourceSpan);
                }
                if (!ast || ast.ast instanceof EmptyExpr) {
                    this._reportError(`Empty expressions are not allowed`, sourceSpan);
                    return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);
                }
                this._checkPipes(ast, sourceSpan);
                return ast;
            }
            catch (e) {
                this._reportError(`${e}`, sourceSpan);
                return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);
            }
        }
        _reportError(message, sourceSpan, level = ParseErrorLevel.ERROR) {
            this.errors.push(new ParseError(sourceSpan, message, level));
        }
        _reportExpressionParserErrors(errors, sourceSpan) {
            for (const error of errors) {
                this._reportError(error.message, sourceSpan);
            }
        }
        // Make sure all the used pipes are known in `this.pipesByName`
        _checkPipes(ast, sourceSpan) {
            if (ast && this.pipesByName) {
                const collector = new PipeCollector();
                ast.visit(collector);
                collector.pipes.forEach((ast, pipeName) => {
                    const pipeMeta = this.pipesByName.get(pipeName);
                    if (!pipeMeta) {
                        this._reportError(`The pipe '${pipeName}' could not be found`, new ParseSourceSpan(sourceSpan.start.moveBy(ast.span.start), sourceSpan.start.moveBy(ast.span.end)));
                    }
                    else {
                        this._usedPipes.set(pipeName, pipeMeta);
                    }
                });
            }
        }
        /**
         * @param propName the name of the property / attribute
         * @param sourceSpan
         * @param isAttr true when binding to an attribute
         */
        _validatePropertyOrAttributeName(propName, sourceSpan, isAttr) {
            const report = isAttr ? this._schemaRegistry.validateAttribute(propName) :
                this._schemaRegistry.validateProperty(propName);
            if (report.error) {
                this._reportError(report.msg, sourceSpan, ParseErrorLevel.ERROR);
            }
        }
    }
    class PipeCollector extends RecursiveAstVisitor {
        constructor() {
            super(...arguments);
            this.pipes = new Map();
        }
        visitPipe(ast, context) {
            this.pipes.set(ast.name, ast);
            ast.exp.visit(this);
            this.visitAll(ast.args, context);
            return null;
        }
    }
    function isAnimationLabel(name) {
        return name[0] == '@';
    }
    function calcPossibleSecurityContexts(registry, selector, propName, isAttribute) {
        const ctxs = [];
        CssSelector.parse(selector).forEach((selector) => {
            const elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();
            const notElementNames = new Set(selector.notSelectors.filter(selector => selector.isElementSelector())
                .map((selector) => selector.element));
            const possibleElementNames = elementNames.filter(elementName => !notElementNames.has(elementName));
            ctxs.push(...possibleElementNames.map(elementName => registry.securityContext(elementName, propName, isAttribute)));
        });
        return ctxs.length === 0 ? [SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();
    }
    /**
     * Compute a new ParseSourceSpan based off an original `sourceSpan` by using
     * absolute offsets from the specified `absoluteSpan`.
     *
     * @param sourceSpan original source span
     * @param absoluteSpan absolute source span to move to
     */
    function moveParseSourceSpan(sourceSpan, absoluteSpan) {
        // The difference of two absolute offsets provide the relative offset
        const startDiff = absoluteSpan.start - sourceSpan.start.offset;
        const endDiff = absoluteSpan.end - sourceSpan.end.offset;
        return new ParseSourceSpan(sourceSpan.start.moveBy(startDiff), sourceSpan.end.moveBy(endDiff));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const NG_CONTENT_SELECT_ATTR = 'select';
    const LINK_ELEMENT = 'link';
    const LINK_STYLE_REL_ATTR = 'rel';
    const LINK_STYLE_HREF_ATTR = 'href';
    const LINK_STYLE_REL_VALUE = 'stylesheet';
    const STYLE_ELEMENT = 'style';
    const SCRIPT_ELEMENT = 'script';
    const NG_NON_BINDABLE_ATTR = 'ngNonBindable';
    const NG_PROJECT_AS = 'ngProjectAs';
    function preparseElement(ast) {
        let selectAttr = null;
        let hrefAttr = null;
        let relAttr = null;
        let nonBindable = false;
        let projectAs = '';
        ast.attrs.forEach(attr => {
            const lcAttrName = attr.name.toLowerCase();
            if (lcAttrName == NG_CONTENT_SELECT_ATTR) {
                selectAttr = attr.value;
            }
            else if (lcAttrName == LINK_STYLE_HREF_ATTR) {
                hrefAttr = attr.value;
            }
            else if (lcAttrName == LINK_STYLE_REL_ATTR) {
                relAttr = attr.value;
            }
            else if (attr.name == NG_NON_BINDABLE_ATTR) {
                nonBindable = true;
            }
            else if (attr.name == NG_PROJECT_AS) {
                if (attr.value.length > 0) {
                    projectAs = attr.value;
                }
            }
        });
        selectAttr = normalizeNgContentSelect(selectAttr);
        const nodeName = ast.name.toLowerCase();
        let type = PreparsedElementType.OTHER;
        if (isNgContent(nodeName)) {
            type = PreparsedElementType.NG_CONTENT;
        }
        else if (nodeName == STYLE_ELEMENT) {
            type = PreparsedElementType.STYLE;
        }
        else if (nodeName == SCRIPT_ELEMENT) {
            type = PreparsedElementType.SCRIPT;
        }
        else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {
            type = PreparsedElementType.STYLESHEET;
        }
        return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);
    }
    var PreparsedElementType;
    (function (PreparsedElementType) {
        PreparsedElementType[PreparsedElementType["NG_CONTENT"] = 0] = "NG_CONTENT";
        PreparsedElementType[PreparsedElementType["STYLE"] = 1] = "STYLE";
        PreparsedElementType[PreparsedElementType["STYLESHEET"] = 2] = "STYLESHEET";
        PreparsedElementType[PreparsedElementType["SCRIPT"] = 3] = "SCRIPT";
        PreparsedElementType[PreparsedElementType["OTHER"] = 4] = "OTHER";
    })(PreparsedElementType || (PreparsedElementType = {}));
    class PreparsedElement {
        constructor(type, selectAttr, hrefAttr, nonBindable, projectAs) {
            this.type = type;
            this.selectAttr = selectAttr;
            this.hrefAttr = hrefAttr;
            this.nonBindable = nonBindable;
            this.projectAs = projectAs;
        }
    }
    function normalizeNgContentSelect(selectAttr) {
        if (selectAttr === null || selectAttr.length === 0) {
            return '*';
        }
        return selectAttr;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function isEmptyExpression(ast) {
        if (ast instanceof ASTWithSource) {
            ast = ast.ast;
        }
        return ast instanceof EmptyExpr;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Parses string representation of a style and converts it into object literal.
     *
     * @param value string representation of style as used in the `style` attribute in HTML.
     *   Example: `color: red; height: auto`.
     * @returns An array of style property name and value pairs, e.g. `['color', 'red', 'height',
     * 'auto']`
     */
    function parse(value) {
        // we use a string array here instead of a string map
        // because a string-map is not guaranteed to retain the
        // order of the entries whereas a string array can be
        // constructed in a [key, value, key, value] format.
        const styles = [];
        let i = 0;
        let parenDepth = 0;
        let quote = 0 /* QuoteNone */;
        let valueStart = 0;
        let propStart = 0;
        let currentProp = null;
        let valueHasQuotes = false;
        while (i < value.length) {
            const token = value.charCodeAt(i++);
            switch (token) {
                case 40 /* OpenParen */:
                    parenDepth++;
                    break;
                case 41 /* CloseParen */:
                    parenDepth--;
                    break;
                case 39 /* QuoteSingle */:
                    // valueStart needs to be there since prop values don't
                    // have quotes in CSS
                    valueHasQuotes = valueHasQuotes || valueStart > 0;
                    if (quote === 0 /* QuoteNone */) {
                        quote = 39 /* QuoteSingle */;
                    }
                    else if (quote === 39 /* QuoteSingle */ && value.charCodeAt(i - 1) !== 92 /* BackSlash */) {
                        quote = 0 /* QuoteNone */;
                    }
                    break;
                case 34 /* QuoteDouble */:
                    // same logic as above
                    valueHasQuotes = valueHasQuotes || valueStart > 0;
                    if (quote === 0 /* QuoteNone */) {
                        quote = 34 /* QuoteDouble */;
                    }
                    else if (quote === 34 /* QuoteDouble */ && value.charCodeAt(i - 1) !== 92 /* BackSlash */) {
                        quote = 0 /* QuoteNone */;
                    }
                    break;
                case 58 /* Colon */:
                    if (!currentProp && parenDepth === 0 && quote === 0 /* QuoteNone */) {
                        currentProp = hyphenate(value.substring(propStart, i - 1).trim());
                        valueStart = i;
                    }
                    break;
                case 59 /* Semicolon */:
                    if (currentProp && valueStart > 0 && parenDepth === 0 && quote === 0 /* QuoteNone */) {
                        const styleVal = value.substring(valueStart, i - 1).trim();
                        styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);
                        propStart = i;
                        valueStart = 0;
                        currentProp = null;
                        valueHasQuotes = false;
                    }
                    break;
            }
        }
        if (currentProp && valueStart) {
            const styleVal = value.substr(valueStart).trim();
            styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);
        }
        return styles;
    }
    function stripUnnecessaryQuotes(value) {
        const qS = value.charCodeAt(0);
        const qE = value.charCodeAt(value.length - 1);
        if (qS == qE && (qS == 39 /* QuoteSingle */ || qS == 34 /* QuoteDouble */)) {
            const tempValue = value.substring(1, value.length - 1);
            // special case to avoid using a multi-quoted string that was just chomped
            // (e.g. `font-family: "Verdana", "sans-serif"`)
            if (tempValue.indexOf('\'') == -1 && tempValue.indexOf('"') == -1) {
                value = tempValue;
            }
        }
        return value;
    }
    function hyphenate(value) {
        return value
            .replace(/[a-z][A-Z]/g, v => {
            return v.charAt(0) + '-' + v.charAt(1);
        })
            .toLowerCase();
    }

    const IMPORTANT_FLAG = '!important';
    /**
     * Minimum amount of binding slots required in the runtime for style/class bindings.
     *
     * Styling in Angular uses up two slots in the runtime LView/TData data structures to
     * record binding data, property information and metadata.
     *
     * When a binding is registered it will place the following information in the `LView`:
     *
     * slot 1) binding value
     * slot 2) cached value (all other values collected before it in string form)
     *
     * When a binding is registered it will place the following information in the `TData`:
     *
     * slot 1) prop name
     * slot 2) binding index that points to the previous style/class binding (and some extra config
     * values)
     *
     * Let's imagine we have a binding that looks like so:
     *
     * ```
     * <div [style.width]="x" [style.height]="y">
     * ```
     *
     * Our `LView` and `TData` data-structures look like so:
     *
     * ```typescript
     * LView = [
     *   // ...
     *   x, // value of x
     *   "width: x",
     *
     *   y, // value of y
     *   "width: x; height: y",
     *   // ...
     * ];
     *
     * TData = [
     *   // ...
     *   "width", // binding slot 20
     *   0,
     *
     *   "height",
     *   20,
     *   // ...
     * ];
     * ```
     *
     * */
    const MIN_STYLING_BINDING_SLOTS_REQUIRED = 2;
    /**
     * Produces creation/update instructions for all styling bindings (class and style)
     *
     * It also produces the creation instruction to register all initial styling values
     * (which are all the static class="..." and style="..." attribute values that exist
     * on an element within a template).
     *
     * The builder class below handles producing instructions for the following cases:
     *
     * - Static style/class attributes (style="..." and class="...")
     * - Dynamic style/class map bindings ([style]="map" and [class]="map|string")
     * - Dynamic style/class property bindings ([style.prop]="exp" and [class.name]="exp")
     *
     * Due to the complex relationship of all of these cases, the instructions generated
     * for these attributes/properties/bindings must be done so in the correct order. The
     * order which these must be generated is as follows:
     *
     * if (createMode) {
     *   styling(...)
     * }
     * if (updateMode) {
     *   styleMap(...)
     *   classMap(...)
     *   styleProp(...)
     *   classProp(...)
     * }
     *
     * The creation/update methods within the builder class produce these instructions.
     */
    class StylingBuilder {
        constructor(_directiveExpr) {
            this._directiveExpr = _directiveExpr;
            /** Whether or not there are any static styling values present */
            this._hasInitialValues = false;
            /**
             *  Whether or not there are any styling bindings present
             *  (i.e. `[style]`, `[class]`, `[style.prop]` or `[class.name]`)
             */
            this.hasBindings = false;
            this.hasBindingsWithPipes = false;
            /** the input for [class] (if it exists) */
            this._classMapInput = null;
            /** the input for [style] (if it exists) */
            this._styleMapInput = null;
            /** an array of each [style.prop] input */
            this._singleStyleInputs = null;
            /** an array of each [class.name] input */
            this._singleClassInputs = null;
            this._lastStylingInput = null;
            this._firstStylingInput = null;
            // maps are used instead of hash maps because a Map will
            // retain the ordering of the keys
            /**
             * Represents the location of each style binding in the template
             * (e.g. `<div [style.width]="w" [style.height]="h">` implies
             * that `width=0` and `height=1`)
             */
            this._stylesIndex = new Map();
            /**
             * Represents the location of each class binding in the template
             * (e.g. `<div [class.big]="b" [class.hidden]="h">` implies
             * that `big=0` and `hidden=1`)
             */
            this._classesIndex = new Map();
            this._initialStyleValues = [];
            this._initialClassValues = [];
        }
        /**
         * Registers a given input to the styling builder to be later used when producing AOT code.
         *
         * The code below will only accept the input if it is somehow tied to styling (whether it be
         * style/class bindings or static style/class attributes).
         */
        registerBoundInput(input) {
            // [attr.style] or [attr.class] are skipped in the code below,
            // they should not be treated as styling-based bindings since
            // they are intended to be written directly to the attr and
            // will therefore skip all style/class resolution that is present
            // with style="", [style]="" and [style.prop]="", class="",
            // [class.prop]="". [class]="" assignments
            let binding = null;
            let name = input.name;
            switch (input.type) {
                case 0 /* Property */:
                    binding = this.registerInputBasedOnName(name, input.value, input.sourceSpan);
                    break;
                case 3 /* Style */:
                    binding = this.registerStyleInput(name, false, input.value, input.sourceSpan, input.unit);
                    break;
                case 2 /* Class */:
                    binding = this.registerClassInput(name, false, input.value, input.sourceSpan);
                    break;
            }
            return binding ? true : false;
        }
        registerInputBasedOnName(name, expression, sourceSpan) {
            let binding = null;
            const prefix = name.substring(0, 6);
            const isStyle = name === 'style' || prefix === 'style.' || prefix === 'style!';
            const isClass = !isStyle && (name === 'class' || prefix === 'class.' || prefix === 'class!');
            if (isStyle || isClass) {
                const isMapBased = name.charAt(5) !== '.'; // style.prop or class.prop makes this a no
                const property = name.substr(isMapBased ? 5 : 6); // the dot explains why there's a +1
                if (isStyle) {
                    binding = this.registerStyleInput(property, isMapBased, expression, sourceSpan);
                }
                else {
                    binding = this.registerClassInput(property, isMapBased, expression, sourceSpan);
                }
            }
            return binding;
        }
        registerStyleInput(name, isMapBased, value, sourceSpan, suffix) {
            if (isEmptyExpression(value)) {
                return null;
            }
            name = normalizePropName(name);
            const { property, hasOverrideFlag, suffix: bindingSuffix } = parseProperty(name);
            suffix = typeof suffix === 'string' && suffix.length !== 0 ? suffix : bindingSuffix;
            const entry = { name: property, suffix: suffix, value, sourceSpan, hasOverrideFlag };
            if (isMapBased) {
                this._styleMapInput = entry;
            }
            else {
                (this._singleStyleInputs = this._singleStyleInputs || []).push(entry);
                registerIntoMap(this._stylesIndex, property);
            }
            this._lastStylingInput = entry;
            this._firstStylingInput = this._firstStylingInput || entry;
            this._checkForPipes(value);
            this.hasBindings = true;
            return entry;
        }
        registerClassInput(name, isMapBased, value, sourceSpan) {
            if (isEmptyExpression(value)) {
                return null;
            }
            const { property, hasOverrideFlag } = parseProperty(name);
            const entry = { name: property, value, sourceSpan, hasOverrideFlag, suffix: null };
            if (isMapBased) {
                if (this._classMapInput) {
                    throw new Error('[class] and [className] bindings cannot be used on the same element simultaneously');
                }
                this._classMapInput = entry;
            }
            else {
                (this._singleClassInputs = this._singleClassInputs || []).push(entry);
                registerIntoMap(this._classesIndex, property);
            }
            this._lastStylingInput = entry;
            this._firstStylingInput = this._firstStylingInput || entry;
            this._checkForPipes(value);
            this.hasBindings = true;
            return entry;
        }
        _checkForPipes(value) {
            if ((value instanceof ASTWithSource) && (value.ast instanceof BindingPipe)) {
                this.hasBindingsWithPipes = true;
            }
        }
        /**
         * Registers the element's static style string value to the builder.
         *
         * @param value the style string (e.g. `width:100px; height:200px;`)
         */
        registerStyleAttr(value) {
            this._initialStyleValues = parse(value);
            this._hasInitialValues = true;
        }
        /**
         * Registers the element's static class string value to the builder.
         *
         * @param value the className string (e.g. `disabled gold zoom`)
         */
        registerClassAttr(value) {
            this._initialClassValues = value.trim().split(/\s+/g);
            this._hasInitialValues = true;
        }
        /**
         * Appends all styling-related expressions to the provided attrs array.
         *
         * @param attrs an existing array where each of the styling expressions
         * will be inserted into.
         */
        populateInitialStylingAttrs(attrs) {
            // [CLASS_MARKER, 'foo', 'bar', 'baz' ...]
            if (this._initialClassValues.length) {
                attrs.push(literal(1 /* Classes */));
                for (let i = 0; i < this._initialClassValues.length; i++) {
                    attrs.push(literal(this._initialClassValues[i]));
                }
            }
            // [STYLE_MARKER, 'width', '200px', 'height', '100px', ...]
            if (this._initialStyleValues.length) {
                attrs.push(literal(2 /* Styles */));
                for (let i = 0; i < this._initialStyleValues.length; i += 2) {
                    attrs.push(literal(this._initialStyleValues[i]), literal(this._initialStyleValues[i + 1]));
                }
            }
        }
        /**
         * Builds an instruction with all the expressions and parameters for `elementHostAttrs`.
         *
         * The instruction generation code below is used for producing the AOT statement code which is
         * responsible for registering initial styles (within a directive hostBindings' creation block),
         * as well as any of the provided attribute values, to the directive host element.
         */
        assignHostAttrs(attrs, definitionMap) {
            if (this._directiveExpr && (attrs.length || this._hasInitialValues)) {
                this.populateInitialStylingAttrs(attrs);
                definitionMap.set('hostAttrs', literalArr(attrs));
            }
        }
        /**
         * Builds an instruction with all the expressions and parameters for `classMap`.
         *
         * The instruction data will contain all expressions for `classMap` to function
         * which includes the `[class]` expression params.
         */
        buildClassMapInstruction(valueConverter) {
            if (this._classMapInput) {
                return this._buildMapBasedInstruction(valueConverter, true, this._classMapInput);
            }
            return null;
        }
        /**
         * Builds an instruction with all the expressions and parameters for `styleMap`.
         *
         * The instruction data will contain all expressions for `styleMap` to function
         * which includes the `[style]` expression params.
         */
        buildStyleMapInstruction(valueConverter) {
            if (this._styleMapInput) {
                return this._buildMapBasedInstruction(valueConverter, false, this._styleMapInput);
            }
            return null;
        }
        _buildMapBasedInstruction(valueConverter, isClassBased, stylingInput) {
            // each styling binding value is stored in the LView
            // map-based bindings allocate two slots: one for the
            // previous binding value and another for the previous
            // className or style attribute value.
            let totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED;
            // these values must be outside of the update block so that they can
            // be evaluated (the AST visit call) during creation time so that any
            // pipes can be picked up in time before the template is built
            const mapValue = stylingInput.value.visit(valueConverter);
            let reference;
            if (mapValue instanceof Interpolation) {
                totalBindingSlotsRequired += mapValue.expressions.length;
                reference = isClassBased ? getClassMapInterpolationExpression(mapValue) :
                    getStyleMapInterpolationExpression(mapValue);
            }
            else {
                reference = isClassBased ? Identifiers$1.classMap : Identifiers$1.styleMap;
            }
            return {
                reference,
                calls: [{
                        supportsInterpolation: true,
                        sourceSpan: stylingInput.sourceSpan,
                        allocateBindingSlots: totalBindingSlotsRequired,
                        params: (convertFn) => {
                            const convertResult = convertFn(mapValue);
                            const params = Array.isArray(convertResult) ? convertResult : [convertResult];
                            return params;
                        }
                    }]
            };
        }
        _buildSingleInputs(reference, inputs, valueConverter, getInterpolationExpressionFn, isClassBased) {
            const instructions = [];
            inputs.forEach(input => {
                const previousInstruction = instructions[instructions.length - 1];
                const value = input.value.visit(valueConverter);
                let referenceForCall = reference;
                // each styling binding value is stored in the LView
                // but there are two values stored for each binding:
                //   1) the value itself
                //   2) an intermediate value (concatenation of style up to this point).
                //      We need to store the intermediate value so that we don't allocate
                //      the strings on each CD.
                let totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED;
                if (value instanceof Interpolation) {
                    totalBindingSlotsRequired += value.expressions.length;
                    if (getInterpolationExpressionFn) {
                        referenceForCall = getInterpolationExpressionFn(value);
                    }
                }
                const call = {
                    sourceSpan: input.sourceSpan,
                    allocateBindingSlots: totalBindingSlotsRequired,
                    supportsInterpolation: !!getInterpolationExpressionFn,
                    params: (convertFn) => {
                        // params => stylingProp(propName, value, suffix)
                        const params = [];
                        params.push(literal(input.name));
                        const convertResult = convertFn(value);
                        if (Array.isArray(convertResult)) {
                            params.push(...convertResult);
                        }
                        else {
                            params.push(convertResult);
                        }
                        // [style.prop] bindings may use suffix values (e.g. px, em, etc...), therefore,
                        // if that is detected then we need to pass that in as an optional param.
                        if (!isClassBased && input.suffix !== null) {
                            params.push(literal(input.suffix));
                        }
                        return params;
                    }
                };
                // If we ended up generating a call to the same instruction as the previous styling property
                // we can chain the calls together safely to save some bytes, otherwise we have to generate
                // a separate instruction call. This is primarily a concern with interpolation instructions
                // where we may start off with one `reference`, but end up using another based on the
                // number of interpolations.
                if (previousInstruction && previousInstruction.reference === referenceForCall) {
                    previousInstruction.calls.push(call);
                }
                else {
                    instructions.push({ reference: referenceForCall, calls: [call] });
                }
            });
            return instructions;
        }
        _buildClassInputs(valueConverter) {
            if (this._singleClassInputs) {
                return this._buildSingleInputs(Identifiers$1.classProp, this._singleClassInputs, valueConverter, null, true);
            }
            return [];
        }
        _buildStyleInputs(valueConverter) {
            if (this._singleStyleInputs) {
                return this._buildSingleInputs(Identifiers$1.styleProp, this._singleStyleInputs, valueConverter, getStylePropInterpolationExpression, false);
            }
            return [];
        }
        /**
         * Constructs all instructions which contain the expressions that will be placed
         * into the update block of a template function or a directive hostBindings function.
         */
        buildUpdateLevelInstructions(valueConverter) {
            const instructions = [];
            if (this.hasBindings) {
                const styleMapInstruction = this.buildStyleMapInstruction(valueConverter);
                if (styleMapInstruction) {
                    instructions.push(styleMapInstruction);
                }
                const classMapInstruction = this.buildClassMapInstruction(valueConverter);
                if (classMapInstruction) {
                    instructions.push(classMapInstruction);
                }
                instructions.push(...this._buildStyleInputs(valueConverter));
                instructions.push(...this._buildClassInputs(valueConverter));
            }
            return instructions;
        }
    }
    function registerIntoMap(map, key) {
        if (!map.has(key)) {
            map.set(key, map.size);
        }
    }
    function parseProperty(name) {
        let hasOverrideFlag = false;
        const overrideIndex = name.indexOf(IMPORTANT_FLAG);
        if (overrideIndex !== -1) {
            name = overrideIndex > 0 ? name.substring(0, overrideIndex) : '';
            hasOverrideFlag = true;
        }
        let suffix = null;
        let property = name;
        const unitIndex = name.lastIndexOf('.');
        if (unitIndex > 0) {
            suffix = name.substr(unitIndex + 1);
            property = name.substring(0, unitIndex);
        }
        return { property, suffix, hasOverrideFlag };
    }
    /**
     * Gets the instruction to generate for an interpolated class map.
     * @param interpolation An Interpolation AST
     */
    function getClassMapInterpolationExpression(interpolation) {
        switch (getInterpolationArgsLength(interpolation)) {
            case 1:
                return Identifiers$1.classMap;
            case 3:
                return Identifiers$1.classMapInterpolate1;
            case 5:
                return Identifiers$1.classMapInterpolate2;
            case 7:
                return Identifiers$1.classMapInterpolate3;
            case 9:
                return Identifiers$1.classMapInterpolate4;
            case 11:
                return Identifiers$1.classMapInterpolate5;
            case 13:
                return Identifiers$1.classMapInterpolate6;
            case 15:
                return Identifiers$1.classMapInterpolate7;
            case 17:
                return Identifiers$1.classMapInterpolate8;
            default:
                return Identifiers$1.classMapInterpolateV;
        }
    }
    /**
     * Gets the instruction to generate for an interpolated style map.
     * @param interpolation An Interpolation AST
     */
    function getStyleMapInterpolationExpression(interpolation) {
        switch (getInterpolationArgsLength(interpolation)) {
            case 1:
                return Identifiers$1.styleMap;
            case 3:
                return Identifiers$1.styleMapInterpolate1;
            case 5:
                return Identifiers$1.styleMapInterpolate2;
            case 7:
                return Identifiers$1.styleMapInterpolate3;
            case 9:
                return Identifiers$1.styleMapInterpolate4;
            case 11:
                return Identifiers$1.styleMapInterpolate5;
            case 13:
                return Identifiers$1.styleMapInterpolate6;
            case 15:
                return Identifiers$1.styleMapInterpolate7;
            case 17:
                return Identifiers$1.styleMapInterpolate8;
            default:
                return Identifiers$1.styleMapInterpolateV;
        }
    }
    /**
     * Gets the instruction to generate for an interpolated style prop.
     * @param interpolation An Interpolation AST
     */
    function getStylePropInterpolationExpression(interpolation) {
        switch (getInterpolationArgsLength(interpolation)) {
            case 1:
                return Identifiers$1.styleProp;
            case 3:
                return Identifiers$1.stylePropInterpolate1;
            case 5:
                return Identifiers$1.stylePropInterpolate2;
            case 7:
                return Identifiers$1.stylePropInterpolate3;
            case 9:
                return Identifiers$1.stylePropInterpolate4;
            case 11:
                return Identifiers$1.stylePropInterpolate5;
            case 13:
                return Identifiers$1.stylePropInterpolate6;
            case 15:
                return Identifiers$1.stylePropInterpolate7;
            case 17:
                return Identifiers$1.stylePropInterpolate8;
            default:
                return Identifiers$1.stylePropInterpolateV;
        }
    }
    function normalizePropName(prop) {
        return hyphenate(prop);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var TokenType$1;
    (function (TokenType) {
        TokenType[TokenType["Character"] = 0] = "Character";
        TokenType[TokenType["Identifier"] = 1] = "Identifier";
        TokenType[TokenType["Keyword"] = 2] = "Keyword";
        TokenType[TokenType["String"] = 3] = "String";
        TokenType[TokenType["Operator"] = 4] = "Operator";
        TokenType[TokenType["Number"] = 5] = "Number";
        TokenType[TokenType["Error"] = 6] = "Error";
    })(TokenType$1 || (TokenType$1 = {}));
    const KEYWORDS = ['var', 'let', 'as', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];
    class Lexer {
        tokenize(text) {
            const scanner = new _Scanner(text);
            const tokens = [];
            let token = scanner.scanToken();
            while (token != null) {
                tokens.push(token);
                token = scanner.scanToken();
            }
            return tokens;
        }
    }
    class Token$1 {
        constructor(index, end, type, numValue, strValue) {
            this.index = index;
            this.end = end;
            this.type = type;
            this.numValue = numValue;
            this.strValue = strValue;
        }
        isCharacter(code) {
            return this.type == TokenType$1.Character && this.numValue == code;
        }
        isNumber() {
            return this.type == TokenType$1.Number;
        }
        isString() {
            return this.type == TokenType$1.String;
        }
        isOperator(operator) {
            return this.type == TokenType$1.Operator && this.strValue == operator;
        }
        isIdentifier() {
            return this.type == TokenType$1.Identifier;
        }
        isKeyword() {
            return this.type == TokenType$1.Keyword;
        }
        isKeywordLet() {
            return this.type == TokenType$1.Keyword && this.strValue == 'let';
        }
        isKeywordAs() {
            return this.type == TokenType$1.Keyword && this.strValue == 'as';
        }
        isKeywordNull() {
            return this.type == TokenType$1.Keyword && this.strValue == 'null';
        }
        isKeywordUndefined() {
            return this.type == TokenType$1.Keyword && this.strValue == 'undefined';
        }
        isKeywordTrue() {
            return this.type == TokenType$1.Keyword && this.strValue == 'true';
        }
        isKeywordFalse() {
            return this.type == TokenType$1.Keyword && this.strValue == 'false';
        }
        isKeywordThis() {
            return this.type == TokenType$1.Keyword && this.strValue == 'this';
        }
        isError() {
            return this.type == TokenType$1.Error;
        }
        toNumber() {
            return this.type == TokenType$1.Number ? this.numValue : -1;
        }
        toString() {
            switch (this.type) {
                case TokenType$1.Character:
                case TokenType$1.Identifier:
                case TokenType$1.Keyword:
                case TokenType$1.Operator:
                case TokenType$1.String:
                case TokenType$1.Error:
                    return this.strValue;
                case TokenType$1.Number:
                    return this.numValue.toString();
                default:
                    return null;
            }
        }
    }
    function newCharacterToken(index, end, code) {
        return new Token$1(index, end, TokenType$1.Character, code, String.fromCharCode(code));
    }
    function newIdentifierToken(index, end, text) {
        return new Token$1(index, end, TokenType$1.Identifier, 0, text);
    }
    function newKeywordToken(index, end, text) {
        return new Token$1(index, end, TokenType$1.Keyword, 0, text);
    }
    function newOperatorToken(index, end, text) {
        return new Token$1(index, end, TokenType$1.Operator, 0, text);
    }
    function newStringToken(index, end, text) {
        return new Token$1(index, end, TokenType$1.String, 0, text);
    }
    function newNumberToken(index, end, n) {
        return new Token$1(index, end, TokenType$1.Number, n, '');
    }
    function newErrorToken(index, end, message) {
        return new Token$1(index, end, TokenType$1.Error, 0, message);
    }
    const EOF = new Token$1(-1, -1, TokenType$1.Character, 0, '');
    class _Scanner {
        constructor(input) {
            this.input = input;
            this.peek = 0;
            this.index = -1;
            this.length = input.length;
            this.advance();
        }
        advance() {
            this.peek = ++this.index >= this.length ? $EOF : this.input.charCodeAt(this.index);
        }
        scanToken() {
            const input = this.input, length = this.length;
            let peek = this.peek, index = this.index;
            // Skip whitespace.
            while (peek <= $SPACE) {
                if (++index >= length) {
                    peek = $EOF;
                    break;
                }
                else {
                    peek = input.charCodeAt(index);
                }
            }
            this.peek = peek;
            this.index = index;
            if (index >= length) {
                return null;
            }
            // Handle identifiers and numbers.
            if (isIdentifierStart(peek))
                return this.scanIdentifier();
            if (isDigit(peek))
                return this.scanNumber(index);
            const start = index;
            switch (peek) {
                case $PERIOD:
                    this.advance();
                    return isDigit(this.peek) ? this.scanNumber(start) :
                        newCharacterToken(start, this.index, $PERIOD);
                case $LPAREN:
                case $RPAREN:
                case $LBRACE:
                case $RBRACE:
                case $LBRACKET:
                case $RBRACKET:
                case $COMMA:
                case $COLON:
                case $SEMICOLON:
                    return this.scanCharacter(start, peek);
                case $SQ:
                case $DQ:
                    return this.scanString();
                case $HASH:
                case $PLUS:
                case $MINUS:
                case $STAR:
                case $SLASH:
                case $PERCENT:
                case $CARET:
                    return this.scanOperator(start, String.fromCharCode(peek));
                case $QUESTION:
                    return this.scanComplexOperator(start, '?', $PERIOD, '.');
                case $LT:
                case $GT:
                    return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=');
                case $BANG:
                case $EQ:
                    return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=', $EQ, '=');
                case $AMPERSAND:
                    return this.scanComplexOperator(start, '&', $AMPERSAND, '&');
                case $BAR:
                    return this.scanComplexOperator(start, '|', $BAR, '|');
                case $NBSP:
                    while (isWhitespace(this.peek))
                        this.advance();
                    return this.scanToken();
            }
            this.advance();
            return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);
        }
        scanCharacter(start, code) {
            this.advance();
            return newCharacterToken(start, this.index, code);
        }
        scanOperator(start, str) {
            this.advance();
            return newOperatorToken(start, this.index, str);
        }
        /**
         * Tokenize a 2/3 char long operator
         *
         * @param start start index in the expression
         * @param one first symbol (always part of the operator)
         * @param twoCode code point for the second symbol
         * @param two second symbol (part of the operator when the second code point matches)
         * @param threeCode code point for the third symbol
         * @param three third symbol (part of the operator when provided and matches source expression)
         */
        scanComplexOperator(start, one, twoCode, two, threeCode, three) {
            this.advance();
            let str = one;
            if (this.peek == twoCode) {
                this.advance();
                str += two;
            }
            if (threeCode != null && this.peek == threeCode) {
                this.advance();
                str += three;
            }
            return newOperatorToken(start, this.index, str);
        }
        scanIdentifier() {
            const start = this.index;
            this.advance();
            while (isIdentifierPart(this.peek))
                this.advance();
            const str = this.input.substring(start, this.index);
            return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, this.index, str) :
                newIdentifierToken(start, this.index, str);
        }
        scanNumber(start) {
            let simple = (this.index === start);
            this.advance(); // Skip initial digit.
            while (true) {
                if (isDigit(this.peek)) ;
                else if (this.peek == $PERIOD) {
                    simple = false;
                }
                else if (isExponentStart(this.peek)) {
                    this.advance();
                    if (isExponentSign(this.peek))
                        this.advance();
                    if (!isDigit(this.peek))
                        return this.error('Invalid exponent', -1);
                    simple = false;
                }
                else {
                    break;
                }
                this.advance();
            }
            const str = this.input.substring(start, this.index);
            const value = simple ? parseIntAutoRadix(str) : parseFloat(str);
            return newNumberToken(start, this.index, value);
        }
        scanString() {
            const start = this.index;
            const quote = this.peek;
            this.advance(); // Skip initial quote.
            let buffer = '';
            let marker = this.index;
            const input = this.input;
            while (this.peek != quote) {
                if (this.peek == $BACKSLASH) {
                    buffer += input.substring(marker, this.index);
                    this.advance();
                    let unescapedCode;
                    // Workaround for TS2.1-introduced type strictness
                    this.peek = this.peek;
                    if (this.peek == $u) {
                        // 4 character hex code for unicode character.
                        const hex = input.substring(this.index + 1, this.index + 5);
                        if (/^[0-9a-f]+$/i.test(hex)) {
                            unescapedCode = parseInt(hex, 16);
                        }
                        else {
                            return this.error(`Invalid unicode escape [\\u${hex}]`, 0);
                        }
                        for (let i = 0; i < 5; i++) {
                            this.advance();
                        }
                    }
                    else {
                        unescapedCode = unescape(this.peek);
                        this.advance();
                    }
                    buffer += String.fromCharCode(unescapedCode);
                    marker = this.index;
                }
                else if (this.peek == $EOF) {
                    return this.error('Unterminated quote', 0);
                }
                else {
                    this.advance();
                }
            }
            const last = input.substring(marker, this.index);
            this.advance(); // Skip terminating quote.
            return newStringToken(start, this.index, buffer + last);
        }
        error(message, offset) {
            const position = this.index + offset;
            return newErrorToken(position, this.index, `Lexer Error: ${message} at column ${position} in expression [${this.input}]`);
        }
    }
    function isIdentifierStart(code) {
        return ($a <= code && code <= $z) || ($A <= code && code <= $Z) ||
            (code == $_) || (code == $$);
    }
    function isIdentifier(input) {
        if (input.length == 0)
            return false;
        const scanner = new _Scanner(input);
        if (!isIdentifierStart(scanner.peek))
            return false;
        scanner.advance();
        while (scanner.peek !== $EOF) {
            if (!isIdentifierPart(scanner.peek))
                return false;
            scanner.advance();
        }
        return true;
    }
    function isIdentifierPart(code) {
        return isAsciiLetter(code) || isDigit(code) || (code == $_) ||
            (code == $$);
    }
    function isExponentStart(code) {
        return code == $e || code == $E;
    }
    function isExponentSign(code) {
        return code == $MINUS || code == $PLUS;
    }
    function isQuote(code) {
        return code === $SQ || code === $DQ || code === $BT;
    }
    function unescape(code) {
        switch (code) {
            case $n:
                return $LF;
            case $f:
                return $FF;
            case $r:
                return $CR;
            case $t:
                return $TAB;
            case $v:
                return $VTAB;
            default:
                return code;
        }
    }
    function parseIntAutoRadix(text) {
        const result = parseInt(text);
        if (isNaN(result)) {
            throw new Error('Invalid integer literal when parsing ' + text);
        }
        return result;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class SplitInterpolation {
        constructor(strings, expressions, offsets) {
            this.strings = strings;
            this.expressions = expressions;
            this.offsets = offsets;
        }
    }
    class TemplateBindingParseResult {
        constructor(templateBindings, warnings, errors) {
            this.templateBindings = templateBindings;
            this.warnings = warnings;
            this.errors = errors;
        }
    }
    const defaultInterpolateRegExp = _createInterpolateRegExp(DEFAULT_INTERPOLATION_CONFIG);
    function _getInterpolateRegExp(config) {
        if (config === DEFAULT_INTERPOLATION_CONFIG) {
            return defaultInterpolateRegExp;
        }
        else {
            return _createInterpolateRegExp(config);
        }
    }
    function _createInterpolateRegExp(config) {
        const pattern = escapeRegExp(config.start) + '([\\s\\S]*?)' + escapeRegExp(config.end);
        return new RegExp(pattern, 'g');
    }
    class Parser$1 {
        constructor(_lexer) {
            this._lexer = _lexer;
            this.errors = [];
            this.simpleExpressionChecker = SimpleExpressionChecker;
        }
        parseAction(input, location, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
            this._checkNoInterpolation(input, location, interpolationConfig);
            const sourceToLex = this._stripComments(input);
            const tokens = this._lexer.tokenize(this._stripComments(input));
            const ast = new _ParseAST(input, location, absoluteOffset, tokens, sourceToLex.length, true, this.errors, input.length - sourceToLex.length)
                .parseChain();
            return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);
        }
        parseBinding(input, location, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
            const ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);
            return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);
        }
        checkSimpleExpression(ast) {
            const checker = new this.simpleExpressionChecker();
            ast.visit(checker);
            return checker.errors;
        }
        parseSimpleBinding(input, location, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
            const ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);
            const errors = this.checkSimpleExpression(ast);
            if (errors.length > 0) {
                this._reportError(`Host binding expression cannot contain ${errors.join(' ')}`, input, location);
            }
            return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);
        }
        _reportError(message, input, errLocation, ctxLocation) {
            this.errors.push(new ParserError(message, input, errLocation, ctxLocation));
        }
        _parseBindingAst(input, location, absoluteOffset, interpolationConfig) {
            // Quotes expressions use 3rd-party expression language. We don't want to use
            // our lexer or parser for that, so we check for that ahead of time.
            const quote = this._parseQuote(input, location, absoluteOffset);
            if (quote != null) {
                return quote;
            }
            this._checkNoInterpolation(input, location, interpolationConfig);
            const sourceToLex = this._stripComments(input);
            const tokens = this._lexer.tokenize(sourceToLex);
            return new _ParseAST(input, location, absoluteOffset, tokens, sourceToLex.length, false, this.errors, input.length - sourceToLex.length)
                .parseChain();
        }
        _parseQuote(input, location, absoluteOffset) {
            if (input == null)
                return null;
            const prefixSeparatorIndex = input.indexOf(':');
            if (prefixSeparatorIndex == -1)
                return null;
            const prefix = input.substring(0, prefixSeparatorIndex).trim();
            if (!isIdentifier(prefix))
                return null;
            const uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);
            const span = new ParseSpan(0, input.length);
            return new Quote(span, span.toAbsolute(absoluteOffset), prefix, uninterpretedExpression, location);
        }
        /**
         * Parse microsyntax template expression and return a list of bindings or
         * parsing errors in case the given expression is invalid.
         *
         * For example,
         * ```
         *   <div *ngFor="let item of items">
         *         ^      ^ absoluteValueOffset for `templateValue`
         *         absoluteKeyOffset for `templateKey`
         * ```
         * contains three bindings:
         * 1. ngFor -> null
         * 2. item -> NgForOfContext.$implicit
         * 3. ngForOf -> items
         *
         * This is apparent from the de-sugared template:
         * ```
         *   <ng-template ngFor let-item [ngForOf]="items">
         * ```
         *
         * @param templateKey name of directive, without the * prefix. For example: ngIf, ngFor
         * @param templateValue RHS of the microsyntax attribute
         * @param templateUrl template filename if it's external, component filename if it's inline
         * @param absoluteKeyOffset start of the `templateKey`
         * @param absoluteValueOffset start of the `templateValue`
         */
        parseTemplateBindings(templateKey, templateValue, templateUrl, absoluteKeyOffset, absoluteValueOffset) {
            const tokens = this._lexer.tokenize(templateValue);
            const parser = new _ParseAST(templateValue, templateUrl, absoluteValueOffset, tokens, templateValue.length, false /* parseAction */, this.errors, 0 /* relative offset */);
            return parser.parseTemplateBindings({
                source: templateKey,
                span: new AbsoluteSourceSpan(absoluteKeyOffset, absoluteKeyOffset + templateKey.length),
            });
        }
        parseInterpolation(input, location, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
            const split = this.splitInterpolation(input, location, interpolationConfig);
            if (split == null)
                return null;
            const expressions = [];
            for (let i = 0; i < split.expressions.length; ++i) {
                const expressionText = split.expressions[i];
                const sourceToLex = this._stripComments(expressionText);
                const tokens = this._lexer.tokenize(sourceToLex);
                const ast = new _ParseAST(input, location, absoluteOffset, tokens, sourceToLex.length, false, this.errors, split.offsets[i] + (expressionText.length - sourceToLex.length))
                    .parseChain();
                expressions.push(ast);
            }
            const span = new ParseSpan(0, input == null ? 0 : input.length);
            return new ASTWithSource(new Interpolation(span, span.toAbsolute(absoluteOffset), split.strings, expressions), input, location, absoluteOffset, this.errors);
        }
        splitInterpolation(input, location, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
            const regexp = _getInterpolateRegExp(interpolationConfig);
            const parts = input.split(regexp);
            if (parts.length <= 1) {
                return null;
            }
            const strings = [];
            const expressions = [];
            const offsets = [];
            let offset = 0;
            for (let i = 0; i < parts.length; i++) {
                const part = parts[i];
                if (i % 2 === 0) {
                    // fixed string
                    strings.push(part);
                    offset += part.length;
                }
                else if (part.trim().length > 0) {
                    offset += interpolationConfig.start.length;
                    expressions.push(part);
                    offsets.push(offset);
                    offset += part.length + interpolationConfig.end.length;
                }
                else {
                    this._reportError('Blank expressions are not allowed in interpolated strings', input, `at column ${this._findInterpolationErrorColumn(parts, i, interpolationConfig)} in`, location);
                    expressions.push('$implicit');
                    offsets.push(offset);
                }
            }
            return new SplitInterpolation(strings, expressions, offsets);
        }
        wrapLiteralPrimitive(input, location, absoluteOffset) {
            const span = new ParseSpan(0, input == null ? 0 : input.length);
            return new ASTWithSource(new LiteralPrimitive(span, span.toAbsolute(absoluteOffset), input), input, location, absoluteOffset, this.errors);
        }
        _stripComments(input) {
            const i = this._commentStart(input);
            return i != null ? input.substring(0, i).trim() : input;
        }
        _commentStart(input) {
            let outerQuote = null;
            for (let i = 0; i < input.length - 1; i++) {
                const char = input.charCodeAt(i);
                const nextChar = input.charCodeAt(i + 1);
                if (char === $SLASH && nextChar == $SLASH && outerQuote == null)
                    return i;
                if (outerQuote === char) {
                    outerQuote = null;
                }
                else if (outerQuote == null && isQuote(char)) {
                    outerQuote = char;
                }
            }
            return null;
        }
        _checkNoInterpolation(input, location, interpolationConfig) {
            const regexp = _getInterpolateRegExp(interpolationConfig);
            const parts = input.split(regexp);
            if (parts.length > 1) {
                this._reportError(`Got interpolation (${interpolationConfig.start}${interpolationConfig.end}) where expression was expected`, input, `at column ${this._findInterpolationErrorColumn(parts, 1, interpolationConfig)} in`, location);
            }
        }
        _findInterpolationErrorColumn(parts, partInErrIdx, interpolationConfig) {
            let errLocation = '';
            for (let j = 0; j < partInErrIdx; j++) {
                errLocation += j % 2 === 0 ?
                    parts[j] :
                    `${interpolationConfig.start}${parts[j]}${interpolationConfig.end}`;
            }
            return errLocation.length;
        }
    }
    class IvyParser extends Parser$1 {
        constructor() {
            super(...arguments);
            this.simpleExpressionChecker = IvySimpleExpressionChecker; //
        }
    }
    class _ParseAST {
        constructor(input, location, absoluteOffset, tokens, inputLength, parseAction, errors, offset) {
            this.input = input;
            this.location = location;
            this.absoluteOffset = absoluteOffset;
            this.tokens = tokens;
            this.inputLength = inputLength;
            this.parseAction = parseAction;
            this.errors = errors;
            this.offset = offset;
            this.rparensExpected = 0;
            this.rbracketsExpected = 0;
            this.rbracesExpected = 0;
            // Cache of expression start and input indeces to the absolute source span they map to, used to
            // prevent creating superfluous source spans in `sourceSpan`.
            // A serial of the expression start and input index is used for mapping because both are stateful
            // and may change for subsequent expressions visited by the parser.
            this.sourceSpanCache = new Map();
            this.index = 0;
        }
        peek(offset) {
            const i = this.index + offset;
            return i < this.tokens.length ? this.tokens[i] : EOF;
        }
        get next() {
            return this.peek(0);
        }
        /** Whether all the parser input has been processed. */
        get atEOF() {
            return this.index >= this.tokens.length;
        }
        /**
         * Index of the next token to be processed, or the end of the last token if all have been
         * processed.
         */
        get inputIndex() {
            return this.atEOF ? this.currentEndIndex : this.next.index + this.offset;
        }
        /**
         * End index of the last processed token, or the start of the first token if none have been
         * processed.
         */
        get currentEndIndex() {
            if (this.index > 0) {
                const curToken = this.peek(-1);
                return curToken.end + this.offset;
            }
            // No tokens have been processed yet; return the next token's start or the length of the input
            // if there is no token.
            if (this.tokens.length === 0) {
                return this.inputLength + this.offset;
            }
            return this.next.index + this.offset;
        }
        /**
         * Returns the absolute offset of the start of the current token.
         */
        get currentAbsoluteOffset() {
            return this.absoluteOffset + this.inputIndex;
        }
        span(start) {
            return new ParseSpan(start, this.currentEndIndex);
        }
        sourceSpan(start) {
            const serial = `${start}@${this.inputIndex}`;
            if (!this.sourceSpanCache.has(serial)) {
                this.sourceSpanCache.set(serial, this.span(start).toAbsolute(this.absoluteOffset));
            }
            return this.sourceSpanCache.get(serial);
        }
        advance() {
            this.index++;
        }
        consumeOptionalCharacter(code) {
            if (this.next.isCharacter(code)) {
                this.advance();
                return true;
            }
            else {
                return false;
            }
        }
        peekKeywordLet() {
            return this.next.isKeywordLet();
        }
        peekKeywordAs() {
            return this.next.isKeywordAs();
        }
        expectCharacter(code) {
            if (this.consumeOptionalCharacter(code))
                return;
            this.error(`Missing expected ${String.fromCharCode(code)}`);
        }
        consumeOptionalOperator(op) {
            if (this.next.isOperator(op)) {
                this.advance();
                return true;
            }
            else {
                return false;
            }
        }
        expectOperator(operator) {
            if (this.consumeOptionalOperator(operator))
                return;
            this.error(`Missing expected operator ${operator}`);
        }
        expectIdentifierOrKeyword() {
            const n = this.next;
            if (!n.isIdentifier() && !n.isKeyword()) {
                this.error(`Unexpected token ${n}, expected identifier or keyword`);
                return '';
            }
            this.advance();
            return n.toString();
        }
        expectIdentifierOrKeywordOrString() {
            const n = this.next;
            if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {
                this.error(`Unexpected token ${n}, expected identifier, keyword, or string`);
                return '';
            }
            this.advance();
            return n.toString();
        }
        parseChain() {
            const exprs = [];
            const start = this.inputIndex;
            while (this.index < this.tokens.length) {
                const expr = this.parsePipe();
                exprs.push(expr);
                if (this.consumeOptionalCharacter($SEMICOLON)) {
                    if (!this.parseAction) {
                        this.error('Binding expression cannot contain chained expression');
                    }
                    while (this.consumeOptionalCharacter($SEMICOLON)) {
                    } // read all semicolons
                }
                else if (this.index < this.tokens.length) {
                    this.error(`Unexpected token '${this.next}'`);
                }
            }
            if (exprs.length == 0)
                return new EmptyExpr(this.span(start), this.sourceSpan(start));
            if (exprs.length == 1)
                return exprs[0];
            return new Chain(this.span(start), this.sourceSpan(start), exprs);
        }
        parsePipe() {
            let result = this.parseExpression();
            if (this.consumeOptionalOperator('|')) {
                if (this.parseAction) {
                    this.error('Cannot have a pipe in an action expression');
                }
                do {
                    const nameStart = this.inputIndex;
                    const name = this.expectIdentifierOrKeyword();
                    const nameSpan = this.sourceSpan(nameStart);
                    const args = [];
                    while (this.consumeOptionalCharacter($COLON)) {
                        args.push(this.parseExpression());
                    }
                    const { start } = result.span;
                    result =
                        new BindingPipe(this.span(start), this.sourceSpan(start), result, name, args, nameSpan);
                } while (this.consumeOptionalOperator('|'));
            }
            return result;
        }
        parseExpression() {
            return this.parseConditional();
        }
        parseConditional() {
            const start = this.inputIndex;
            const result = this.parseLogicalOr();
            if (this.consumeOptionalOperator('?')) {
                const yes = this.parsePipe();
                let no;
                if (!this.consumeOptionalCharacter($COLON)) {
                    const end = this.inputIndex;
                    const expression = this.input.substring(start, end);
                    this.error(`Conditional expression ${expression} requires all 3 expressions`);
                    no = new EmptyExpr(this.span(start), this.sourceSpan(start));
                }
                else {
                    no = this.parsePipe();
                }
                return new Conditional(this.span(start), this.sourceSpan(start), result, yes, no);
            }
            else {
                return result;
            }
        }
        parseLogicalOr() {
            // '||'
            let result = this.parseLogicalAnd();
            while (this.consumeOptionalOperator('||')) {
                const right = this.parseLogicalAnd();
                const { start } = result.span;
                result = new Binary(this.span(start), this.sourceSpan(start), '||', result, right);
            }
            return result;
        }
        parseLogicalAnd() {
            // '&&'
            let result = this.parseEquality();
            while (this.consumeOptionalOperator('&&')) {
                const right = this.parseEquality();
                const { start } = result.span;
                result = new Binary(this.span(start), this.sourceSpan(start), '&&', result, right);
            }
            return result;
        }
        parseEquality() {
            // '==','!=','===','!=='
            let result = this.parseRelational();
            while (this.next.type == TokenType$1.Operator) {
                const operator = this.next.strValue;
                switch (operator) {
                    case '==':
                    case '===':
                    case '!=':
                    case '!==':
                        this.advance();
                        const right = this.parseRelational();
                        const { start } = result.span;
                        result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);
                        continue;
                }
                break;
            }
            return result;
        }
        parseRelational() {
            // '<', '>', '<=', '>='
            let result = this.parseAdditive();
            while (this.next.type == TokenType$1.Operator) {
                const operator = this.next.strValue;
                switch (operator) {
                    case '<':
                    case '>':
                    case '<=':
                    case '>=':
                        this.advance();
                        const right = this.parseAdditive();
                        const { start } = result.span;
                        result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);
                        continue;
                }
                break;
            }
            return result;
        }
        parseAdditive() {
            // '+', '-'
            let result = this.parseMultiplicative();
            while (this.next.type == TokenType$1.Operator) {
                const operator = this.next.strValue;
                switch (operator) {
                    case '+':
                    case '-':
                        this.advance();
                        let right = this.parseMultiplicative();
                        const { start } = result.span;
                        result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);
                        continue;
                }
                break;
            }
            return result;
        }
        parseMultiplicative() {
            // '*', '%', '/'
            let result = this.parsePrefix();
            while (this.next.type == TokenType$1.Operator) {
                const operator = this.next.strValue;
                switch (operator) {
                    case '*':
                    case '%':
                    case '/':
                        this.advance();
                        let right = this.parsePrefix();
                        const { start } = result.span;
                        result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);
                        continue;
                }
                break;
            }
            return result;
        }
        parsePrefix() {
            if (this.next.type == TokenType$1.Operator) {
                const start = this.inputIndex;
                const operator = this.next.strValue;
                const literalSpan = new ParseSpan(start, start);
                const literalSourceSpan = literalSpan.toAbsolute(this.absoluteOffset);
                let result;
                switch (operator) {
                    case '+':
                        this.advance();
                        result = this.parsePrefix();
                        return new Binary(this.span(start), this.sourceSpan(start), '-', result, new LiteralPrimitive(literalSpan, literalSourceSpan, 0));
                    case '-':
                        this.advance();
                        result = this.parsePrefix();
                        return new Binary(this.span(start), this.sourceSpan(start), operator, new LiteralPrimitive(literalSpan, literalSourceSpan, 0), result);
                    case '!':
                        this.advance();
                        result = this.parsePrefix();
                        return new PrefixNot(this.span(start), this.sourceSpan(start), result);
                }
            }
            return this.parseCallChain();
        }
        parseCallChain() {
            let result = this.parsePrimary();
            const resultStart = result.span.start;
            while (true) {
                if (this.consumeOptionalCharacter($PERIOD)) {
                    result = this.parseAccessMemberOrMethodCall(result, false);
                }
                else if (this.consumeOptionalOperator('?.')) {
                    result = this.parseAccessMemberOrMethodCall(result, true);
                }
                else if (this.consumeOptionalCharacter($LBRACKET)) {
                    this.rbracketsExpected++;
                    const key = this.parsePipe();
                    this.rbracketsExpected--;
                    this.expectCharacter($RBRACKET);
                    if (this.consumeOptionalOperator('=')) {
                        const value = this.parseConditional();
                        result = new KeyedWrite(this.span(resultStart), this.sourceSpan(resultStart), result, key, value);
                    }
                    else {
                        result = new KeyedRead(this.span(resultStart), this.sourceSpan(resultStart), result, key);
                    }
                }
                else if (this.consumeOptionalCharacter($LPAREN)) {
                    this.rparensExpected++;
                    const args = this.parseCallArguments();
                    this.rparensExpected--;
                    this.expectCharacter($RPAREN);
                    result =
                        new FunctionCall(this.span(resultStart), this.sourceSpan(resultStart), result, args);
                }
                else if (this.consumeOptionalOperator('!')) {
                    result = new NonNullAssert(this.span(resultStart), this.sourceSpan(resultStart), result);
                }
                else {
                    return result;
                }
            }
        }
        parsePrimary() {
            const start = this.inputIndex;
            if (this.consumeOptionalCharacter($LPAREN)) {
                this.rparensExpected++;
                const result = this.parsePipe();
                this.rparensExpected--;
                this.expectCharacter($RPAREN);
                return result;
            }
            else if (this.next.isKeywordNull()) {
                this.advance();
                return new LiteralPrimitive(this.span(start), this.sourceSpan(start), null);
            }
            else if (this.next.isKeywordUndefined()) {
                this.advance();
                return new LiteralPrimitive(this.span(start), this.sourceSpan(start), void 0);
            }
            else if (this.next.isKeywordTrue()) {
                this.advance();
                return new LiteralPrimitive(this.span(start), this.sourceSpan(start), true);
            }
            else if (this.next.isKeywordFalse()) {
                this.advance();
                return new LiteralPrimitive(this.span(start), this.sourceSpan(start), false);
            }
            else if (this.next.isKeywordThis()) {
                this.advance();
                return new ImplicitReceiver(this.span(start), this.sourceSpan(start));
            }
            else if (this.consumeOptionalCharacter($LBRACKET)) {
                this.rbracketsExpected++;
                const elements = this.parseExpressionList($RBRACKET);
                this.rbracketsExpected--;
                this.expectCharacter($RBRACKET);
                return new LiteralArray(this.span(start), this.sourceSpan(start), elements);
            }
            else if (this.next.isCharacter($LBRACE)) {
                return this.parseLiteralMap();
            }
            else if (this.next.isIdentifier()) {
                return this.parseAccessMemberOrMethodCall(new ImplicitReceiver(this.span(start), this.sourceSpan(start)), false);
            }
            else if (this.next.isNumber()) {
                const value = this.next.toNumber();
                this.advance();
                return new LiteralPrimitive(this.span(start), this.sourceSpan(start), value);
            }
            else if (this.next.isString()) {
                const literalValue = this.next.toString();
                this.advance();
                return new LiteralPrimitive(this.span(start), this.sourceSpan(start), literalValue);
            }
            else if (this.index >= this.tokens.length) {
                this.error(`Unexpected end of expression: ${this.input}`);
                return new EmptyExpr(this.span(start), this.sourceSpan(start));
            }
            else {
                this.error(`Unexpected token ${this.next}`);
                return new EmptyExpr(this.span(start), this.sourceSpan(start));
            }
        }
        parseExpressionList(terminator) {
            const result = [];
            if (!this.next.isCharacter(terminator)) {
                do {
                    result.push(this.parsePipe());
                } while (this.consumeOptionalCharacter($COMMA));
            }
            return result;
        }
        parseLiteralMap() {
            const keys = [];
            const values = [];
            const start = this.inputIndex;
            this.expectCharacter($LBRACE);
            if (!this.consumeOptionalCharacter($RBRACE)) {
                this.rbracesExpected++;
                do {
                    const quoted = this.next.isString();
                    const key = this.expectIdentifierOrKeywordOrString();
                    keys.push({ key, quoted });
                    this.expectCharacter($COLON);
                    values.push(this.parsePipe());
                } while (this.consumeOptionalCharacter($COMMA));
                this.rbracesExpected--;
                this.expectCharacter($RBRACE);
            }
            return new LiteralMap(this.span(start), this.sourceSpan(start), keys, values);
        }
        parseAccessMemberOrMethodCall(receiver, isSafe = false) {
            const start = receiver.span.start;
            const nameStart = this.inputIndex;
            const id = this.expectIdentifierOrKeyword();
            const nameSpan = this.sourceSpan(nameStart);
            if (this.consumeOptionalCharacter($LPAREN)) {
                this.rparensExpected++;
                const args = this.parseCallArguments();
                this.expectCharacter($RPAREN);
                this.rparensExpected--;
                const span = this.span(start);
                const sourceSpan = this.sourceSpan(start);
                return isSafe ? new SafeMethodCall(span, sourceSpan, nameSpan, receiver, id, args) :
                    new MethodCall(span, sourceSpan, nameSpan, receiver, id, args);
            }
            else {
                if (isSafe) {
                    if (this.consumeOptionalOperator('=')) {
                        this.error('The \'?.\' operator cannot be used in the assignment');
                        return new EmptyExpr(this.span(start), this.sourceSpan(start));
                    }
                    else {
                        return new SafePropertyRead(this.span(start), this.sourceSpan(start), nameSpan, receiver, id);
                    }
                }
                else {
                    if (this.consumeOptionalOperator('=')) {
                        if (!this.parseAction) {
                            this.error('Bindings cannot contain assignments');
                            return new EmptyExpr(this.span(start), this.sourceSpan(start));
                        }
                        const value = this.parseConditional();
                        return new PropertyWrite(this.span(start), this.sourceSpan(start), nameSpan, receiver, id, value);
                    }
                    else {
                        return new PropertyRead(this.span(start), this.sourceSpan(start), nameSpan, receiver, id);
                    }
                }
            }
        }
        parseCallArguments() {
            if (this.next.isCharacter($RPAREN))
                return [];
            const positionals = [];
            do {
                positionals.push(this.parsePipe());
            } while (this.consumeOptionalCharacter($COMMA));
            return positionals;
        }
        /**
         * Parses an identifier, a keyword, a string with an optional `-` in between,
         * and returns the string along with its absolute source span.
         */
        expectTemplateBindingKey() {
            let result = '';
            let operatorFound = false;
            const start = this.currentAbsoluteOffset;
            do {
                result += this.expectIdentifierOrKeywordOrString();
                operatorFound = this.consumeOptionalOperator('-');
                if (operatorFound) {
                    result += '-';
                }
            } while (operatorFound);
            return {
                source: result,
                span: new AbsoluteSourceSpan(start, start + result.length),
            };
        }
        /**
         * Parse microsyntax template expression and return a list of bindings or
         * parsing errors in case the given expression is invalid.
         *
         * For example,
         * ```
         *   <div *ngFor="let item of items; index as i; trackBy: func">
         * ```
         * contains five bindings:
         * 1. ngFor -> null
         * 2. item -> NgForOfContext.$implicit
         * 3. ngForOf -> items
         * 4. i -> NgForOfContext.index
         * 5. ngForTrackBy -> func
         *
         * For a full description of the microsyntax grammar, see
         * https://gist.github.com/mhevery/d3530294cff2e4a1b3fe15ff75d08855
         *
         * @param templateKey name of the microsyntax directive, like ngIf, ngFor,
         * without the *, along with its absolute span.
         */
        parseTemplateBindings(templateKey) {
            const bindings = [];
            // The first binding is for the template key itself
            // In *ngFor="let item of items", key = "ngFor", value = null
            // In *ngIf="cond | pipe", key = "ngIf", value = "cond | pipe"
            bindings.push(...this.parseDirectiveKeywordBindings(templateKey));
            while (this.index < this.tokens.length) {
                // If it starts with 'let', then this must be variable declaration
                const letBinding = this.parseLetBinding();
                if (letBinding) {
                    bindings.push(letBinding);
                }
                else {
                    // Two possible cases here, either `value "as" key` or
                    // "directive-keyword expression". We don't know which case, but both
                    // "value" and "directive-keyword" are template binding key, so consume
                    // the key first.
                    const key = this.expectTemplateBindingKey();
                    // Peek at the next token, if it is "as" then this must be variable
                    // declaration.
                    const binding = this.parseAsBinding(key);
                    if (binding) {
                        bindings.push(binding);
                    }
                    else {
                        // Otherwise the key must be a directive keyword, like "of". Transform
                        // the key to actual key. Eg. of -> ngForOf, trackBy -> ngForTrackBy
                        key.source = templateKey.source + key.source[0].toUpperCase() + key.source.substring(1);
                        bindings.push(...this.parseDirectiveKeywordBindings(key));
                    }
                }
                this.consumeStatementTerminator();
            }
            return new TemplateBindingParseResult(bindings, [] /* warnings */, this.errors);
        }
        /**
         * Parse a directive keyword, followed by a mandatory expression.
         * For example, "of items", "trackBy: func".
         * The bindings are: ngForOf -> items, ngForTrackBy -> func
         * There could be an optional "as" binding that follows the expression.
         * For example,
         * ```
         *   *ngFor="let item of items | slice:0:1 as collection".
         *                    ^^ ^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^
         *               keyword    bound target   optional 'as' binding
         * ```
         *
         * @param key binding key, for example, ngFor, ngIf, ngForOf, along with its
         * absolute span.
         */
        parseDirectiveKeywordBindings(key) {
            const bindings = [];
            this.consumeOptionalCharacter($COLON); // trackBy: trackByFunction
            const value = this.getDirectiveBoundTarget();
            let spanEnd = this.currentAbsoluteOffset;
            // The binding could optionally be followed by "as". For example,
            // *ngIf="cond | pipe as x". In this case, the key in the "as" binding
            // is "x" and the value is the template key itself ("ngIf"). Note that the
            // 'key' in the current context now becomes the "value" in the next binding.
            const asBinding = this.parseAsBinding(key);
            if (!asBinding) {
                this.consumeStatementTerminator();
                spanEnd = this.currentAbsoluteOffset;
            }
            const sourceSpan = new AbsoluteSourceSpan(key.span.start, spanEnd);
            bindings.push(new ExpressionBinding(sourceSpan, key, value));
            if (asBinding) {
                bindings.push(asBinding);
            }
            return bindings;
        }
        /**
         * Return the expression AST for the bound target of a directive keyword
         * binding. For example,
         * ```
         *   *ngIf="condition | pipe"
         *          ^^^^^^^^^^^^^^^^ bound target for "ngIf"
         *   *ngFor="let item of items"
         *                       ^^^^^ bound target for "ngForOf"
         * ```
         */
        getDirectiveBoundTarget() {
            if (this.next === EOF || this.peekKeywordAs() || this.peekKeywordLet()) {
                return null;
            }
            const ast = this.parsePipe(); // example: "condition | async"
            const { start, end } = ast.span;
            const value = this.input.substring(start, end);
            return new ASTWithSource(ast, value, this.location, this.absoluteOffset + start, this.errors);
        }
        /**
         * Return the binding for a variable declared using `as`. Note that the order
         * of the key-value pair in this declaration is reversed. For example,
         * ```
         *   *ngFor="let item of items; index as i"
         *                              ^^^^^    ^
         *                              value    key
         * ```
         *
         * @param value name of the value in the declaration, "ngIf" in the example
         * above, along with its absolute span.
         */
        parseAsBinding(value) {
            if (!this.peekKeywordAs()) {
                return null;
            }
            this.advance(); // consume the 'as' keyword
            const key = this.expectTemplateBindingKey();
            this.consumeStatementTerminator();
            const sourceSpan = new AbsoluteSourceSpan(value.span.start, this.currentAbsoluteOffset);
            return new VariableBinding(sourceSpan, key, value);
        }
        /**
         * Return the binding for a variable declared using `let`. For example,
         * ```
         *   *ngFor="let item of items; let i=index;"
         *           ^^^^^^^^           ^^^^^^^^^^^
         * ```
         * In the first binding, `item` is bound to `NgForOfContext.$implicit`.
         * In the second binding, `i` is bound to `NgForOfContext.index`.
         */
        parseLetBinding() {
            if (!this.peekKeywordLet()) {
                return null;
            }
            const spanStart = this.currentAbsoluteOffset;
            this.advance(); // consume the 'let' keyword
            const key = this.expectTemplateBindingKey();
            let value = null;
            if (this.consumeOptionalOperator('=')) {
                value = this.expectTemplateBindingKey();
            }
            this.consumeStatementTerminator();
            const sourceSpan = new AbsoluteSourceSpan(spanStart, this.currentAbsoluteOffset);
            return new VariableBinding(sourceSpan, key, value);
        }
        /**
         * Consume the optional statement terminator: semicolon or comma.
         */
        consumeStatementTerminator() {
            this.consumeOptionalCharacter($SEMICOLON) || this.consumeOptionalCharacter($COMMA);
        }
        error(message, index = null) {
            this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));
            this.skip();
        }
        locationText(index = null) {
            if (index == null)
                index = this.index;
            return (index < this.tokens.length) ? `at column ${this.tokens[index].index + 1} in` :
                `at the end of the expression`;
        }
        // Error recovery should skip tokens until it encounters a recovery point. skip() treats
        // the end of input and a ';' as unconditionally a recovery point. It also treats ')',
        // '}' and ']' as conditional recovery points if one of calling productions is expecting
        // one of these symbols. This allows skip() to recover from errors such as '(a.) + 1' allowing
        // more of the AST to be retained (it doesn't skip any tokens as the ')' is retained because
        // of the '(' begins an '(' <expr> ')' production). The recovery points of grouping symbols
        // must be conditional as they must be skipped if none of the calling productions are not
        // expecting the closing token else we will never make progress in the case of an
        // extraneous group closing symbol (such as a stray ')'). This is not the case for ';' because
        // parseChain() is always the root production and it expects a ';'.
        // If a production expects one of these token it increments the corresponding nesting count,
        // and then decrements it just prior to checking if the token is in the input.
        skip() {
            let n = this.next;
            while (this.index < this.tokens.length && !n.isCharacter($SEMICOLON) &&
                (this.rparensExpected <= 0 || !n.isCharacter($RPAREN)) &&
                (this.rbracesExpected <= 0 || !n.isCharacter($RBRACE)) &&
                (this.rbracketsExpected <= 0 || !n.isCharacter($RBRACKET))) {
                if (this.next.isError()) {
                    this.errors.push(new ParserError(this.next.toString(), this.input, this.locationText(), this.location));
                }
                this.advance();
                n = this.next;
            }
        }
    }
    class SimpleExpressionChecker {
        constructor() {
            this.errors = [];
        }
        visitImplicitReceiver(ast, context) { }
        visitInterpolation(ast, context) { }
        visitLiteralPrimitive(ast, context) { }
        visitPropertyRead(ast, context) { }
        visitPropertyWrite(ast, context) { }
        visitSafePropertyRead(ast, context) { }
        visitMethodCall(ast, context) { }
        visitSafeMethodCall(ast, context) { }
        visitFunctionCall(ast, context) { }
        visitLiteralArray(ast, context) {
            this.visitAll(ast.expressions, context);
        }
        visitLiteralMap(ast, context) {
            this.visitAll(ast.values, context);
        }
        visitBinary(ast, context) { }
        visitPrefixNot(ast, context) { }
        visitNonNullAssert(ast, context) { }
        visitConditional(ast, context) { }
        visitPipe(ast, context) {
            this.errors.push('pipes');
        }
        visitKeyedRead(ast, context) { }
        visitKeyedWrite(ast, context) { }
        visitAll(asts, context) {
            return asts.map(node => node.visit(this, context));
        }
        visitChain(ast, context) { }
        visitQuote(ast, context) { }
    }
    /**
     * This class implements SimpleExpressionChecker used in View Engine and performs more strict checks
     * to make sure host bindings do not contain pipes. In View Engine, having pipes in host bindings is
     * not supported as well, but in some cases (like `!(value | async)`) the error is not triggered at
     * compile time. In order to preserve View Engine behavior, more strict checks are introduced for
     * Ivy mode only.
     */
    class IvySimpleExpressionChecker extends RecursiveAstVisitor {
        constructor() {
            super(...arguments);
            this.errors = [];
        }
        visitPipe() {
            this.errors.push('pipes');
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // =================================================================================================
    // =================================================================================================
    // =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========
    // =================================================================================================
    // =================================================================================================
    //
    //        DO NOT EDIT THIS LIST OF SECURITY SENSITIVE PROPERTIES WITHOUT A SECURITY REVIEW!
    //                               Reach out to mprobst for details.
    //
    // =================================================================================================
    /** Map from tagName|propertyName SecurityContext. Properties applying to all tags use '*'. */
    let _SECURITY_SCHEMA;
    function SECURITY_SCHEMA() {
        if (!_SECURITY_SCHEMA) {
            _SECURITY_SCHEMA = {};
            // Case is insignificant below, all element and attribute names are lower-cased for lookup.
            registerContext(SecurityContext.HTML, [
                'iframe|srcdoc',
                '*|innerHTML',
                '*|outerHTML',
            ]);
            registerContext(SecurityContext.STYLE, ['*|style']);
            // NB: no SCRIPT contexts here, they are never allowed due to the parser stripping them.
            registerContext(SecurityContext.URL, [
                '*|formAction', 'area|href', 'area|ping', 'audio|src', 'a|href',
                'a|ping', 'blockquote|cite', 'body|background', 'del|cite', 'form|action',
                'img|src', 'img|srcset', 'input|src', 'ins|cite', 'q|cite',
                'source|src', 'source|srcset', 'track|src', 'video|poster', 'video|src',
            ]);
            registerContext(SecurityContext.RESOURCE_URL, [
                'applet|code',
                'applet|codebase',
                'base|href',
                'embed|src',
                'frame|src',
                'head|profile',
                'html|manifest',
                'iframe|src',
                'link|href',
                'media|src',
                'object|codebase',
                'object|data',
                'script|src',
            ]);
        }
        return _SECURITY_SCHEMA;
    }
    function registerContext(ctx, specs) {
        for (const spec of specs)
            _SECURITY_SCHEMA[spec.toLowerCase()] = ctx;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class ElementSchemaRegistry {
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const BOOLEAN = 'boolean';
    const NUMBER = 'number';
    const STRING = 'string';
    const OBJECT = 'object';
    /**
     * This array represents the DOM schema. It encodes inheritance, properties, and events.
     *
     * ## Overview
     *
     * Each line represents one kind of element. The `element_inheritance` and properties are joined
     * using `element_inheritance|properties` syntax.
     *
     * ## Element Inheritance
     *
     * The `element_inheritance` can be further subdivided as `element1,element2,...^parentElement`.
     * Here the individual elements are separated by `,` (commas). Every element in the list
     * has identical properties.
     *
     * An `element` may inherit additional properties from `parentElement` If no `^parentElement` is
     * specified then `""` (blank) element is assumed.
     *
     * NOTE: The blank element inherits from root `[Element]` element, the super element of all
     * elements.
     *
     * NOTE an element prefix such as `:svg:` has no special meaning to the schema.
     *
     * ## Properties
     *
     * Each element has a set of properties separated by `,` (commas). Each property can be prefixed
     * by a special character designating its type:
     *
     * - (no prefix): property is a string.
     * - `*`: property represents an event.
     * - `!`: property is a boolean.
     * - `#`: property is a number.
     * - `%`: property is an object.
     *
     * ## Query
     *
     * The class creates an internal squas representation which allows to easily answer the query of
     * if a given property exist on a given element.
     *
     * NOTE: We don't yet support querying for types or events.
     * NOTE: This schema is auto extracted from `schema_extractor.ts` located in the test folder,
     *       see dom_element_schema_registry_spec.ts
     */
    // =================================================================================================
    // =================================================================================================
    // =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========
    // =================================================================================================
    // =================================================================================================
    //
    //                       DO NOT EDIT THIS DOM SCHEMA WITHOUT A SECURITY REVIEW!
    //
    // Newly added properties must be security reviewed and assigned an appropriate SecurityContext in
    // dom_security_schema.ts. Reach out to mprobst & rjamet for details.
    //
    // =================================================================================================
    const SCHEMA = [
        '[Element]|textContent,%classList,className,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*copy,*cut,*paste,*search,*selectstart,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerHTML,#scrollLeft,#scrollTop,slot' +
            /* added manually to avoid breaking changes */
            ',*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored',
        '[HTMLElement]^[Element]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate',
        'abbr,address,article,aside,b,bdi,bdo,cite,code,dd,dfn,dt,em,figcaption,figure,footer,header,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate',
        'media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,src,%srcObject,#volume',
        ':svg:^[HTMLElement]|*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,%style,#tabIndex',
        ':svg:graphics^:svg:|',
        ':svg:animation^:svg:|*begin,*end,*repeat',
        ':svg:geometry^:svg:|',
        ':svg:componentTransferFunction^:svg:|',
        ':svg:gradient^:svg:|',
        ':svg:textContent^:svg:graphics|',
        ':svg:textPositioning^:svg:textContent|',
        'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,rev,search,shape,target,text,type,username',
        'area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,search,shape,target,username',
        'audio^media|',
        'br^[HTMLElement]|clear',
        'base^[HTMLElement]|href,target',
        'body^[HTMLElement]|aLink,background,bgColor,link,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink',
        'button^[HTMLElement]|!autofocus,!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value',
        'canvas^[HTMLElement]|#height,#width',
        'content^[HTMLElement]|select',
        'dl^[HTMLElement]|!compact',
        'datalist^[HTMLElement]|',
        'details^[HTMLElement]|!open',
        'dialog^[HTMLElement]|!open,returnValue',
        'dir^[HTMLElement]|!compact',
        'div^[HTMLElement]|align',
        'embed^[HTMLElement]|align,height,name,src,type,width',
        'fieldset^[HTMLElement]|!disabled,name',
        'font^[HTMLElement]|color,face,size',
        'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target',
        'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src',
        'frameset^[HTMLElement]|cols,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows',
        'hr^[HTMLElement]|align,color,!noShade,size,width',
        'head^[HTMLElement]|',
        'h1,h2,h3,h4,h5,h6^[HTMLElement]|align',
        'html^[HTMLElement]|version',
        'iframe^[HTMLElement]|align,!allowFullscreen,frameBorder,height,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width',
        'img^[HTMLElement]|align,alt,border,%crossOrigin,#height,#hspace,!isMap,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width',
        'input^[HTMLElement]|accept,align,alt,autocapitalize,autocomplete,!autofocus,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width',
        'li^[HTMLElement]|type,#value',
        'label^[HTMLElement]|htmlFor',
        'legend^[HTMLElement]|align',
        'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type',
        'map^[HTMLElement]|name',
        'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width',
        'menu^[HTMLElement]|!compact',
        'meta^[HTMLElement]|content,httpEquiv,name,scheme',
        'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value',
        'ins,del^[HTMLElement]|cite,dateTime',
        'ol^[HTMLElement]|!compact,!reversed,#start,type',
        'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width',
        'optgroup^[HTMLElement]|!disabled,label',
        'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value',
        'output^[HTMLElement]|defaultValue,%htmlFor,name,value',
        'p^[HTMLElement]|align',
        'param^[HTMLElement]|name,type,value,valueType',
        'picture^[HTMLElement]|',
        'pre^[HTMLElement]|#width',
        'progress^[HTMLElement]|#max,#value',
        'q,blockquote,cite^[HTMLElement]|',
        'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,src,text,type',
        'select^[HTMLElement]|!autofocus,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value',
        'shadow^[HTMLElement]|',
        'slot^[HTMLElement]|name',
        'source^[HTMLElement]|media,sizes,src,srcset,type',
        'span^[HTMLElement]|',
        'style^[HTMLElement]|!disabled,media,type',
        'caption^[HTMLElement]|align',
        'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width',
        'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width',
        'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width',
        'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign',
        'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign',
        'template^[HTMLElement]|',
        'textarea^[HTMLElement]|autocapitalize,!autofocus,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap',
        'title^[HTMLElement]|text',
        'track^[HTMLElement]|!default,kind,label,src,srclang',
        'ul^[HTMLElement]|!compact,type',
        'unknown^[HTMLElement]|',
        'video^media|#height,poster,#width',
        ':svg:a^:svg:graphics|',
        ':svg:animate^:svg:animation|',
        ':svg:animateMotion^:svg:animation|',
        ':svg:animateTransform^:svg:animation|',
        ':svg:circle^:svg:geometry|',
        ':svg:clipPath^:svg:graphics|',
        ':svg:defs^:svg:graphics|',
        ':svg:desc^:svg:|',
        ':svg:discard^:svg:|',
        ':svg:ellipse^:svg:geometry|',
        ':svg:feBlend^:svg:|',
        ':svg:feColorMatrix^:svg:|',
        ':svg:feComponentTransfer^:svg:|',
        ':svg:feComposite^:svg:|',
        ':svg:feConvolveMatrix^:svg:|',
        ':svg:feDiffuseLighting^:svg:|',
        ':svg:feDisplacementMap^:svg:|',
        ':svg:feDistantLight^:svg:|',
        ':svg:feDropShadow^:svg:|',
        ':svg:feFlood^:svg:|',
        ':svg:feFuncA^:svg:componentTransferFunction|',
        ':svg:feFuncB^:svg:componentTransferFunction|',
        ':svg:feFuncG^:svg:componentTransferFunction|',
        ':svg:feFuncR^:svg:componentTransferFunction|',
        ':svg:feGaussianBlur^:svg:|',
        ':svg:feImage^:svg:|',
        ':svg:feMerge^:svg:|',
        ':svg:feMergeNode^:svg:|',
        ':svg:feMorphology^:svg:|',
        ':svg:feOffset^:svg:|',
        ':svg:fePointLight^:svg:|',
        ':svg:feSpecularLighting^:svg:|',
        ':svg:feSpotLight^:svg:|',
        ':svg:feTile^:svg:|',
        ':svg:feTurbulence^:svg:|',
        ':svg:filter^:svg:|',
        ':svg:foreignObject^:svg:graphics|',
        ':svg:g^:svg:graphics|',
        ':svg:image^:svg:graphics|',
        ':svg:line^:svg:geometry|',
        ':svg:linearGradient^:svg:gradient|',
        ':svg:mpath^:svg:|',
        ':svg:marker^:svg:|',
        ':svg:mask^:svg:|',
        ':svg:metadata^:svg:|',
        ':svg:path^:svg:geometry|',
        ':svg:pattern^:svg:|',
        ':svg:polygon^:svg:geometry|',
        ':svg:polyline^:svg:geometry|',
        ':svg:radialGradient^:svg:gradient|',
        ':svg:rect^:svg:geometry|',
        ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan',
        ':svg:script^:svg:|type',
        ':svg:set^:svg:animation|',
        ':svg:stop^:svg:|',
        ':svg:style^:svg:|!disabled,media,title,type',
        ':svg:switch^:svg:graphics|',
        ':svg:symbol^:svg:|',
        ':svg:tspan^:svg:textPositioning|',
        ':svg:text^:svg:textPositioning|',
        ':svg:textPath^:svg:textContent|',
        ':svg:title^:svg:|',
        ':svg:use^:svg:graphics|',
        ':svg:view^:svg:|#zoomAndPan',
        'data^[HTMLElement]|value',
        'keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name',
        'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default',
        'summary^[HTMLElement]|',
        'time^[HTMLElement]|dateTime',
        ':svg:cursor^:svg:|',
    ];
    const _ATTR_TO_PROP = {
        'class': 'className',
        'for': 'htmlFor',
        'formaction': 'formAction',
        'innerHtml': 'innerHTML',
        'readonly': 'readOnly',
        'tabindex': 'tabIndex',
    };
    class DomElementSchemaRegistry extends ElementSchemaRegistry {
        constructor() {
            super();
            this._schema = {};
            SCHEMA.forEach(encodedType => {
                const type = {};
                const [strType, strProperties] = encodedType.split('|');
                const properties = strProperties.split(',');
                const [typeNames, superName] = strType.split('^');
                typeNames.split(',').forEach(tag => this._schema[tag.toLowerCase()] = type);
                const superType = superName && this._schema[superName.toLowerCase()];
                if (superType) {
                    Object.keys(superType).forEach((prop) => {
                        type[prop] = superType[prop];
                    });
                }
                properties.forEach((property) => {
                    if (property.length > 0) {
                        switch (property[0]) {
                            case '*':
                                // We don't yet support events.
                                // If ever allowing to bind to events, GO THROUGH A SECURITY REVIEW, allowing events
                                // will
                                // almost certainly introduce bad XSS vulnerabilities.
                                // type[property.substring(1)] = EVENT;
                                break;
                            case '!':
                                type[property.substring(1)] = BOOLEAN;
                                break;
                            case '#':
                                type[property.substring(1)] = NUMBER;
                                break;
                            case '%':
                                type[property.substring(1)] = OBJECT;
                                break;
                            default:
                                type[property] = STRING;
                        }
                    }
                });
            });
        }
        hasProperty(tagName, propName, schemaMetas) {
            if (schemaMetas.some((schema) => schema.name === NO_ERRORS_SCHEMA.name)) {
                return true;
            }
            if (tagName.indexOf('-') > -1) {
                if (isNgContainer(tagName) || isNgContent(tagName)) {
                    return false;
                }
                if (schemaMetas.some((schema) => schema.name === CUSTOM_ELEMENTS_SCHEMA.name)) {
                    // Can't tell now as we don't know which properties a custom element will get
                    // once it is instantiated
                    return true;
                }
            }
            const elementProperties = this._schema[tagName.toLowerCase()] || this._schema['unknown'];
            return !!elementProperties[propName];
        }
        hasElement(tagName, schemaMetas) {
            if (schemaMetas.some((schema) => schema.name === NO_ERRORS_SCHEMA.name)) {
                return true;
            }
            if (tagName.indexOf('-') > -1) {
                if (isNgContainer(tagName) || isNgContent(tagName)) {
                    return true;
                }
                if (schemaMetas.some((schema) => schema.name === CUSTOM_ELEMENTS_SCHEMA.name)) {
                    // Allow any custom elements
                    return true;
                }
            }
            return !!this._schema[tagName.toLowerCase()];
        }
        /**
         * securityContext returns the security context for the given property on the given DOM tag.
         *
         * Tag and property name are statically known and cannot change at runtime, i.e. it is not
         * possible to bind a value into a changing attribute or tag name.
         *
         * The filtering is based on a list of allowed tags|attributes. All attributes in the schema
         * above are assumed to have the 'NONE' security context, i.e. that they are safe inert
         * string values. Only specific well known attack vectors are assigned their appropriate context.
         */
        securityContext(tagName, propName, isAttribute) {
            if (isAttribute) {
                // NB: For security purposes, use the mapped property name, not the attribute name.
                propName = this.getMappedPropName(propName);
            }
            // Make sure comparisons are case insensitive, so that case differences between attribute and
            // property names do not have a security impact.
            tagName = tagName.toLowerCase();
            propName = propName.toLowerCase();
            let ctx = SECURITY_SCHEMA()[tagName + '|' + propName];
            if (ctx) {
                return ctx;
            }
            ctx = SECURITY_SCHEMA()['*|' + propName];
            return ctx ? ctx : SecurityContext.NONE;
        }
        getMappedPropName(propName) {
            return _ATTR_TO_PROP[propName] || propName;
        }
        getDefaultComponentElementName() {
            return 'ng-component';
        }
        validateProperty(name) {
            if (name.toLowerCase().startsWith('on')) {
                const msg = `Binding to event property '${name}' is disallowed for security reasons, ` +
                    `please use (${name.slice(2)})=...` +
                    `\nIf '${name}' is a directive input, make sure the directive is imported by the` +
                    ` current module.`;
                return { error: true, msg: msg };
            }
            else {
                return { error: false };
            }
        }
        validateAttribute(name) {
            if (name.toLowerCase().startsWith('on')) {
                const msg = `Binding to event attribute '${name}' is disallowed for security reasons, ` +
                    `please use (${name.slice(2)})=...`;
                return { error: true, msg: msg };
            }
            else {
                return { error: false };
            }
        }
        allKnownElementNames() {
            return Object.keys(this._schema);
        }
        normalizeAnimationStyleProperty(propName) {
            return dashCaseToCamelCase(propName);
        }
        normalizeAnimationStyleValue(camelCaseProp, userProvidedProp, val) {
            let unit = '';
            const strVal = val.toString().trim();
            let errorMsg = null;
            if (_isPixelDimensionStyle(camelCaseProp) && val !== 0 && val !== '0') {
                if (typeof val === 'number') {
                    unit = 'px';
                }
                else {
                    const valAndSuffixMatch = val.match(/^[+-]?[\d\.]+([a-z]*)$/);
                    if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {
                        errorMsg = `Please provide a CSS unit value for ${userProvidedProp}:${val}`;
                    }
                }
            }
            return { error: errorMsg, value: strVal + unit };
        }
    }
    function _isPixelDimensionStyle(prop) {
        switch (prop) {
            case 'width':
            case 'height':
            case 'minWidth':
            case 'minHeight':
            case 'maxWidth':
            case 'maxHeight':
            case 'left':
            case 'top':
            case 'bottom':
            case 'right':
            case 'fontSize':
            case 'outlineWidth':
            case 'outlineOffset':
            case 'paddingTop':
            case 'paddingLeft':
            case 'paddingBottom':
            case 'paddingRight':
            case 'marginTop':
            case 'marginLeft':
            case 'marginBottom':
            case 'marginRight':
            case 'borderRadius':
            case 'borderWidth':
            case 'borderTopWidth':
            case 'borderLeftWidth':
            case 'borderRightWidth':
            case 'borderBottomWidth':
            case 'textIndent':
                return true;
            default:
                return false;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*))|\[\(([^\)]+)\)\]|\[([^\]]+)\]|\(([^\)]+)\))$/;
    // Group 1 = "bind-"
    const KW_BIND_IDX = 1;
    // Group 2 = "let-"
    const KW_LET_IDX = 2;
    // Group 3 = "ref-/#"
    const KW_REF_IDX = 3;
    // Group 4 = "on-"
    const KW_ON_IDX = 4;
    // Group 5 = "bindon-"
    const KW_BINDON_IDX = 5;
    // Group 6 = "@"
    const KW_AT_IDX = 6;
    // Group 7 = the identifier after "bind-", "let-", "ref-/#", "on-", "bindon-" or "@"
    const IDENT_KW_IDX = 7;
    // Group 8 = identifier inside [()]
    const IDENT_BANANA_BOX_IDX = 8;
    // Group 9 = identifier inside []
    const IDENT_PROPERTY_IDX = 9;
    // Group 10 = identifier inside ()
    const IDENT_EVENT_IDX = 10;
    const TEMPLATE_ATTR_PREFIX$1 = '*';
    function htmlAstToRender3Ast(htmlNodes, bindingParser) {
        const transformer = new HtmlAstToIvyAst(bindingParser);
        const ivyNodes = visitAll$1(transformer, htmlNodes);
        // Errors might originate in either the binding parser or the html to ivy transformer
        const allErrors = bindingParser.errors.concat(transformer.errors);
        const errors = allErrors.filter(e => e.level === ParseErrorLevel.ERROR);
        if (errors.length > 0) {
            const errorString = errors.join('\n');
            throw syntaxError(`Template parse errors:\n${errorString}`, errors);
        }
        return {
            nodes: ivyNodes,
            errors: allErrors,
            styleUrls: transformer.styleUrls,
            styles: transformer.styles,
            ngContentSelectors: transformer.ngContentSelectors,
        };
    }
    class HtmlAstToIvyAst {
        constructor(bindingParser) {
            this.bindingParser = bindingParser;
            this.errors = [];
            this.styles = [];
            this.styleUrls = [];
            this.ngContentSelectors = [];
            this.inI18nBlock = false;
        }
        // HTML visitor
        visitElement(element) {
            const isI18nRootElement = isI18nRootNode(element.i18n);
            if (isI18nRootElement) {
                if (this.inI18nBlock) {
                    this.reportError('Cannot mark an element as translatable inside of a translatable section. Please remove the nested i18n marker.', element.sourceSpan);
                }
                this.inI18nBlock = true;
            }
            const preparsedElement = preparseElement(element);
            if (preparsedElement.type === PreparsedElementType.SCRIPT) {
                return null;
            }
            else if (preparsedElement.type === PreparsedElementType.STYLE) {
                const contents = textContents(element);
                if (contents !== null) {
                    this.styles.push(contents);
                }
                return null;
            }
            else if (preparsedElement.type === PreparsedElementType.STYLESHEET &&
                isStyleUrlResolvable(preparsedElement.hrefAttr)) {
                this.styleUrls.push(preparsedElement.hrefAttr);
                return null;
            }
            // Whether the element is a `<ng-template>`
            const isTemplateElement = isNgTemplate(element.name);
            const parsedProperties = [];
            const boundEvents = [];
            const variables = [];
            const references = [];
            const attributes = [];
            const i18nAttrsMeta = {};
            const templateParsedProperties = [];
            const templateVariables = [];
            // Whether the element has any *-attribute
            let elementHasInlineTemplate = false;
            for (const attribute of element.attrs) {
                let hasBinding = false;
                const normalizedName = normalizeAttributeName(attribute.name);
                // `*attr` defines template bindings
                let isTemplateBinding = false;
                if (attribute.i18n) {
                    i18nAttrsMeta[attribute.name] = attribute.i18n;
                }
                if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX$1)) {
                    // *-attributes
                    if (elementHasInlineTemplate) {
                        this.reportError(`Can't have multiple template bindings on one element. Use only one attribute prefixed with *`, attribute.sourceSpan);
                    }
                    isTemplateBinding = true;
                    elementHasInlineTemplate = true;
                    const templateValue = attribute.value;
                    const templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX$1.length);
                    const parsedVariables = [];
                    const absoluteValueOffset = attribute.valueSpan ?
                        attribute.valueSpan.start.offset :
                        // If there is no value span the attribute does not have a value, like `attr` in
                        //`<div attr></div>`. In this case, point to one character beyond the last character of
                        // the attribute name.
                        attribute.sourceSpan.start.offset + attribute.name.length;
                    this.bindingParser.parseInlineTemplateBinding(templateKey, templateValue, attribute.sourceSpan, absoluteValueOffset, [], templateParsedProperties, parsedVariables);
                    templateVariables.push(...parsedVariables.map(v => new Variable(v.name, v.value, v.sourceSpan, v.valueSpan)));
                }
                else {
                    // Check for variables, events, property bindings, interpolation
                    hasBinding = this.parseAttribute(isTemplateElement, attribute, [], parsedProperties, boundEvents, variables, references);
                }
                if (!hasBinding && !isTemplateBinding) {
                    // don't include the bindings as attributes as well in the AST
                    attributes.push(this.visitAttribute(attribute));
                }
            }
            const children = visitAll$1(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children);
            let parsedElement;
            if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {
                // `<ng-content>`
                if (element.children &&
                    !element.children.every((node) => isEmptyTextNode(node) || isCommentNode(node))) {
                    this.reportError(`<ng-content> element cannot have content.`, element.sourceSpan);
                }
                const selector = preparsedElement.selectAttr;
                const attrs = element.attrs.map(attr => this.visitAttribute(attr));
                parsedElement = new Content(selector, attrs, element.sourceSpan, element.i18n);
                this.ngContentSelectors.push(selector);
            }
            else if (isTemplateElement) {
                // `<ng-template>`
                const attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);
                parsedElement = new Template(element.name, attributes, attrs.bound, boundEvents, [ /* no template attributes */], children, references, variables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
            }
            else {
                const attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);
                parsedElement = new Element(element.name, attributes, attrs.bound, boundEvents, children, references, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
            }
            if (elementHasInlineTemplate) {
                // If this node is an inline-template (e.g. has *ngFor) then we need to create a template
                // node that contains this node.
                // Moreover, if the node is an element, then we need to hoist its attributes to the template
                // node for matching against content projection selectors.
                const attrs = this.extractAttributes('ng-template', templateParsedProperties, i18nAttrsMeta);
                const templateAttrs = [];
                attrs.literal.forEach(attr => templateAttrs.push(attr));
                attrs.bound.forEach(attr => templateAttrs.push(attr));
                const hoistedAttrs = parsedElement instanceof Element ?
                    {
                        attributes: parsedElement.attributes,
                        inputs: parsedElement.inputs,
                        outputs: parsedElement.outputs,
                    } :
                    { attributes: [], inputs: [], outputs: [] };
                // For <ng-template>s with structural directives on them, avoid passing i18n information to
                // the wrapping template to prevent unnecessary i18n instructions from being generated. The
                // necessary i18n meta information will be extracted from child elements.
                const i18n = isTemplateElement && isI18nRootElement ? undefined : element.i18n;
                // TODO(pk): test for this case
                parsedElement = new Template(parsedElement.name, hoistedAttrs.attributes, hoistedAttrs.inputs, hoistedAttrs.outputs, templateAttrs, [parsedElement], [ /* no references */], templateVariables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, i18n);
            }
            if (isI18nRootElement) {
                this.inI18nBlock = false;
            }
            return parsedElement;
        }
        visitAttribute(attribute) {
            return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.valueSpan, attribute.i18n);
        }
        visitText(text) {
            return this._visitTextWithInterpolation(text.value, text.sourceSpan, text.i18n);
        }
        visitExpansion(expansion) {
            if (!expansion.i18n) {
                // do not generate Icu in case it was created
                // outside of i18n block in a template
                return null;
            }
            if (!isI18nRootNode(expansion.i18n)) {
                throw new Error(`Invalid type "${expansion.i18n.constructor}" for "i18n" property of ${expansion.sourceSpan.toString()}. Expected a "Message"`);
            }
            const message = expansion.i18n;
            const vars = {};
            const placeholders = {};
            // extract VARs from ICUs - we process them separately while
            // assembling resulting message via goog.getMsg function, since
            // we need to pass them to top-level goog.getMsg call
            Object.keys(message.placeholders).forEach(key => {
                const value = message.placeholders[key];
                if (key.startsWith(I18N_ICU_VAR_PREFIX)) {
                    const config = this.bindingParser.interpolationConfig;
                    // ICU expression is a plain string, not wrapped into start
                    // and end tags, so we wrap it before passing to binding parser
                    const wrapped = `${config.start}${value}${config.end}`;
                    // Currently when the `plural` or `select` keywords in an ICU contain trailing spaces (e.g.
                    // `{count, select , ...}`), these spaces are also included into the key names in ICU vars
                    // (e.g. "VAR_SELECT "). These trailing spaces are not desirable, since they will later be
                    // converted into `_` symbols while normalizing placeholder names, which might lead to
                    // mismatches at runtime (i.e. placeholder will not be replaced with the correct value).
                    const formattedKey = key.trim();
                    vars[formattedKey] =
                        this._visitTextWithInterpolation(wrapped, expansion.sourceSpan);
                }
                else {
                    placeholders[key] = this._visitTextWithInterpolation(value, expansion.sourceSpan);
                }
            });
            return new Icu(vars, placeholders, expansion.sourceSpan, message);
        }
        visitExpansionCase(expansionCase) {
            return null;
        }
        visitComment(comment) {
            return null;
        }
        // convert view engine `ParsedProperty` to a format suitable for IVY
        extractAttributes(elementName, properties, i18nPropsMeta) {
            const bound = [];
            const literal = [];
            properties.forEach(prop => {
                const i18n = i18nPropsMeta[prop.name];
                if (prop.isLiteral) {
                    literal.push(new TextAttribute(prop.name, prop.expression.source || '', prop.sourceSpan, undefined, i18n));
                }
                else {
                    // Note that validation is skipped and property mapping is disabled
                    // due to the fact that we need to make sure a given prop is not an
                    // input of a directive and directive matching happens at runtime.
                    const bep = this.bindingParser.createBoundElementProperty(elementName, prop, /* skipValidation */ true, /* mapPropertyName */ false);
                    bound.push(BoundAttribute.fromBoundElementProperty(bep, i18n));
                }
            });
            return { bound, literal };
        }
        parseAttribute(isTemplateElement, attribute, matchableAttributes, parsedProperties, boundEvents, variables, references) {
            const name = normalizeAttributeName(attribute.name);
            const value = attribute.value;
            const srcSpan = attribute.sourceSpan;
            const absoluteOffset = attribute.valueSpan ? attribute.valueSpan.start.offset : srcSpan.start.offset;
            const bindParts = name.match(BIND_NAME_REGEXP);
            let hasBinding = false;
            if (bindParts) {
                hasBinding = true;
                if (bindParts[KW_BIND_IDX] != null) {
                    this.bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties);
                }
                else if (bindParts[KW_LET_IDX]) {
                    if (isTemplateElement) {
                        const identifier = bindParts[IDENT_KW_IDX];
                        this.parseVariable(identifier, value, srcSpan, attribute.valueSpan, variables);
                    }
                    else {
                        this.reportError(`"let-" is only supported on ng-template elements.`, srcSpan);
                    }
                }
                else if (bindParts[KW_REF_IDX]) {
                    const identifier = bindParts[IDENT_KW_IDX];
                    this.parseReference(identifier, value, srcSpan, attribute.valueSpan, references);
                }
                else if (bindParts[KW_ON_IDX]) {
                    const events = [];
                    this.bindingParser.parseEvent(bindParts[IDENT_KW_IDX], value, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events);
                    addEvents(events, boundEvents);
                }
                else if (bindParts[KW_BINDON_IDX]) {
                    this.bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties);
                    this.parseAssignmentEvent(bindParts[IDENT_KW_IDX], value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents);
                }
                else if (bindParts[KW_AT_IDX]) {
                    this.bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties);
                }
                else if (bindParts[IDENT_BANANA_BOX_IDX]) {
                    this.bindingParser.parsePropertyBinding(bindParts[IDENT_BANANA_BOX_IDX], value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties);
                    this.parseAssignmentEvent(bindParts[IDENT_BANANA_BOX_IDX], value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents);
                }
                else if (bindParts[IDENT_PROPERTY_IDX]) {
                    this.bindingParser.parsePropertyBinding(bindParts[IDENT_PROPERTY_IDX], value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties);
                }
                else if (bindParts[IDENT_EVENT_IDX]) {
                    const events = [];
                    this.bindingParser.parseEvent(bindParts[IDENT_EVENT_IDX], value, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events);
                    addEvents(events, boundEvents);
                }
            }
            else {
                hasBinding = this.bindingParser.parsePropertyInterpolation(name, value, srcSpan, attribute.valueSpan, matchableAttributes, parsedProperties);
            }
            return hasBinding;
        }
        _visitTextWithInterpolation(value, sourceSpan, i18n) {
            const valueNoNgsp = replaceNgsp(value);
            const expr = this.bindingParser.parseInterpolation(valueNoNgsp, sourceSpan);
            return expr ? new BoundText(expr, sourceSpan, i18n) : new Text(valueNoNgsp, sourceSpan);
        }
        parseVariable(identifier, value, sourceSpan, valueSpan, variables) {
            if (identifier.indexOf('-') > -1) {
                this.reportError(`"-" is not allowed in variable names`, sourceSpan);
            }
            else if (identifier.length === 0) {
                this.reportError(`Variable does not have a name`, sourceSpan);
            }
            variables.push(new Variable(identifier, value, sourceSpan, valueSpan));
        }
        parseReference(identifier, value, sourceSpan, valueSpan, references) {
            if (identifier.indexOf('-') > -1) {
                this.reportError(`"-" is not allowed in reference names`, sourceSpan);
            }
            else if (identifier.length === 0) {
                this.reportError(`Reference does not have a name`, sourceSpan);
            }
            references.push(new Reference(identifier, value, sourceSpan, valueSpan));
        }
        parseAssignmentEvent(name, expression, sourceSpan, valueSpan, targetMatchableAttrs, boundEvents) {
            const events = [];
            this.bindingParser.parseEvent(`${name}Change`, `${expression}=$event`, sourceSpan, valueSpan || sourceSpan, targetMatchableAttrs, events);
            addEvents(events, boundEvents);
        }
        reportError(message, sourceSpan, level = ParseErrorLevel.ERROR) {
            this.errors.push(new ParseError(sourceSpan, message, level));
        }
    }
    class NonBindableVisitor {
        visitElement(ast) {
            const preparsedElement = preparseElement(ast);
            if (preparsedElement.type === PreparsedElementType.SCRIPT ||
                preparsedElement.type === PreparsedElementType.STYLE ||
                preparsedElement.type === PreparsedElementType.STYLESHEET) {
                // Skipping <script> for security reasons
                // Skipping <style> and stylesheets as we already processed them
                // in the StyleCompiler
                return null;
            }
            const children = visitAll$1(this, ast.children, null);
            return new Element(ast.name, visitAll$1(this, ast.attrs), 
            /* inputs */ [], /* outputs */ [], children, /* references */ [], ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan);
        }
        visitComment(comment) {
            return null;
        }
        visitAttribute(attribute) {
            return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, undefined, attribute.i18n);
        }
        visitText(text) {
            return new Text(text.value, text.sourceSpan);
        }
        visitExpansion(expansion) {
            return null;
        }
        visitExpansionCase(expansionCase) {
            return null;
        }
    }
    const NON_BINDABLE_VISITOR = new NonBindableVisitor();
    function normalizeAttributeName(attrName) {
        return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;
    }
    function addEvents(events, boundEvents) {
        boundEvents.push(...events.map(e => BoundEvent.fromParsedEvent(e)));
    }
    function isEmptyTextNode(node) {
        return node instanceof Text$2 && node.value.trim().length == 0;
    }
    function isCommentNode(node) {
        return node instanceof Comment;
    }
    function textContents(node) {
        if (node.children.length !== 1 || !(node.children[0] instanceof Text$2)) {
            return null;
        }
        else {
            return node.children[0].value;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var TagType;
    (function (TagType) {
        TagType[TagType["ELEMENT"] = 0] = "ELEMENT";
        TagType[TagType["TEMPLATE"] = 1] = "TEMPLATE";
        TagType[TagType["PROJECTION"] = 2] = "PROJECTION";
    })(TagType || (TagType = {}));
    /**
     * Generates an object that is used as a shared state between parent and all child contexts.
     */
    function setupRegistry() {
        return { getUniqueId: getSeqNumberGenerator(), icus: new Map() };
    }
    /**
     * I18nContext is a helper class which keeps track of all i18n-related aspects
     * (accumulates placeholders, bindings, etc) between i18nStart and i18nEnd instructions.
     *
     * When we enter a nested template, the top-level context is being passed down
     * to the nested component, which uses this context to generate a child instance
     * of I18nContext class (to handle nested template) and at the end, reconciles it back
     * with the parent context.
     *
     * @param index Instruction index of i18nStart, which initiates this context
     * @param ref Reference to a translation const that represents the content if thus context
     * @param level Nestng level defined for child contexts
     * @param templateIndex Instruction index of a template which this context belongs to
     * @param meta Meta information (id, meaning, description, etc) associated with this context
     */
    class I18nContext {
        constructor(index, ref, level = 0, templateIndex = null, meta, registry) {
            this.index = index;
            this.ref = ref;
            this.level = level;
            this.templateIndex = templateIndex;
            this.meta = meta;
            this.registry = registry;
            this.bindings = new Set();
            this.placeholders = new Map();
            this.isEmitted = false;
            this._unresolvedCtxCount = 0;
            this._registry = registry || setupRegistry();
            this.id = this._registry.getUniqueId();
        }
        appendTag(type, node, index, closed) {
            if (node.isVoid && closed) {
                return; // ignore "close" for void tags
            }
            const ph = node.isVoid || !closed ? node.startName : node.closeName;
            const content = { type, index, ctx: this.id, isVoid: node.isVoid, closed };
            updatePlaceholderMap(this.placeholders, ph, content);
        }
        get icus() {
            return this._registry.icus;
        }
        get isRoot() {
            return this.level === 0;
        }
        get isResolved() {
            return this._unresolvedCtxCount === 0;
        }
        getSerializedPlaceholders() {
            const result = new Map();
            this.placeholders.forEach((values, key) => result.set(key, values.map(serializePlaceholderValue)));
            return result;
        }
        // public API to accumulate i18n-related content
        appendBinding(binding) {
            this.bindings.add(binding);
        }
        appendIcu(name, ref) {
            updatePlaceholderMap(this._registry.icus, name, ref);
        }
        appendBoundText(node) {
            const phs = assembleBoundTextPlaceholders(node, this.bindings.size, this.id);
            phs.forEach((values, key) => updatePlaceholderMap(this.placeholders, key, ...values));
        }
        appendTemplate(node, index) {
            // add open and close tags at the same time,
            // since we process nested templates separately
            this.appendTag(TagType.TEMPLATE, node, index, false);
            this.appendTag(TagType.TEMPLATE, node, index, true);
            this._unresolvedCtxCount++;
        }
        appendElement(node, index, closed) {
            this.appendTag(TagType.ELEMENT, node, index, closed);
        }
        appendProjection(node, index) {
            // add open and close tags at the same time,
            // since we process projected content separately
            this.appendTag(TagType.PROJECTION, node, index, false);
            this.appendTag(TagType.PROJECTION, node, index, true);
        }
        /**
         * Generates an instance of a child context based on the root one,
         * when we enter a nested template within I18n section.
         *
         * @param index Instruction index of corresponding i18nStart, which initiates this context
         * @param templateIndex Instruction index of a template which this context belongs to
         * @param meta Meta information (id, meaning, description, etc) associated with this context
         *
         * @returns I18nContext instance
         */
        forkChildContext(index, templateIndex, meta) {
            return new I18nContext(index, this.ref, this.level + 1, templateIndex, meta, this._registry);
        }
        /**
         * Reconciles child context into parent one once the end of the i18n block is reached (i18nEnd).
         *
         * @param context Child I18nContext instance to be reconciled with parent context.
         */
        reconcileChildContext(context) {
            // set the right context id for open and close
            // template tags, so we can use it as sub-block ids
            ['start', 'close'].forEach((op) => {
                const key = context.meta[`${op}Name`];
                const phs = this.placeholders.get(key) || [];
                const tag = phs.find(findTemplateFn(this.id, context.templateIndex));
                if (tag) {
                    tag.ctx = context.id;
                }
            });
            // reconcile placeholders
            const childPhs = context.placeholders;
            childPhs.forEach((values, key) => {
                const phs = this.placeholders.get(key);
                if (!phs) {
                    this.placeholders.set(key, values);
                    return;
                }
                // try to find matching template...
                const tmplIdx = phs.findIndex(findTemplateFn(context.id, context.templateIndex));
                if (tmplIdx >= 0) {
                    // ... if found - replace it with nested template content
                    const isCloseTag = key.startsWith('CLOSE');
                    const isTemplateTag = key.endsWith('NG-TEMPLATE');
                    if (isTemplateTag) {
                        // current template's content is placed before or after
                        // parent template tag, depending on the open/close atrribute
                        phs.splice(tmplIdx + (isCloseTag ? 0 : 1), 0, ...values);
                    }
                    else {
                        const idx = isCloseTag ? values.length - 1 : 0;
                        values[idx].tmpl = phs[tmplIdx];
                        phs.splice(tmplIdx, 1, ...values);
                    }
                }
                else {
                    // ... otherwise just append content to placeholder value
                    phs.push(...values);
                }
                this.placeholders.set(key, phs);
            });
            this._unresolvedCtxCount--;
        }
    }
    //
    // Helper methods
    //
    function wrap(symbol, index, contextId, closed) {
        const state = closed ? '/' : '';
        return wrapI18nPlaceholder(`${state}${symbol}${index}`, contextId);
    }
    function wrapTag(symbol, { index, ctx, isVoid }, closed) {
        return isVoid ? wrap(symbol, index, ctx) + wrap(symbol, index, ctx, true) :
            wrap(symbol, index, ctx, closed);
    }
    function findTemplateFn(ctx, templateIndex) {
        return (token) => typeof token === 'object' && token.type === TagType.TEMPLATE &&
            token.index === templateIndex && token.ctx === ctx;
    }
    function serializePlaceholderValue(value) {
        const element = (data, closed) => wrapTag('#', data, closed);
        const template = (data, closed) => wrapTag('*', data, closed);
        const projection = (data, closed) => wrapTag('!', data, closed);
        switch (value.type) {
            case TagType.ELEMENT:
                // close element tag
                if (value.closed) {
                    return element(value, true) + (value.tmpl ? template(value.tmpl, true) : '');
                }
                // open element tag that also initiates a template
                if (value.tmpl) {
                    return template(value.tmpl) + element(value) +
                        (value.isVoid ? template(value.tmpl, true) : '');
                }
                return element(value);
            case TagType.TEMPLATE:
                return template(value, value.closed);
            case TagType.PROJECTION:
                return projection(value, value.closed);
            default:
                return value;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class IcuSerializerVisitor {
        visitText(text) {
            return text.value;
        }
        visitContainer(container) {
            return container.children.map(child => child.visit(this)).join('');
        }
        visitIcu(icu) {
            const strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);
            const result = `{${icu.expressionPlaceholder}, ${icu.type}, ${strCases.join(' ')}}`;
            return result;
        }
        visitTagPlaceholder(ph) {
            return ph.isVoid ?
                this.formatPh(ph.startName) :
                `${this.formatPh(ph.startName)}${ph.children.map(child => child.visit(this)).join('')}${this.formatPh(ph.closeName)}`;
        }
        visitPlaceholder(ph) {
            return this.formatPh(ph.name);
        }
        visitIcuPlaceholder(ph, context) {
            return this.formatPh(ph.name);
        }
        formatPh(value) {
            return `{${formatI18nPlaceholderName(value, /* useCamelCase */ false)}}`;
        }
    }
    const serializer = new IcuSerializerVisitor();
    function serializeIcuNode(icu) {
        return icu.visit(serializer);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const TAG_TO_PLACEHOLDER_NAMES = {
        'A': 'LINK',
        'B': 'BOLD_TEXT',
        'BR': 'LINE_BREAK',
        'EM': 'EMPHASISED_TEXT',
        'H1': 'HEADING_LEVEL1',
        'H2': 'HEADING_LEVEL2',
        'H3': 'HEADING_LEVEL3',
        'H4': 'HEADING_LEVEL4',
        'H5': 'HEADING_LEVEL5',
        'H6': 'HEADING_LEVEL6',
        'HR': 'HORIZONTAL_RULE',
        'I': 'ITALIC_TEXT',
        'LI': 'LIST_ITEM',
        'LINK': 'MEDIA_LINK',
        'OL': 'ORDERED_LIST',
        'P': 'PARAGRAPH',
        'Q': 'QUOTATION',
        'S': 'STRIKETHROUGH_TEXT',
        'SMALL': 'SMALL_TEXT',
        'SUB': 'SUBSTRIPT',
        'SUP': 'SUPERSCRIPT',
        'TBODY': 'TABLE_BODY',
        'TD': 'TABLE_CELL',
        'TFOOT': 'TABLE_FOOTER',
        'TH': 'TABLE_HEADER_CELL',
        'THEAD': 'TABLE_HEADER',
        'TR': 'TABLE_ROW',
        'TT': 'MONOSPACED_TEXT',
        'U': 'UNDERLINED_TEXT',
        'UL': 'UNORDERED_LIST',
    };
    /**
     * Creates unique names for placeholder with different content.
     *
     * Returns the same placeholder name when the content is identical.
     */
    class PlaceholderRegistry {
        constructor() {
            // Count the occurrence of the base name top generate a unique name
            this._placeHolderNameCounts = {};
            // Maps signature to placeholder names
            this._signatureToName = {};
        }
        getStartTagPlaceholderName(tag, attrs, isVoid) {
            const signature = this._hashTag(tag, attrs, isVoid);
            if (this._signatureToName[signature]) {
                return this._signatureToName[signature];
            }
            const upperTag = tag.toUpperCase();
            const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;
            const name = this._generateUniqueName(isVoid ? baseName : `START_${baseName}`);
            this._signatureToName[signature] = name;
            return name;
        }
        getCloseTagPlaceholderName(tag) {
            const signature = this._hashClosingTag(tag);
            if (this._signatureToName[signature]) {
                return this._signatureToName[signature];
            }
            const upperTag = tag.toUpperCase();
            const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;
            const name = this._generateUniqueName(`CLOSE_${baseName}`);
            this._signatureToName[signature] = name;
            return name;
        }
        getPlaceholderName(name, content) {
            const upperName = name.toUpperCase();
            const signature = `PH: ${upperName}=${content}`;
            if (this._signatureToName[signature]) {
                return this._signatureToName[signature];
            }
            const uniqueName = this._generateUniqueName(upperName);
            this._signatureToName[signature] = uniqueName;
            return uniqueName;
        }
        getUniquePlaceholder(name) {
            return this._generateUniqueName(name.toUpperCase());
        }
        // Generate a hash for a tag - does not take attribute order into account
        _hashTag(tag, attrs, isVoid) {
            const start = `<${tag}`;
            const strAttrs = Object.keys(attrs).sort().map((name) => ` ${name}=${attrs[name]}`).join('');
            const end = isVoid ? '/>' : `></${tag}>`;
            return start + strAttrs + end;
        }
        _hashClosingTag(tag) {
            return this._hashTag(`/${tag}`, {}, false);
        }
        _generateUniqueName(base) {
            const seen = this._placeHolderNameCounts.hasOwnProperty(base);
            if (!seen) {
                this._placeHolderNameCounts[base] = 1;
                return base;
            }
            const id = this._placeHolderNameCounts[base];
            this._placeHolderNameCounts[base] = id + 1;
            return `${base}_${id}`;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const _expParser = new Parser$1(new Lexer());
    /**
     * Returns a function converting html nodes to an i18n Message given an interpolationConfig
     */
    function createI18nMessageFactory(interpolationConfig) {
        const visitor = new _I18nVisitor(_expParser, interpolationConfig);
        return (nodes, meaning, description, customId, visitNodeFn) => visitor.toI18nMessage(nodes, meaning, description, customId, visitNodeFn);
    }
    function noopVisitNodeFn(_html, i18n) {
        return i18n;
    }
    class _I18nVisitor {
        constructor(_expressionParser, _interpolationConfig) {
            this._expressionParser = _expressionParser;
            this._interpolationConfig = _interpolationConfig;
        }
        toI18nMessage(nodes, meaning = '', description = '', customId = '', visitNodeFn) {
            const context = {
                isIcu: nodes.length == 1 && nodes[0] instanceof Expansion,
                icuDepth: 0,
                placeholderRegistry: new PlaceholderRegistry(),
                placeholderToContent: {},
                placeholderToMessage: {},
                visitNodeFn: visitNodeFn || noopVisitNodeFn,
            };
            const i18nodes = visitAll$1(this, nodes, context);
            return new Message(i18nodes, context.placeholderToContent, context.placeholderToMessage, meaning, description, customId);
        }
        visitElement(el, context) {
            const children = visitAll$1(this, el.children, context);
            const attrs = {};
            el.attrs.forEach(attr => {
                // Do not visit the attributes, translatable ones are top-level ASTs
                attrs[attr.name] = attr.value;
            });
            const isVoid = getHtmlTagDefinition(el.name).isVoid;
            const startPhName = context.placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);
            context.placeholderToContent[startPhName] = el.sourceSpan.toString();
            let closePhName = '';
            if (!isVoid) {
                closePhName = context.placeholderRegistry.getCloseTagPlaceholderName(el.name);
                context.placeholderToContent[closePhName] = `</${el.name}>`;
            }
            const node = new TagPlaceholder(el.name, attrs, startPhName, closePhName, children, isVoid, el.sourceSpan);
            return context.visitNodeFn(el, node);
        }
        visitAttribute(attribute, context) {
            const node = this._visitTextWithInterpolation(attribute.value, attribute.sourceSpan, context);
            return context.visitNodeFn(attribute, node);
        }
        visitText(text, context) {
            const node = this._visitTextWithInterpolation(text.value, text.sourceSpan, context);
            return context.visitNodeFn(text, node);
        }
        visitComment(comment, context) {
            return null;
        }
        visitExpansion(icu, context) {
            context.icuDepth++;
            const i18nIcuCases = {};
            const i18nIcu = new Icu$1(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);
            icu.cases.forEach((caze) => {
                i18nIcuCases[caze.value] = new Container(caze.expression.map((node) => node.visit(this, context)), caze.expSourceSpan);
            });
            context.icuDepth--;
            if (context.isIcu || context.icuDepth > 0) {
                // Returns an ICU node when:
                // - the message (vs a part of the message) is an ICU message, or
                // - the ICU message is nested.
                const expPh = context.placeholderRegistry.getUniquePlaceholder(`VAR_${icu.type}`);
                i18nIcu.expressionPlaceholder = expPh;
                context.placeholderToContent[expPh] = icu.switchValue;
                return context.visitNodeFn(icu, i18nIcu);
            }
            // Else returns a placeholder
            // ICU placeholders should not be replaced with their original content but with the their
            // translations.
            // TODO(vicb): add a html.Node -> i18n.Message cache to avoid having to re-create the msg
            const phName = context.placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());
            context.placeholderToMessage[phName] = this.toI18nMessage([icu], '', '', '', undefined);
            const node = new IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);
            return context.visitNodeFn(icu, node);
        }
        visitExpansionCase(_icuCase, _context) {
            throw new Error('Unreachable code');
        }
        _visitTextWithInterpolation(text, sourceSpan, context) {
            const splitInterpolation = this._expressionParser.splitInterpolation(text, sourceSpan.start.toString(), this._interpolationConfig);
            if (!splitInterpolation) {
                // No expression, return a single text
                return new Text$1(text, sourceSpan);
            }
            // Return a group of text + expressions
            const nodes = [];
            const container = new Container(nodes, sourceSpan);
            const { start: sDelimiter, end: eDelimiter } = this._interpolationConfig;
            for (let i = 0; i < splitInterpolation.strings.length - 1; i++) {
                const expression = splitInterpolation.expressions[i];
                const baseName = _extractPlaceholderName(expression) || 'INTERPOLATION';
                const phName = context.placeholderRegistry.getPlaceholderName(baseName, expression);
                if (splitInterpolation.strings[i].length) {
                    // No need to add empty strings
                    nodes.push(new Text$1(splitInterpolation.strings[i], sourceSpan));
                }
                nodes.push(new Placeholder(expression, phName, sourceSpan));
                context.placeholderToContent[phName] = sDelimiter + expression + eDelimiter;
            }
            // The last index contains no expression
            const lastStringIdx = splitInterpolation.strings.length - 1;
            if (splitInterpolation.strings[lastStringIdx].length) {
                nodes.push(new Text$1(splitInterpolation.strings[lastStringIdx], sourceSpan));
            }
            return container;
        }
    }
    const _CUSTOM_PH_EXP = /\/\/[\s\S]*i18n[\s\S]*\([\s\S]*ph[\s\S]*=[\s\S]*("|')([\s\S]*?)\1[\s\S]*\)/g;
    function _extractPlaceholderName(input) {
        return input.split(_CUSTOM_PH_EXP)[2];
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const setI18nRefs = (htmlNode, i18nNode) => {
        if (htmlNode instanceof NodeWithI18n) {
            if (i18nNode instanceof IcuPlaceholder && htmlNode.i18n instanceof Message) {
                // This html node represents an ICU but this is a second processing pass, and the legacy id
                // was computed in the previous pass and stored in the `i18n` property as a message.
                // We are about to wipe out that property so capture the previous message to be reused when
                // generating the message for this ICU later. See `_generateI18nMessage()`.
                i18nNode.previousMessage = htmlNode.i18n;
            }
            htmlNode.i18n = i18nNode;
        }
        return i18nNode;
    };
    /**
     * This visitor walks over HTML parse tree and converts information stored in
     * i18n-related attributes ("i18n" and "i18n-*") into i18n meta object that is
     * stored with other element's and attribute's information.
     */
    class I18nMetaVisitor {
        constructor(interpolationConfig = DEFAULT_INTERPOLATION_CONFIG, keepI18nAttrs = false, enableI18nLegacyMessageIdFormat = false) {
            this.interpolationConfig = interpolationConfig;
            this.keepI18nAttrs = keepI18nAttrs;
            this.enableI18nLegacyMessageIdFormat = enableI18nLegacyMessageIdFormat;
            // whether visited nodes contain i18n information
            this.hasI18nMeta = false;
            // i18n message generation factory
            this._createI18nMessage = createI18nMessageFactory(this.interpolationConfig);
        }
        _generateI18nMessage(nodes, meta = '', visitNodeFn) {
            const { meaning, description, customId } = this._parseMetadata(meta);
            const message = this._createI18nMessage(nodes, meaning, description, customId, visitNodeFn);
            this._setMessageId(message, meta);
            this._setLegacyIds(message, meta);
            return message;
        }
        visitElement(element) {
            if (hasI18nAttrs(element)) {
                this.hasI18nMeta = true;
                const attrs = [];
                const attrsMeta = {};
                for (const attr of element.attrs) {
                    if (attr.name === I18N_ATTR) {
                        // root 'i18n' node attribute
                        const i18n = element.i18n || attr.value;
                        const message = this._generateI18nMessage(element.children, i18n, setI18nRefs);
                        // do not assign empty i18n meta
                        if (message.nodes.length) {
                            element.i18n = message;
                        }
                    }
                    else if (attr.name.startsWith(I18N_ATTR_PREFIX)) {
                        // 'i18n-*' attributes
                        const key = attr.name.slice(I18N_ATTR_PREFIX.length);
                        attrsMeta[key] = attr.value;
                    }
                    else {
                        // non-i18n attributes
                        attrs.push(attr);
                    }
                }
                // set i18n meta for attributes
                if (Object.keys(attrsMeta).length) {
                    for (const attr of attrs) {
                        const meta = attrsMeta[attr.name];
                        // do not create translation for empty attributes
                        if (meta !== undefined && attr.value) {
                            attr.i18n = this._generateI18nMessage([attr], attr.i18n || meta);
                        }
                    }
                }
                if (!this.keepI18nAttrs) {
                    // update element's attributes,
                    // keeping only non-i18n related ones
                    element.attrs = attrs;
                }
            }
            visitAll$1(this, element.children, element.i18n);
            return element;
        }
        visitExpansion(expansion, currentMessage) {
            let message;
            const meta = expansion.i18n;
            this.hasI18nMeta = true;
            if (meta instanceof IcuPlaceholder) {
                // set ICU placeholder name (e.g. "ICU_1"),
                // generated while processing root element contents,
                // so we can reference it when we output translation
                const name = meta.name;
                message = this._generateI18nMessage([expansion], meta);
                const icu = icuFromI18nMessage(message);
                icu.name = name;
            }
            else {
                // ICU is a top level message, try to use metadata from container element if provided via
                // `context` argument. Note: context may not be available for standalone ICUs (without
                // wrapping element), so fallback to ICU metadata in this case.
                message = this._generateI18nMessage([expansion], currentMessage || meta);
            }
            expansion.i18n = message;
            return expansion;
        }
        visitText(text) {
            return text;
        }
        visitAttribute(attribute) {
            return attribute;
        }
        visitComment(comment) {
            return comment;
        }
        visitExpansionCase(expansionCase) {
            return expansionCase;
        }
        /**
         * Parse the general form `meta` passed into extract the explicit metadata needed to create a
         * `Message`.
         *
         * There are three possibilities for the `meta` variable
         * 1) a string from an `i18n` template attribute: parse it to extract the metadata values.
         * 2) a `Message` from a previous processing pass: reuse the metadata values in the message.
         * 4) other: ignore this and just process the message metadata as normal
         *
         * @param meta the bucket that holds information about the message
         * @returns the parsed metadata.
         */
        _parseMetadata(meta) {
            return typeof meta === 'string' ? parseI18nMeta(meta) :
                meta instanceof Message ? meta : {};
        }
        /**
         * Generate (or restore) message id if not specified already.
         */
        _setMessageId(message, meta) {
            if (!message.id) {
                message.id = meta instanceof Message && meta.id || decimalDigest(message);
            }
        }
        /**
         * Update the `message` with a `legacyId` if necessary.
         *
         * @param message the message whose legacy id should be set
         * @param meta information about the message being processed
         */
        _setLegacyIds(message, meta) {
            if (this.enableI18nLegacyMessageIdFormat) {
                message.legacyIds = [computeDigest(message), computeDecimalDigest(message)];
            }
            else if (typeof meta !== 'string') {
                // This occurs if we are doing the 2nd pass after whitespace removal (see `parseTemplate()` in
                // `packages/compiler/src/render3/view/template.ts`).
                // In that case we want to reuse the legacy message generated in the 1st pass (see
                // `setI18nRefs()`).
                const previousMessage = meta instanceof Message ?
                    meta :
                    meta instanceof IcuPlaceholder ? meta.previousMessage : undefined;
                message.legacyIds = previousMessage ? previousMessage.legacyIds : [];
            }
        }
    }
    /** I18n separators for metadata **/
    const I18N_MEANING_SEPARATOR = '|';
    const I18N_ID_SEPARATOR = '@@';
    /**
     * Parses i18n metas like:
     *  - "@@id",
     *  - "description[@@id]",
     *  - "meaning|description[@@id]"
     * and returns an object with parsed output.
     *
     * @param meta String that represents i18n meta
     * @returns Object with id, meaning and description fields
     */
    function parseI18nMeta(meta = '') {
        let customId;
        let meaning;
        let description;
        meta = meta.trim();
        if (meta) {
            const idIndex = meta.indexOf(I18N_ID_SEPARATOR);
            const descIndex = meta.indexOf(I18N_MEANING_SEPARATOR);
            let meaningAndDesc;
            [meaningAndDesc, customId] =
                (idIndex > -1) ? [meta.slice(0, idIndex), meta.slice(idIndex + 2)] : [meta, ''];
            [meaning, description] = (descIndex > -1) ?
                [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] :
                ['', meaningAndDesc];
        }
        return { customId, meaning, description };
    }
    // Converts i18n meta information for a message (id, description, meaning)
    // to a JsDoc statement formatted as expected by the Closure compiler.
    function i18nMetaToDocStmt(meta) {
        const tags = [];
        if (meta.description) {
            tags.push({ tagName: "desc" /* Desc */, text: meta.description });
        }
        if (meta.meaning) {
            tags.push({ tagName: "meaning" /* Meaning */, text: meta.meaning });
        }
        return tags.length == 0 ? null : new JSDocCommentStmt(tags);
    }

    /** Closure uses `goog.getMsg(message)` to lookup translations */
    const GOOG_GET_MSG = 'goog.getMsg';
    function createGoogleGetMsgStatements(variable$1, message, closureVar, params) {
        const messageString = serializeI18nMessageForGetMsg(message);
        const args = [literal(messageString)];
        if (Object.keys(params).length) {
            args.push(mapLiteral(params, true));
        }
        // /**
        //  * @desc description of message
        //  * @meaning meaning of message
        //  */
        // const MSG_... = goog.getMsg(..);
        // I18N_X = MSG_...;
        const statements = [];
        const jsdocComment = i18nMetaToDocStmt(message);
        if (jsdocComment !== null) {
            statements.push(jsdocComment);
        }
        statements.push(closureVar.set(variable(GOOG_GET_MSG).callFn(args)).toConstDecl());
        statements.push(new ExpressionStatement(variable$1.set(closureVar)));
        return statements;
    }
    /**
     * This visitor walks over i18n tree and generates its string representation, including ICUs and
     * placeholders in `{$placeholder}` (for plain messages) or `{PLACEHOLDER}` (inside ICUs) format.
     */
    class GetMsgSerializerVisitor {
        formatPh(value) {
            return `{$${formatI18nPlaceholderName(value)}}`;
        }
        visitText(text) {
            return text.value;
        }
        visitContainer(container) {
            return container.children.map(child => child.visit(this)).join('');
        }
        visitIcu(icu) {
            return serializeIcuNode(icu);
        }
        visitTagPlaceholder(ph) {
            return ph.isVoid ?
                this.formatPh(ph.startName) :
                `${this.formatPh(ph.startName)}${ph.children.map(child => child.visit(this)).join('')}${this.formatPh(ph.closeName)}`;
        }
        visitPlaceholder(ph) {
            return this.formatPh(ph.name);
        }
        visitIcuPlaceholder(ph, context) {
            return this.formatPh(ph.name);
        }
    }
    const serializerVisitor$1 = new GetMsgSerializerVisitor();
    function serializeI18nMessageForGetMsg(message) {
        return message.nodes.map(node => node.visit(serializerVisitor$1, null)).join('');
    }

    function createLocalizeStatements(variable, message, params) {
        const statements = [];
        const { messageParts, placeHolders } = serializeI18nMessageForLocalize(message);
        statements.push(new ExpressionStatement(variable.set(localizedString(message, messageParts, placeHolders, placeHolders.map(ph => params[ph])))));
        return statements;
    }
    class MessagePiece {
        constructor(text) {
            this.text = text;
        }
    }
    class LiteralPiece extends MessagePiece {
    }
    class PlaceholderPiece extends MessagePiece {
        constructor(name) {
            super(formatI18nPlaceholderName(name, /* useCamelCase */ false));
        }
    }
    /**
     * This visitor walks over an i18n tree, capturing literal strings and placeholders.
     *
     * The result can be used for generating the `$localize` tagged template literals.
     */
    class LocalizeSerializerVisitor {
        visitText(text, context) {
            if (context[context.length - 1] instanceof LiteralPiece) {
                // Two literal pieces in a row means that there was some comment node in-between.
                context[context.length - 1].text += text.value;
            }
            else {
                context.push(new LiteralPiece(text.value));
            }
        }
        visitContainer(container, context) {
            container.children.forEach(child => child.visit(this, context));
        }
        visitIcu(icu, context) {
            context.push(new LiteralPiece(serializeIcuNode(icu)));
        }
        visitTagPlaceholder(ph, context) {
            context.push(new PlaceholderPiece(ph.startName));
            if (!ph.isVoid) {
                ph.children.forEach(child => child.visit(this, context));
                context.push(new PlaceholderPiece(ph.closeName));
            }
        }
        visitPlaceholder(ph, context) {
            context.push(new PlaceholderPiece(ph.name));
        }
        visitIcuPlaceholder(ph, context) {
            context.push(new PlaceholderPiece(ph.name));
        }
    }
    const serializerVisitor$2 = new LocalizeSerializerVisitor();
    /**
     * Serialize an i18n message into two arrays: messageParts and placeholders.
     *
     * These arrays will be used to generate `$localize` tagged template literals.
     *
     * @param message The message to be serialized.
     * @returns an object containing the messageParts and placeholders.
     */
    function serializeI18nMessageForLocalize(message) {
        const pieces = [];
        message.nodes.forEach(node => node.visit(serializerVisitor$2, pieces));
        return processMessagePieces(pieces);
    }
    /**
     * Convert the list of serialized MessagePieces into two arrays.
     *
     * One contains the literal string pieces and the other the placeholders that will be replaced by
     * expressions when rendering `$localize` tagged template literals.
     *
     * @param pieces The pieces to process.
     * @returns an object containing the messageParts and placeholders.
     */
    function processMessagePieces(pieces) {
        const messageParts = [];
        const placeHolders = [];
        if (pieces[0] instanceof PlaceholderPiece) {
            // The first piece was a placeholder so we need to add an initial empty message part.
            messageParts.push('');
        }
        for (let i = 0; i < pieces.length; i++) {
            const part = pieces[i];
            if (part instanceof LiteralPiece) {
                messageParts.push(part.text);
            }
            else {
                placeHolders.push(part.text);
                if (pieces[i - 1] instanceof PlaceholderPiece) {
                    // There were two placeholders in a row, so we need to add an empty message part.
                    messageParts.push('');
                }
            }
        }
        if (pieces[pieces.length - 1] instanceof PlaceholderPiece) {
            // The last piece was a placeholder so we need to add a final empty message part.
            messageParts.push('');
        }
        return { messageParts, placeHolders };
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // Selector attribute name of `<ng-content>`
    const NG_CONTENT_SELECT_ATTR$1 = 'select';
    // Attribute name of `ngProjectAs`.
    const NG_PROJECT_AS_ATTR_NAME = 'ngProjectAs';
    // List of supported global targets for event listeners
    const GLOBAL_TARGET_RESOLVERS = new Map([['window', Identifiers$1.resolveWindow], ['document', Identifiers$1.resolveDocument], ['body', Identifiers$1.resolveBody]]);
    const LEADING_TRIVIA_CHARS = [' ', '\n', '\r', '\t'];
    //  if (rf & flags) { .. }
    function renderFlagCheckIfStmt(flags, statements) {
        return ifStmt(variable(RENDER_FLAGS).bitwiseAnd(literal(flags), null, false), statements);
    }
    function prepareEventListenerParameters(eventAst, handlerName = null, scope = null) {
        const { type, name, target, phase, handler } = eventAst;
        if (target && !GLOBAL_TARGET_RESOLVERS.has(target)) {
            throw new Error(`Unexpected global target '${target}' defined for '${name}' event.
        Supported list of global targets: ${Array.from(GLOBAL_TARGET_RESOLVERS.keys())}.`);
        }
        const eventArgumentName = '$event';
        const implicitReceiverAccesses = new Set();
        const implicitReceiverExpr = (scope === null || scope.bindingLevel === 0) ?
            variable(CONTEXT_NAME) :
            scope.getOrCreateSharedContextVar(0);
        const bindingExpr = convertActionBinding(scope, implicitReceiverExpr, handler, 'b', () => error('Unexpected interpolation'), eventAst.handlerSpan, implicitReceiverAccesses);
        const statements = [];
        if (scope) {
            statements.push(...scope.restoreViewStatement());
            statements.push(...scope.variableDeclarations());
        }
        statements.push(...bindingExpr.render3Stmts);
        const eventName = type === 1 /* Animation */ ? prepareSyntheticListenerName(name, phase) : name;
        const fnName = handlerName && sanitizeIdentifier(handlerName);
        const fnArgs = [];
        if (implicitReceiverAccesses.has(eventArgumentName)) {
            fnArgs.push(new FnParam(eventArgumentName, DYNAMIC_TYPE));
        }
        const handlerFn = fn(fnArgs, statements, INFERRED_TYPE, null, fnName);
        const params = [literal(eventName), handlerFn];
        if (target) {
            params.push(literal(false), // `useCapture` flag, defaults to `false`
            importExpr(GLOBAL_TARGET_RESOLVERS.get(target)));
        }
        return params;
    }
    class TemplateDefinitionBuilder {
        constructor(constantPool, parentBindingScope, level = 0, contextName, i18nContext, templateIndex, templateName, directiveMatcher, directives, pipeTypeByName, pipes, _namespace, relativeContextFilePath, i18nUseExternalIds, _constants = []) {
            this.constantPool = constantPool;
            this.level = level;
            this.contextName = contextName;
            this.i18nContext = i18nContext;
            this.templateIndex = templateIndex;
            this.templateName = templateName;
            this.directiveMatcher = directiveMatcher;
            this.directives = directives;
            this.pipeTypeByName = pipeTypeByName;
            this.pipes = pipes;
            this._namespace = _namespace;
            this.i18nUseExternalIds = i18nUseExternalIds;
            this._constants = _constants;
            this._dataIndex = 0;
            this._bindingContext = 0;
            this._prefixCode = [];
            /**
             * List of callbacks to generate creation mode instructions. We store them here as we process
             * the template so bindings in listeners are resolved only once all nodes have been visited.
             * This ensures all local refs and context variables are available for matching.
             */
            this._creationCodeFns = [];
            /**
             * List of callbacks to generate update mode instructions. We store them here as we process
             * the template so bindings are resolved only once all nodes have been visited. This ensures
             * all local refs and context variables are available for matching.
             */
            this._updateCodeFns = [];
            /** Index of the currently-selected node. */
            this._currentIndex = 0;
            /** Temporary variable declarations generated from visiting pipes, literals, etc. */
            this._tempVariables = [];
            /**
             * List of callbacks to build nested templates. Nested templates must not be visited until
             * after the parent template has finished visiting all of its nodes. This ensures that all
             * local ref bindings in nested templates are able to find local ref values if the refs
             * are defined after the template declaration.
             */
            this._nestedTemplateFns = [];
            this._unsupported = unsupported;
            // i18n context local to this template
            this.i18n = null;
            // Number of slots to reserve for pureFunctions
            this._pureFunctionSlots = 0;
            // Number of binding slots
            this._bindingSlots = 0;
            // Projection slots found in the template. Projection slots can distribute projected
            // nodes based on a selector, or can just use the wildcard selector to match
            // all nodes which aren't matching any selector.
            this._ngContentReservedSlots = [];
            // Number of non-default selectors found in all parent templates of this template. We need to
            // track it to properly adjust projection slot index in the `projection` instruction.
            this._ngContentSelectorsOffset = 0;
            // Expression that should be used as implicit receiver when converting template
            // expressions to output AST.
            this._implicitReceiverExpr = null;
            // These should be handled in the template or element directly.
            this.visitReference = invalid$1;
            this.visitVariable = invalid$1;
            this.visitTextAttribute = invalid$1;
            this.visitBoundAttribute = invalid$1;
            this.visitBoundEvent = invalid$1;
            this._bindingScope = parentBindingScope.nestedScope(level);
            // Turn the relative context file path into an identifier by replacing non-alphanumeric
            // characters with underscores.
            this.fileBasedI18nSuffix = relativeContextFilePath.replace(/[^A-Za-z0-9]/g, '_') + '_';
            this._valueConverter = new ValueConverter(constantPool, () => this.allocateDataSlot(), (numSlots) => this.allocatePureFunctionSlots(numSlots), (name, localName, slot, value) => {
                const pipeType = pipeTypeByName.get(name);
                if (pipeType) {
                    this.pipes.add(pipeType);
                }
                this._bindingScope.set(this.level, localName, value);
                this.creationInstruction(null, Identifiers$1.pipe, [literal(slot), literal(name)]);
            });
        }
        buildTemplateFunction(nodes, variables, ngContentSelectorsOffset = 0, i18n) {
            this._ngContentSelectorsOffset = ngContentSelectorsOffset;
            if (this._namespace !== Identifiers$1.namespaceHTML) {
                this.creationInstruction(null, this._namespace);
            }
            // Create variable bindings
            variables.forEach(v => this.registerContextVariables(v));
            // Initiate i18n context in case:
            // - this template has parent i18n context
            // - or the template has i18n meta associated with it,
            //   but it's not initiated by the Element (e.g. <ng-template i18n>)
            const initI18nContext = this.i18nContext ||
                (isI18nRootNode(i18n) && !isSingleI18nIcu(i18n) &&
                    !(isSingleElementTemplate(nodes) && nodes[0].i18n === i18n));
            const selfClosingI18nInstruction = hasTextChildrenOnly(nodes);
            if (initI18nContext) {
                this.i18nStart(null, i18n, selfClosingI18nInstruction);
            }
            // This is the initial pass through the nodes of this template. In this pass, we
            // queue all creation mode and update mode instructions for generation in the second
            // pass. It's necessary to separate the passes to ensure local refs are defined before
            // resolving bindings. We also count bindings in this pass as we walk bound expressions.
            visitAll(this, nodes);
            // Add total binding count to pure function count so pure function instructions are
            // generated with the correct slot offset when update instructions are processed.
            this._pureFunctionSlots += this._bindingSlots;
            // Pipes are walked in the first pass (to enqueue `pipe()` creation instructions and
            // `pipeBind` update instructions), so we have to update the slot offsets manually
            // to account for bindings.
            this._valueConverter.updatePipeSlotOffsets(this._bindingSlots);
            // Nested templates must be processed before creation instructions so template()
            // instructions can be generated with the correct internal const count.
            this._nestedTemplateFns.forEach(buildTemplateFn => buildTemplateFn());
            // Output the `projectionDef` instruction when some `<ng-content>` tags are present.
            // The `projectionDef` instruction is only emitted for the component template and
            // is skipped for nested templates (<ng-template> tags).
            if (this.level === 0 && this._ngContentReservedSlots.length) {
                const parameters = [];
                // By default the `projectionDef` instructions creates one slot for the wildcard
                // selector if no parameters are passed. Therefore we only want to allocate a new
                // array for the projection slots if the default projection slot is not sufficient.
                if (this._ngContentReservedSlots.length > 1 || this._ngContentReservedSlots[0] !== '*') {
                    const r3ReservedSlots = this._ngContentReservedSlots.map(s => s !== '*' ? parseSelectorToR3Selector(s) : s);
                    parameters.push(this.constantPool.getConstLiteral(asLiteral(r3ReservedSlots), true));
                }
                // Since we accumulate ngContent selectors while processing template elements,
                // we *prepend* `projectionDef` to creation instructions block, to put it before
                // any `projection` instructions
                this.creationInstruction(null, Identifiers$1.projectionDef, parameters, /* prepend */ true);
            }
            if (initI18nContext) {
                this.i18nEnd(null, selfClosingI18nInstruction);
            }
            // Generate all the creation mode instructions (e.g. resolve bindings in listeners)
            const creationStatements = this._creationCodeFns.map((fn) => fn());
            // Generate all the update mode instructions (e.g. resolve property or text bindings)
            const updateStatements = this._updateCodeFns.map((fn) => fn());
            //  Variable declaration must occur after binding resolution so we can generate context
            //  instructions that build on each other.
            // e.g. const b = nextContext().$implicit(); const b = nextContext();
            const creationVariables = this._bindingScope.viewSnapshotStatements();
            const updateVariables = this._bindingScope.variableDeclarations().concat(this._tempVariables);
            const creationBlock = creationStatements.length > 0 ?
                [renderFlagCheckIfStmt(1 /* Create */, creationVariables.concat(creationStatements))] :
                [];
            const updateBlock = updateStatements.length > 0 ?
                [renderFlagCheckIfStmt(2 /* Update */, updateVariables.concat(updateStatements))] :
                [];
            return fn(
            // i.e. (rf: RenderFlags, ctx: any)
            [new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], [
                // Temporary variable declarations for query refresh (i.e. let _t: any;)
                ...this._prefixCode,
                // Creating mode (i.e. if (rf & RenderFlags.Create) { ... })
                ...creationBlock,
                // Binding and refresh mode (i.e. if (rf & RenderFlags.Update) {...})
                ...updateBlock,
            ], INFERRED_TYPE, null, this.templateName);
        }
        // LocalResolver
        getLocal(name) {
            return this._bindingScope.get(name);
        }
        // LocalResolver
        notifyImplicitReceiverUse() {
            this._bindingScope.notifyImplicitReceiverUse();
        }
        i18nTranslate(message, params = {}, ref, transformFn) {
            const _ref = ref || variable(this.constantPool.uniqueName(TRANSLATION_PREFIX));
            // Closure Compiler requires const names to start with `MSG_` but disallows any other const to
            // start with `MSG_`. We define a variable starting with `MSG_` just for the `goog.getMsg` call
            const closureVar = this.i18nGenerateClosureVar(message.id);
            const statements = getTranslationDeclStmts(message, _ref, closureVar, params, transformFn);
            this.constantPool.statements.push(...statements);
            return _ref;
        }
        registerContextVariables(variable$1) {
            const scopedName = this._bindingScope.freshReferenceName();
            const retrievalLevel = this.level;
            const lhs = variable(variable$1.name + scopedName);
            this._bindingScope.set(retrievalLevel, variable$1.name, lhs, 1 /* CONTEXT */, (scope, relativeLevel) => {
                let rhs;
                if (scope.bindingLevel === retrievalLevel) {
                    // e.g. ctx
                    rhs = variable(CONTEXT_NAME);
                }
                else {
                    const sharedCtxVar = scope.getSharedContextName(retrievalLevel);
                    // e.g. ctx_r0   OR  x(2);
                    rhs = sharedCtxVar ? sharedCtxVar : generateNextContextExpr(relativeLevel);
                }
                // e.g. const $item$ = x(2).$implicit;
                return [lhs.set(rhs.prop(variable$1.value || IMPLICIT_REFERENCE)).toConstDecl()];
            });
        }
        i18nAppendBindings(expressions) {
            if (expressions.length > 0) {
                expressions.forEach(expression => this.i18n.appendBinding(expression));
            }
        }
        i18nBindProps(props) {
            const bound = {};
            Object.keys(props).forEach(key => {
                const prop = props[key];
                if (prop instanceof Text) {
                    bound[key] = literal(prop.value);
                }
                else {
                    const value = prop.value.visit(this._valueConverter);
                    this.allocateBindingSlots(value);
                    if (value instanceof Interpolation) {
                        const { strings, expressions } = value;
                        const { id, bindings } = this.i18n;
                        const label = assembleI18nBoundString(strings, bindings.size, id);
                        this.i18nAppendBindings(expressions);
                        bound[key] = literal(label);
                    }
                }
            });
            return bound;
        }
        i18nGenerateClosureVar(messageId) {
            let name;
            const suffix = this.fileBasedI18nSuffix.toUpperCase();
            if (this.i18nUseExternalIds) {
                const prefix = getTranslationConstPrefix(`EXTERNAL_`);
                const uniqueSuffix = this.constantPool.uniqueName(suffix);
                name = `${prefix}${sanitizeIdentifier(messageId)}$$${uniqueSuffix}`;
            }
            else {
                const prefix = getTranslationConstPrefix(suffix);
                name = this.constantPool.uniqueName(prefix);
            }
            return variable(name);
        }
        i18nUpdateRef(context) {
            const { icus, meta, isRoot, isResolved, isEmitted } = context;
            if (isRoot && isResolved && !isEmitted && !isSingleI18nIcu(meta)) {
                context.isEmitted = true;
                const placeholders = context.getSerializedPlaceholders();
                let icuMapping = {};
                let params = placeholders.size ? placeholdersToParams(placeholders) : {};
                if (icus.size) {
                    icus.forEach((refs, key) => {
                        if (refs.length === 1) {
                            // if we have one ICU defined for a given
                            // placeholder - just output its reference
                            params[key] = refs[0];
                        }
                        else {
                            // ... otherwise we need to activate post-processing
                            // to replace ICU placeholders with proper values
                            const placeholder = wrapI18nPlaceholder(`${I18N_ICU_MAPPING_PREFIX}${key}`);
                            params[key] = literal(placeholder);
                            icuMapping[key] = literalArr(refs);
                        }
                    });
                }
                // translation requires post processing in 2 cases:
                // - if we have placeholders with multiple values (ex. `START_DIV`: [#1, #2, ...])
                // - if we have multiple ICUs that refer to the same placeholder name
                const needsPostprocessing = Array.from(placeholders.values()).some((value) => value.length > 1) ||
                    Object.keys(icuMapping).length;
                let transformFn;
                if (needsPostprocessing) {
                    transformFn = (raw) => {
                        const args = [raw];
                        if (Object.keys(icuMapping).length) {
                            args.push(mapLiteral(icuMapping, true));
                        }
                        return instruction(null, Identifiers$1.i18nPostprocess, args);
                    };
                }
                this.i18nTranslate(meta, params, context.ref, transformFn);
            }
        }
        i18nStart(span = null, meta, selfClosing) {
            const index = this.allocateDataSlot();
            if (this.i18nContext) {
                this.i18n = this.i18nContext.forkChildContext(index, this.templateIndex, meta);
            }
            else {
                const ref = variable(this.constantPool.uniqueName(TRANSLATION_PREFIX));
                this.i18n = new I18nContext(index, ref, 0, this.templateIndex, meta);
            }
            // generate i18nStart instruction
            const { id, ref } = this.i18n;
            const params = [literal(index), ref];
            if (id > 0) {
                // do not push 3rd argument (sub-block id)
                // into i18nStart call for top level i18n context
                params.push(literal(id));
            }
            this.creationInstruction(span, selfClosing ? Identifiers$1.i18n : Identifiers$1.i18nStart, params);
        }
        i18nEnd(span = null, selfClosing) {
            if (!this.i18n) {
                throw new Error('i18nEnd is executed with no i18n context present');
            }
            if (this.i18nContext) {
                this.i18nContext.reconcileChildContext(this.i18n);
                this.i18nUpdateRef(this.i18nContext);
            }
            else {
                this.i18nUpdateRef(this.i18n);
            }
            // setup accumulated bindings
            const { index, bindings } = this.i18n;
            if (bindings.size) {
                const chainBindings = [];
                bindings.forEach(binding => {
                    chainBindings.push({ sourceSpan: span, value: () => this.convertPropertyBinding(binding) });
                });
                // for i18n block, advance to the most recent element index (by taking the current number of
                // elements and subtracting one) before invoking `i18nExp` instructions, to make sure the
                // necessary lifecycle hooks of components/directives are properly flushed.
                this.updateInstructionChainWithAdvance(this.getConstCount() - 1, Identifiers$1.i18nExp, chainBindings);
                this.updateInstruction(span, Identifiers$1.i18nApply, [literal(index)]);
            }
            if (!selfClosing) {
                this.creationInstruction(span, Identifiers$1.i18nEnd);
            }
            this.i18n = null; // reset local i18n context
        }
        i18nAttributesInstruction(nodeIndex, attrs, sourceSpan) {
            let hasBindings = false;
            const i18nAttrArgs = [];
            const bindings = [];
            attrs.forEach(attr => {
                const message = attr.i18n;
                if (attr instanceof TextAttribute) {
                    i18nAttrArgs.push(literal(attr.name), this.i18nTranslate(message));
                }
                else {
                    const converted = attr.value.visit(this._valueConverter);
                    this.allocateBindingSlots(converted);
                    if (converted instanceof Interpolation) {
                        const placeholders = assembleBoundTextPlaceholders(message);
                        const params = placeholdersToParams(placeholders);
                        i18nAttrArgs.push(literal(attr.name), this.i18nTranslate(message, params));
                        converted.expressions.forEach(expression => {
                            hasBindings = true;
                            bindings.push({
                                sourceSpan,
                                value: () => this.convertPropertyBinding(expression),
                            });
                        });
                    }
                }
            });
            if (bindings.length > 0) {
                this.updateInstructionChainWithAdvance(nodeIndex, Identifiers$1.i18nExp, bindings);
            }
            if (i18nAttrArgs.length > 0) {
                const index = literal(this.allocateDataSlot());
                const args = this.constantPool.getConstLiteral(literalArr(i18nAttrArgs), true);
                this.creationInstruction(sourceSpan, Identifiers$1.i18nAttributes, [index, args]);
                if (hasBindings) {
                    this.updateInstruction(sourceSpan, Identifiers$1.i18nApply, [index]);
                }
            }
        }
        getNamespaceInstruction(namespaceKey) {
            switch (namespaceKey) {
                case 'math':
                    return Identifiers$1.namespaceMathML;
                case 'svg':
                    return Identifiers$1.namespaceSVG;
                default:
                    return Identifiers$1.namespaceHTML;
            }
        }
        addNamespaceInstruction(nsInstruction, element) {
            this._namespace = nsInstruction;
            this.creationInstruction(element.sourceSpan, nsInstruction);
        }
        /**
         * Adds an update instruction for an interpolated property or attribute, such as
         * `prop="{{value}}"` or `attr.title="{{value}}"`
         */
        interpolatedUpdateInstruction(instruction, elementIndex, attrName, input, value, params) {
            this.updateInstructionWithAdvance(elementIndex, input.sourceSpan, instruction, () => [literal(attrName), ...this.getUpdateInstructionArguments(value), ...params]);
        }
        visitContent(ngContent) {
            const slot = this.allocateDataSlot();
            const projectionSlotIdx = this._ngContentSelectorsOffset + this._ngContentReservedSlots.length;
            const parameters = [literal(slot)];
            this._ngContentReservedSlots.push(ngContent.selector);
            const nonContentSelectAttributes = ngContent.attributes.filter(attr => attr.name.toLowerCase() !== NG_CONTENT_SELECT_ATTR$1);
            const attributes = this.getAttributeExpressions(nonContentSelectAttributes, [], []);
            if (attributes.length > 0) {
                parameters.push(literal(projectionSlotIdx), literalArr(attributes));
            }
            else if (projectionSlotIdx !== 0) {
                parameters.push(literal(projectionSlotIdx));
            }
            this.creationInstruction(ngContent.sourceSpan, Identifiers$1.projection, parameters);
            if (this.i18n) {
                this.i18n.appendProjection(ngContent.i18n, slot);
            }
        }
        visitElement(element) {
            const elementIndex = this.allocateDataSlot();
            const stylingBuilder = new StylingBuilder(null);
            let isNonBindableMode = false;
            const isI18nRootElement = isI18nRootNode(element.i18n) && !isSingleI18nIcu(element.i18n);
            const i18nAttrs = [];
            const outputAttrs = [];
            const [namespaceKey, elementName] = splitNsName(element.name);
            const isNgContainer$1 = isNgContainer(element.name);
            // Handle styling, i18n, ngNonBindable attributes
            for (const attr of element.attributes) {
                const { name, value } = attr;
                if (name === NON_BINDABLE_ATTR) {
                    isNonBindableMode = true;
                }
                else if (name === 'style') {
                    stylingBuilder.registerStyleAttr(value);
                }
                else if (name === 'class') {
                    stylingBuilder.registerClassAttr(value);
                }
                else {
                    (attr.i18n ? i18nAttrs : outputAttrs).push(attr);
                }
            }
            // Match directives on non i18n attributes
            this.matchDirectives(element.name, element);
            // Regular element or ng-container creation mode
            const parameters = [literal(elementIndex)];
            if (!isNgContainer$1) {
                parameters.push(literal(elementName));
            }
            // Add the attributes
            const allOtherInputs = [];
            element.inputs.forEach((input) => {
                const stylingInputWasSet = stylingBuilder.registerBoundInput(input);
                if (!stylingInputWasSet) {
                    if (input.type === 0 /* Property */ && input.i18n) {
                        i18nAttrs.push(input);
                    }
                    else {
                        allOtherInputs.push(input);
                    }
                }
            });
            // add attributes for directive and projection matching purposes
            const attributes = this.getAttributeExpressions(outputAttrs, allOtherInputs, element.outputs, stylingBuilder, [], i18nAttrs);
            parameters.push(this.addAttrsToConsts(attributes));
            // local refs (ex.: <div #foo #bar="baz">)
            const refs = this.prepareRefsArray(element.references);
            parameters.push(this.addToConsts(refs));
            const wasInNamespace = this._namespace;
            const currentNamespace = this.getNamespaceInstruction(namespaceKey);
            // If the namespace is changing now, include an instruction to change it
            // during element creation.
            if (currentNamespace !== wasInNamespace) {
                this.addNamespaceInstruction(currentNamespace, element);
            }
            if (this.i18n) {
                this.i18n.appendElement(element.i18n, elementIndex);
            }
            // Note that we do not append text node instructions and ICUs inside i18n section,
            // so we exclude them while calculating whether current element has children
            const hasChildren = (!isI18nRootElement && this.i18n) ? !hasTextChildrenOnly(element.children) :
                element.children.length > 0;
            const createSelfClosingInstruction = !stylingBuilder.hasBindingsWithPipes &&
                element.outputs.length === 0 && i18nAttrs.length === 0 && !hasChildren;
            const createSelfClosingI18nInstruction = !createSelfClosingInstruction && hasTextChildrenOnly(element.children);
            if (createSelfClosingInstruction) {
                this.creationInstruction(element.sourceSpan, isNgContainer$1 ? Identifiers$1.elementContainer : Identifiers$1.element, trimTrailingNulls(parameters));
            }
            else {
                this.creationInstruction(element.sourceSpan, isNgContainer$1 ? Identifiers$1.elementContainerStart : Identifiers$1.elementStart, trimTrailingNulls(parameters));
                if (isNonBindableMode) {
                    this.creationInstruction(element.sourceSpan, Identifiers$1.disableBindings);
                }
                if (i18nAttrs.length > 0) {
                    this.i18nAttributesInstruction(elementIndex, i18nAttrs, element.sourceSpan);
                }
                // Generate Listeners (outputs)
                if (element.outputs.length > 0) {
                    const listeners = element.outputs.map((outputAst) => ({
                        sourceSpan: outputAst.sourceSpan,
                        params: this.prepareListenerParameter(element.name, outputAst, elementIndex)
                    }));
                    this.creationInstructionChain(Identifiers$1.listener, listeners);
                }
                // Note: it's important to keep i18n/i18nStart instructions after i18nAttributes and
                // listeners, to make sure i18nAttributes instruction targets current element at runtime.
                if (isI18nRootElement) {
                    this.i18nStart(element.sourceSpan, element.i18n, createSelfClosingI18nInstruction);
                }
            }
            // the code here will collect all update-level styling instructions and add them to the
            // update block of the template function AOT code. Instructions like `styleProp`,
            // `styleMap`, `classMap`, `classProp`
            // are all generated and assigned in the code below.
            const stylingInstructions = stylingBuilder.buildUpdateLevelInstructions(this._valueConverter);
            const limit = stylingInstructions.length - 1;
            for (let i = 0; i <= limit; i++) {
                const instruction = stylingInstructions[i];
                this._bindingSlots += this.processStylingUpdateInstruction(elementIndex, instruction);
            }
            // the reason why `undefined` is used is because the renderer understands this as a
            // special value to symbolize that there is no RHS to this binding
            // TODO (matsko): revisit this once FW-959 is approached
            const emptyValueBindInstruction = literal(undefined);
            const propertyBindings = [];
            const attributeBindings = [];
            // Generate element input bindings
            allOtherInputs.forEach((input) => {
                const inputType = input.type;
                if (inputType === 4 /* Animation */) {
                    const value = input.value.visit(this._valueConverter);
                    // animation bindings can be presented in the following formats:
                    // 1. [@binding]="fooExp"
                    // 2. [@binding]="{value:fooExp, params:{...}}"
                    // 3. [@binding]
                    // 4. @binding
                    // All formats will be valid for when a synthetic binding is created.
                    // The reasoning for this is because the renderer should get each
                    // synthetic binding value in the order of the array that they are
                    // defined in...
                    const hasValue = value instanceof LiteralPrimitive ? !!value.value : true;
                    this.allocateBindingSlots(value);
                    propertyBindings.push({
                        name: prepareSyntheticPropertyName(input.name),
                        sourceSpan: input.sourceSpan,
                        value: () => hasValue ? this.convertPropertyBinding(value) : emptyValueBindInstruction
                    });
                }
                else {
                    // we must skip attributes with associated i18n context, since these attributes are handled
                    // separately and corresponding `i18nExp` and `i18nApply` instructions will be generated
                    if (input.i18n)
                        return;
                    const value = input.value.visit(this._valueConverter);
                    if (value !== undefined) {
                        const params = [];
                        const [attrNamespace, attrName] = splitNsName(input.name);
                        const isAttributeBinding = inputType === 1 /* Attribute */;
                        const sanitizationRef = resolveSanitizationFn(input.securityContext, isAttributeBinding);
                        if (sanitizationRef)
                            params.push(sanitizationRef);
                        if (attrNamespace) {
                            const namespaceLiteral = literal(attrNamespace);
                            if (sanitizationRef) {
                                params.push(namespaceLiteral);
                            }
                            else {
                                // If there wasn't a sanitization ref, we need to add
                                // an extra param so that we can pass in the namespace.
                                params.push(literal(null), namespaceLiteral);
                            }
                        }
                        this.allocateBindingSlots(value);
                        if (inputType === 0 /* Property */) {
                            if (value instanceof Interpolation) {
                                // prop="{{value}}" and friends
                                this.interpolatedUpdateInstruction(getPropertyInterpolationExpression(value), elementIndex, attrName, input, value, params);
                            }
                            else {
                                // [prop]="value"
                                // Collect all the properties so that we can chain into a single function at the end.
                                propertyBindings.push({
                                    name: attrName,
                                    sourceSpan: input.sourceSpan,
                                    value: () => this.convertPropertyBinding(value),
                                    params
                                });
                            }
                        }
                        else if (inputType === 1 /* Attribute */) {
                            if (value instanceof Interpolation && getInterpolationArgsLength(value) > 1) {
                                // attr.name="text{{value}}" and friends
                                this.interpolatedUpdateInstruction(getAttributeInterpolationExpression(value), elementIndex, attrName, input, value, params);
                            }
                            else {
                                const boundValue = value instanceof Interpolation ? value.expressions[0] : value;
                                // [attr.name]="value" or attr.name="{{value}}"
                                // Collect the attribute bindings so that they can be chained at the end.
                                attributeBindings.push({
                                    name: attrName,
                                    sourceSpan: input.sourceSpan,
                                    value: () => this.convertPropertyBinding(boundValue),
                                    params
                                });
                            }
                        }
                        else {
                            // class prop
                            this.updateInstructionWithAdvance(elementIndex, input.sourceSpan, Identifiers$1.classProp, () => {
                                return [
                                    literal(elementIndex), literal(attrName), this.convertPropertyBinding(value),
                                    ...params
                                ];
                            });
                        }
                    }
                }
            });
            if (propertyBindings.length > 0) {
                this.updateInstructionChainWithAdvance(elementIndex, Identifiers$1.property, propertyBindings);
            }
            if (attributeBindings.length > 0) {
                this.updateInstructionChainWithAdvance(elementIndex, Identifiers$1.attribute, attributeBindings);
            }
            // Traverse element child nodes
            visitAll(this, element.children);
            if (!isI18nRootElement && this.i18n) {
                this.i18n.appendElement(element.i18n, elementIndex, true);
            }
            if (!createSelfClosingInstruction) {
                // Finish element construction mode.
                const span = element.endSourceSpan || element.sourceSpan;
                if (isI18nRootElement) {
                    this.i18nEnd(span, createSelfClosingI18nInstruction);
                }
                if (isNonBindableMode) {
                    this.creationInstruction(span, Identifiers$1.enableBindings);
                }
                this.creationInstruction(span, isNgContainer$1 ? Identifiers$1.elementContainerEnd : Identifiers$1.elementEnd);
            }
        }
        visitTemplate(template) {
            const NG_TEMPLATE_TAG_NAME = 'ng-template';
            const templateIndex = this.allocateDataSlot();
            if (this.i18n) {
                this.i18n.appendTemplate(template.i18n, templateIndex);
            }
            const tagName = sanitizeIdentifier(template.tagName || '');
            const contextName = `${this.contextName}${tagName ? '_' + tagName : ''}_${templateIndex}`;
            const templateName = `${contextName}_Template`;
            const parameters = [
                literal(templateIndex),
                variable(templateName),
                // We don't care about the tag's namespace here, because we infer
                // it based on the parent nodes inside the template instruction.
                literal(template.tagName ? splitNsName(template.tagName)[1] : template.tagName),
            ];
            // find directives matching on a given <ng-template> node
            this.matchDirectives(NG_TEMPLATE_TAG_NAME, template);
            // prepare attributes parameter (including attributes used for directive matching)
            const [i18nStaticAttrs, staticAttrs] = partitionArray(template.attributes, hasI18nMeta);
            const attrsExprs = this.getAttributeExpressions(staticAttrs, template.inputs, template.outputs, undefined /* styles */, template.templateAttrs, i18nStaticAttrs);
            parameters.push(this.addAttrsToConsts(attrsExprs));
            // local refs (ex.: <ng-template #foo>)
            if (template.references && template.references.length) {
                const refs = this.prepareRefsArray(template.references);
                parameters.push(this.addToConsts(refs));
                parameters.push(importExpr(Identifiers$1.templateRefExtractor));
            }
            // Create the template function
            const templateVisitor = new TemplateDefinitionBuilder(this.constantPool, this._bindingScope, this.level + 1, contextName, this.i18n, templateIndex, templateName, this.directiveMatcher, this.directives, this.pipeTypeByName, this.pipes, this._namespace, this.fileBasedI18nSuffix, this.i18nUseExternalIds, this._constants);
            // Nested templates must not be visited until after their parent templates have completed
            // processing, so they are queued here until after the initial pass. Otherwise, we wouldn't
            // be able to support bindings in nested templates to local refs that occur after the
            // template definition. e.g. <div *ngIf="showing">{{ foo }}</div>  <div #foo></div>
            this._nestedTemplateFns.push(() => {
                const templateFunctionExpr = templateVisitor.buildTemplateFunction(template.children, template.variables, this._ngContentReservedSlots.length + this._ngContentSelectorsOffset, template.i18n);
                this.constantPool.statements.push(templateFunctionExpr.toDeclStmt(templateName, null));
                if (templateVisitor._ngContentReservedSlots.length) {
                    this._ngContentReservedSlots.push(...templateVisitor._ngContentReservedSlots);
                }
            });
            // e.g. template(1, MyComp_Template_1)
            this.creationInstruction(template.sourceSpan, Identifiers$1.templateCreate, () => {
                parameters.splice(2, 0, literal(templateVisitor.getConstCount()), literal(templateVisitor.getVarCount()));
                return trimTrailingNulls(parameters);
            });
            // handle property bindings e.g. property('ngForOf', ctx.items), et al;
            this.templatePropertyBindings(templateIndex, template.templateAttrs);
            // Only add normal input/output binding instructions on explicit <ng-template> elements.
            if (template.tagName === NG_TEMPLATE_TAG_NAME) {
                const [i18nInputs, inputs] = partitionArray(template.inputs, hasI18nMeta);
                const i18nAttrs = [...i18nStaticAttrs, ...i18nInputs];
                // Add i18n attributes that may act as inputs to directives. If such attributes are present,
                // generate `i18nAttributes` instruction. Note: we generate it only for explicit <ng-template>
                // elements, in case of inline templates, corresponding instructions will be generated in the
                // nested template function.
                if (i18nAttrs.length > 0) {
                    this.i18nAttributesInstruction(templateIndex, i18nAttrs, template.sourceSpan);
                }
                // Add the input bindings
                if (inputs.length > 0) {
                    this.templatePropertyBindings(templateIndex, inputs);
                }
                // Generate listeners for directive output
                if (template.outputs.length > 0) {
                    const listeners = template.outputs.map((outputAst) => ({
                        sourceSpan: outputAst.sourceSpan,
                        params: this.prepareListenerParameter('ng_template', outputAst, templateIndex)
                    }));
                    this.creationInstructionChain(Identifiers$1.listener, listeners);
                }
            }
        }
        visitBoundText(text) {
            if (this.i18n) {
                const value = text.value.visit(this._valueConverter);
                this.allocateBindingSlots(value);
                if (value instanceof Interpolation) {
                    this.i18n.appendBoundText(text.i18n);
                    this.i18nAppendBindings(value.expressions);
                }
                return;
            }
            const nodeIndex = this.allocateDataSlot();
            this.creationInstruction(text.sourceSpan, Identifiers$1.text, [literal(nodeIndex)]);
            const value = text.value.visit(this._valueConverter);
            this.allocateBindingSlots(value);
            if (value instanceof Interpolation) {
                this.updateInstructionWithAdvance(nodeIndex, text.sourceSpan, getTextInterpolationExpression(value), () => this.getUpdateInstructionArguments(value));
            }
            else {
                error('Text nodes should be interpolated and never bound directly.');
            }
        }
        visitText(text) {
            // when a text element is located within a translatable
            // block, we exclude this text element from instructions set,
            // since it will be captured in i18n content and processed at runtime
            if (!this.i18n) {
                this.creationInstruction(text.sourceSpan, Identifiers$1.text, [literal(this.allocateDataSlot()), literal(text.value)]);
            }
        }
        visitIcu(icu) {
            let initWasInvoked = false;
            // if an ICU was created outside of i18n block, we still treat
            // it as a translatable entity and invoke i18nStart and i18nEnd
            // to generate i18n context and the necessary instructions
            if (!this.i18n) {
                initWasInvoked = true;
                this.i18nStart(null, icu.i18n, true);
            }
            const i18n = this.i18n;
            const vars = this.i18nBindProps(icu.vars);
            const placeholders = this.i18nBindProps(icu.placeholders);
            // output ICU directly and keep ICU reference in context
            const message = icu.i18n;
            // we always need post-processing function for ICUs, to make sure that:
            // - all placeholders in a form of {PLACEHOLDER} are replaced with actual values (note:
            // `goog.getMsg` does not process ICUs and uses the `{PLACEHOLDER}` format for placeholders
            // inside ICUs)
            // - all ICU vars (such as `VAR_SELECT` or `VAR_PLURAL`) are replaced with correct values
            const transformFn = (raw) => {
                const params = Object.assign(Object.assign({}, vars), placeholders);
                const formatted = i18nFormatPlaceholderNames(params, /* useCamelCase */ false);
                return instruction(null, Identifiers$1.i18nPostprocess, [raw, mapLiteral(formatted, true)]);
            };
            // in case the whole i18n message is a single ICU - we do not need to
            // create a separate top-level translation, we can use the root ref instead
            // and make this ICU a top-level translation
            // note: ICU placeholders are replaced with actual values in `i18nPostprocess` function
            // separately, so we do not pass placeholders into `i18nTranslate` function.
            if (isSingleI18nIcu(i18n.meta)) {
                this.i18nTranslate(message, /* placeholders */ {}, i18n.ref, transformFn);
            }
            else {
                // output ICU directly and keep ICU reference in context
                const ref = this.i18nTranslate(message, /* placeholders */ {}, /* ref */ undefined, transformFn);
                i18n.appendIcu(icuFromI18nMessage(message).name, ref);
            }
            if (initWasInvoked) {
                this.i18nEnd(null, true);
            }
            return null;
        }
        allocateDataSlot() {
            return this._dataIndex++;
        }
        getConstCount() {
            return this._dataIndex;
        }
        getVarCount() {
            return this._pureFunctionSlots;
        }
        getConsts() {
            return this._constants;
        }
        getNgContentSelectors() {
            return this._ngContentReservedSlots.length ?
                this.constantPool.getConstLiteral(asLiteral(this._ngContentReservedSlots), true) :
                null;
        }
        bindingContext() {
            return `${this._bindingContext++}`;
        }
        templatePropertyBindings(templateIndex, attrs) {
            const propertyBindings = [];
            attrs.forEach(input => {
                if (input instanceof BoundAttribute) {
                    const value = input.value.visit(this._valueConverter);
                    if (value !== undefined) {
                        this.allocateBindingSlots(value);
                        if (value instanceof Interpolation) {
                            // Params typically contain attribute namespace and value sanitizer, which is applicable
                            // for regular HTML elements, but not applicable for <ng-template> (since props act as
                            // inputs to directives), so keep params array empty.
                            const params = [];
                            // prop="{{value}}" case
                            this.interpolatedUpdateInstruction(getPropertyInterpolationExpression(value), templateIndex, input.name, input, value, params);
                        }
                        else {
                            // [prop]="value" case
                            propertyBindings.push({
                                name: input.name,
                                sourceSpan: input.sourceSpan,
                                value: () => this.convertPropertyBinding(value)
                            });
                        }
                    }
                }
            });
            if (propertyBindings.length > 0) {
                this.updateInstructionChainWithAdvance(templateIndex, Identifiers$1.property, propertyBindings);
            }
        }
        // Bindings must only be resolved after all local refs have been visited, so all
        // instructions are queued in callbacks that execute once the initial pass has completed.
        // Otherwise, we wouldn't be able to support local refs that are defined after their
        // bindings. e.g. {{ foo }} <div #foo></div>
        instructionFn(fns, span, reference, paramsOrFn, prepend = false) {
            fns[prepend ? 'unshift' : 'push'](() => {
                const params = Array.isArray(paramsOrFn) ? paramsOrFn : paramsOrFn();
                return instruction(span, reference, params).toStmt();
            });
        }
        processStylingUpdateInstruction(elementIndex, instruction) {
            let allocateBindingSlots = 0;
            if (instruction) {
                const calls = [];
                instruction.calls.forEach(call => {
                    allocateBindingSlots += call.allocateBindingSlots;
                    calls.push({
                        sourceSpan: call.sourceSpan,
                        value: () => {
                            return call.params(value => (call.supportsInterpolation && value instanceof Interpolation) ?
                                this.getUpdateInstructionArguments(value) :
                                this.convertPropertyBinding(value));
                        }
                    });
                });
                this.updateInstructionChainWithAdvance(elementIndex, instruction.reference, calls);
            }
            return allocateBindingSlots;
        }
        creationInstruction(span, reference, paramsOrFn, prepend) {
            this.instructionFn(this._creationCodeFns, span, reference, paramsOrFn || [], prepend);
        }
        creationInstructionChain(reference, calls) {
            const span = calls.length ? calls[0].sourceSpan : null;
            this._creationCodeFns.push(() => {
                return chainedInstruction(reference, calls.map(call => call.params()), span).toStmt();
            });
        }
        updateInstructionWithAdvance(nodeIndex, span, reference, paramsOrFn) {
            this.addAdvanceInstructionIfNecessary(nodeIndex, span);
            this.updateInstruction(span, reference, paramsOrFn);
        }
        updateInstruction(span, reference, paramsOrFn) {
            this.instructionFn(this._updateCodeFns, span, reference, paramsOrFn || []);
        }
        updateInstructionChain(reference, bindings) {
            const span = bindings.length ? bindings[0].sourceSpan : null;
            this._updateCodeFns.push(() => {
                const calls = bindings.map(property => {
                    const value = property.value();
                    const fnParams = Array.isArray(value) ? value : [value];
                    if (property.params) {
                        fnParams.push(...property.params);
                    }
                    if (property.name) {
                        // We want the property name to always be the first function parameter.
                        fnParams.unshift(literal(property.name));
                    }
                    return fnParams;
                });
                return chainedInstruction(reference, calls, span).toStmt();
            });
        }
        updateInstructionChainWithAdvance(nodeIndex, reference, bindings) {
            this.addAdvanceInstructionIfNecessary(nodeIndex, bindings.length ? bindings[0].sourceSpan : null);
            this.updateInstructionChain(reference, bindings);
        }
        addAdvanceInstructionIfNecessary(nodeIndex, span) {
            if (nodeIndex !== this._currentIndex) {
                const delta = nodeIndex - this._currentIndex;
                if (delta < 1) {
                    throw new Error('advance instruction can only go forwards');
                }
                this.instructionFn(this._updateCodeFns, span, Identifiers$1.advance, [literal(delta)]);
                this._currentIndex = nodeIndex;
            }
        }
        allocatePureFunctionSlots(numSlots) {
            const originalSlots = this._pureFunctionSlots;
            this._pureFunctionSlots += numSlots;
            return originalSlots;
        }
        allocateBindingSlots(value) {
            this._bindingSlots += value instanceof Interpolation ? value.expressions.length : 1;
        }
        /**
         * Gets an expression that refers to the implicit receiver. The implicit
         * receiver is always the root level context.
         */
        getImplicitReceiverExpr() {
            if (this._implicitReceiverExpr) {
                return this._implicitReceiverExpr;
            }
            return this._implicitReceiverExpr = this.level === 0 ?
                variable(CONTEXT_NAME) :
                this._bindingScope.getOrCreateSharedContextVar(0);
        }
        convertPropertyBinding(value) {
            const convertedPropertyBinding = convertPropertyBinding(this, this.getImplicitReceiverExpr(), value, this.bindingContext(), BindingForm.Expression, () => error('Unexpected interpolation'));
            const valExpr = convertedPropertyBinding.currValExpr;
            this._tempVariables.push(...convertedPropertyBinding.stmts);
            return valExpr;
        }
        /**
         * Gets a list of argument expressions to pass to an update instruction expression. Also updates
         * the temp variables state with temp variables that were identified as needing to be created
         * while visiting the arguments.
         * @param value The original expression we will be resolving an arguments list from.
         */
        getUpdateInstructionArguments(value) {
            const { args, stmts } = convertUpdateArguments(this, this.getImplicitReceiverExpr(), value, this.bindingContext());
            this._tempVariables.push(...stmts);
            return args;
        }
        matchDirectives(elementName, elOrTpl) {
            if (this.directiveMatcher) {
                const selector = createCssSelector(elementName, getAttrsForDirectiveMatching(elOrTpl));
                this.directiveMatcher.match(selector, (cssSelector, staticType) => {
                    this.directives.add(staticType);
                });
            }
        }
        /**
         * Prepares all attribute expression values for the `TAttributes` array.
         *
         * The purpose of this function is to properly construct an attributes array that
         * is passed into the `elementStart` (or just `element`) functions. Because there
         * are many different types of attributes, the array needs to be constructed in a
         * special way so that `elementStart` can properly evaluate them.
         *
         * The format looks like this:
         *
         * ```
         * attrs = [prop, value, prop2, value2,
         *   PROJECT_AS, selector,
         *   CLASSES, class1, class2,
         *   STYLES, style1, value1, style2, value2,
         *   BINDINGS, name1, name2, name3,
         *   TEMPLATE, name4, name5, name6,
         *   I18N, name7, name8, ...]
         * ```
         *
         * Note that this function will fully ignore all synthetic (@foo) attribute values
         * because those values are intended to always be generated as property instructions.
         */
        getAttributeExpressions(renderAttributes, inputs, outputs, styles, templateAttrs = [], i18nAttrs = []) {
            const alreadySeen = new Set();
            const attrExprs = [];
            let ngProjectAsAttr;
            renderAttributes.forEach((attr) => {
                if (attr.name === NG_PROJECT_AS_ATTR_NAME) {
                    ngProjectAsAttr = attr;
                }
                attrExprs.push(...getAttributeNameLiterals(attr.name), asLiteral(attr.value));
            });
            // Keep ngProjectAs next to the other name, value pairs so we can verify that we match
            // ngProjectAs marker in the attribute name slot.
            if (ngProjectAsAttr) {
                attrExprs.push(...getNgProjectAsLiteral(ngProjectAsAttr));
            }
            function addAttrExpr(key, value) {
                if (typeof key === 'string') {
                    if (!alreadySeen.has(key)) {
                        attrExprs.push(...getAttributeNameLiterals(key));
                        value !== undefined && attrExprs.push(value);
                        alreadySeen.add(key);
                    }
                }
                else {
                    attrExprs.push(literal(key));
                }
            }
            // it's important that this occurs before BINDINGS and TEMPLATE because once `elementStart`
            // comes across the BINDINGS or TEMPLATE markers then it will continue reading each value as
            // as single property value cell by cell.
            if (styles) {
                styles.populateInitialStylingAttrs(attrExprs);
            }
            if (inputs.length || outputs.length) {
                const attrsLengthBeforeInputs = attrExprs.length;
                for (let i = 0; i < inputs.length; i++) {
                    const input = inputs[i];
                    // We don't want the animation and attribute bindings in the
                    // attributes array since they aren't used for directive matching.
                    if (input.type !== 4 /* Animation */ && input.type !== 1 /* Attribute */) {
                        addAttrExpr(input.name);
                    }
                }
                for (let i = 0; i < outputs.length; i++) {
                    const output = outputs[i];
                    if (output.type !== 1 /* Animation */) {
                        addAttrExpr(output.name);
                    }
                }
                // this is a cheap way of adding the marker only after all the input/output
                // values have been filtered (by not including the animation ones) and added
                // to the expressions. The marker is important because it tells the runtime
                // code that this is where attributes without values start...
                if (attrExprs.length !== attrsLengthBeforeInputs) {
                    attrExprs.splice(attrsLengthBeforeInputs, 0, literal(3 /* Bindings */));
                }
            }
            if (templateAttrs.length) {
                attrExprs.push(literal(4 /* Template */));
                templateAttrs.forEach(attr => addAttrExpr(attr.name));
            }
            if (i18nAttrs.length) {
                attrExprs.push(literal(6 /* I18n */));
                i18nAttrs.forEach(attr => addAttrExpr(attr.name));
            }
            return attrExprs;
        }
        addToConsts(expression) {
            if (isNull(expression)) {
                return TYPED_NULL_EXPR;
            }
            // Try to reuse a literal that's already in the array, if possible.
            for (let i = 0; i < this._constants.length; i++) {
                if (this._constants[i].isEquivalent(expression)) {
                    return literal(i);
                }
            }
            return literal(this._constants.push(expression) - 1);
        }
        addAttrsToConsts(attrs) {
            return attrs.length > 0 ? this.addToConsts(literalArr(attrs)) : TYPED_NULL_EXPR;
        }
        prepareRefsArray(references) {
            if (!references || references.length === 0) {
                return TYPED_NULL_EXPR;
            }
            const refsParam = flatten(references.map(reference => {
                const slot = this.allocateDataSlot();
                // Generate the update temporary.
                const variableName = this._bindingScope.freshReferenceName();
                const retrievalLevel = this.level;
                const lhs = variable(variableName);
                this._bindingScope.set(retrievalLevel, reference.name, lhs, 0 /* DEFAULT */, (scope, relativeLevel) => {
                    // e.g. nextContext(2);
                    const nextContextStmt = relativeLevel > 0 ? [generateNextContextExpr(relativeLevel).toStmt()] : [];
                    // e.g. const $foo$ = reference(1);
                    const refExpr = lhs.set(importExpr(Identifiers$1.reference).callFn([literal(slot)]));
                    return nextContextStmt.concat(refExpr.toConstDecl());
                }, true);
                return [reference.name, reference.value];
            }));
            return asLiteral(refsParam);
        }
        prepareListenerParameter(tagName, outputAst, index) {
            return () => {
                const eventName = outputAst.name;
                const bindingFnName = outputAst.type === 1 /* Animation */ ?
                    // synthetic @listener.foo values are treated the exact same as are standard listeners
                    prepareSyntheticListenerFunctionName(eventName, outputAst.phase) :
                    sanitizeIdentifier(eventName);
                const handlerName = `${this.templateName}_${tagName}_${bindingFnName}_${index}_listener`;
                const scope = this._bindingScope.nestedScope(this._bindingScope.bindingLevel);
                return prepareEventListenerParameters(outputAst, handlerName, scope);
            };
        }
    }
    class ValueConverter extends AstMemoryEfficientTransformer {
        constructor(constantPool, allocateSlot, allocatePureFunctionSlots, definePipe) {
            super();
            this.constantPool = constantPool;
            this.allocateSlot = allocateSlot;
            this.allocatePureFunctionSlots = allocatePureFunctionSlots;
            this.definePipe = definePipe;
            this._pipeBindExprs = [];
        }
        // AstMemoryEfficientTransformer
        visitPipe(pipe, context) {
            // Allocate a slot to create the pipe
            const slot = this.allocateSlot();
            const slotPseudoLocal = `PIPE:${slot}`;
            // Allocate one slot for the result plus one slot per pipe argument
            const pureFunctionSlot = this.allocatePureFunctionSlots(2 + pipe.args.length);
            const target = new PropertyRead(pipe.span, pipe.sourceSpan, pipe.nameSpan, new ImplicitReceiver(pipe.span, pipe.sourceSpan), slotPseudoLocal);
            const { identifier, isVarLength } = pipeBindingCallInfo(pipe.args);
            this.definePipe(pipe.name, slotPseudoLocal, slot, importExpr(identifier));
            const args = [pipe.exp, ...pipe.args];
            const convertedArgs = isVarLength ?
                this.visitAll([new LiteralArray(pipe.span, pipe.sourceSpan, args)]) :
                this.visitAll(args);
            const pipeBindExpr = new FunctionCall(pipe.span, pipe.sourceSpan, target, [
                new LiteralPrimitive(pipe.span, pipe.sourceSpan, slot),
                new LiteralPrimitive(pipe.span, pipe.sourceSpan, pureFunctionSlot),
                ...convertedArgs,
            ]);
            this._pipeBindExprs.push(pipeBindExpr);
            return pipeBindExpr;
        }
        updatePipeSlotOffsets(bindingSlots) {
            this._pipeBindExprs.forEach((pipe) => {
                // update the slot offset arg (index 1) to account for binding slots
                const slotOffset = pipe.args[1];
                slotOffset.value += bindingSlots;
            });
        }
        visitLiteralArray(array, context) {
            return new BuiltinFunctionCall(array.span, array.sourceSpan, this.visitAll(array.expressions), values => {
                // If the literal has calculated (non-literal) elements transform it into
                // calls to literal factories that compose the literal and will cache intermediate
                // values.
                const literal = literalArr(values);
                return getLiteralFactory(this.constantPool, literal, this.allocatePureFunctionSlots);
            });
        }
        visitLiteralMap(map, context) {
            return new BuiltinFunctionCall(map.span, map.sourceSpan, this.visitAll(map.values), values => {
                // If the literal has calculated (non-literal) elements  transform it into
                // calls to literal factories that compose the literal and will cache intermediate
                // values.
                const literal = literalMap(values.map((value, index) => ({ key: map.keys[index].key, value, quoted: map.keys[index].quoted })));
                return getLiteralFactory(this.constantPool, literal, this.allocatePureFunctionSlots);
            });
        }
    }
    // Pipes always have at least one parameter, the value they operate on
    const pipeBindingIdentifiers = [Identifiers$1.pipeBind1, Identifiers$1.pipeBind2, Identifiers$1.pipeBind3, Identifiers$1.pipeBind4];
    function pipeBindingCallInfo(args) {
        const identifier = pipeBindingIdentifiers[args.length];
        return {
            identifier: identifier || Identifiers$1.pipeBindV,
            isVarLength: !identifier,
        };
    }
    const pureFunctionIdentifiers = [
        Identifiers$1.pureFunction0, Identifiers$1.pureFunction1, Identifiers$1.pureFunction2, Identifiers$1.pureFunction3, Identifiers$1.pureFunction4,
        Identifiers$1.pureFunction5, Identifiers$1.pureFunction6, Identifiers$1.pureFunction7, Identifiers$1.pureFunction8
    ];
    function pureFunctionCallInfo(args) {
        const identifier = pureFunctionIdentifiers[args.length];
        return {
            identifier: identifier || Identifiers$1.pureFunctionV,
            isVarLength: !identifier,
        };
    }
    function instruction(span, reference, params) {
        return importExpr(reference, null, span).callFn(params, span);
    }
    // e.g. x(2);
    function generateNextContextExpr(relativeLevelDiff) {
        return importExpr(Identifiers$1.nextContext)
            .callFn(relativeLevelDiff > 1 ? [literal(relativeLevelDiff)] : []);
    }
    function getLiteralFactory(constantPool, literal$1, allocateSlots) {
        const { literalFactory, literalFactoryArguments } = constantPool.getLiteralFactory(literal$1);
        // Allocate 1 slot for the result plus 1 per argument
        const startSlot = allocateSlots(1 + literalFactoryArguments.length);
        const { identifier, isVarLength } = pureFunctionCallInfo(literalFactoryArguments);
        // Literal factories are pure functions that only need to be re-invoked when the parameters
        // change.
        const args = [literal(startSlot), literalFactory];
        if (isVarLength) {
            args.push(literalArr(literalFactoryArguments));
        }
        else {
            args.push(...literalFactoryArguments);
        }
        return importExpr(identifier).callFn(args);
    }
    /**
     * Gets an array of literals that can be added to an expression
     * to represent the name and namespace of an attribute. E.g.
     * `:xlink:href` turns into `[AttributeMarker.NamespaceURI, 'xlink', 'href']`.
     *
     * @param name Name of the attribute, including the namespace.
     */
    function getAttributeNameLiterals(name) {
        const [attributeNamespace, attributeName] = splitNsName(name);
        const nameLiteral = literal(attributeName);
        if (attributeNamespace) {
            return [
                literal(0 /* NamespaceURI */), literal(attributeNamespace), nameLiteral
            ];
        }
        return [nameLiteral];
    }
    /** The prefix used to get a shared context in BindingScope's map. */
    const SHARED_CONTEXT_KEY = '$$shared_ctx$$';
    class BindingScope {
        constructor(bindingLevel = 0, parent = null) {
            this.bindingLevel = bindingLevel;
            this.parent = parent;
            /** Keeps a map from local variables to their BindingData. */
            this.map = new Map();
            this.referenceNameIndex = 0;
            this.restoreViewVariable = null;
        }
        static createRootScope() {
            return new BindingScope().set(0, '$event', variable('$event'));
        }
        get(name) {
            let current = this;
            while (current) {
                let value = current.map.get(name);
                if (value != null) {
                    if (current !== this) {
                        // make a local copy and reset the `declare` state
                        value = {
                            retrievalLevel: value.retrievalLevel,
                            lhs: value.lhs,
                            declareLocalCallback: value.declareLocalCallback,
                            declare: false,
                            priority: value.priority,
                            localRef: value.localRef
                        };
                        // Cache the value locally.
                        this.map.set(name, value);
                        // Possibly generate a shared context var
                        this.maybeGenerateSharedContextVar(value);
                        this.maybeRestoreView(value.retrievalLevel, value.localRef);
                    }
                    if (value.declareLocalCallback && !value.declare) {
                        value.declare = true;
                    }
                    return value.lhs;
                }
                current = current.parent;
            }
            // If we get to this point, we are looking for a property on the top level component
            // - If level === 0, we are on the top and don't need to re-declare `ctx`.
            // - If level > 0, we are in an embedded view. We need to retrieve the name of the
            // local var we used to store the component context, e.g. const $comp$ = x();
            return this.bindingLevel === 0 ? null : this.getComponentProperty(name);
        }
        /**
         * Create a local variable for later reference.
         *
         * @param retrievalLevel The level from which this value can be retrieved
         * @param name Name of the variable.
         * @param lhs AST representing the left hand side of the `let lhs = rhs;`.
         * @param priority The sorting priority of this var
         * @param declareLocalCallback The callback to invoke when declaring this local var
         * @param localRef Whether or not this is a local ref
         */
        set(retrievalLevel, name, lhs, priority = 0 /* DEFAULT */, declareLocalCallback, localRef) {
            if (this.map.has(name)) {
                if (localRef) {
                    // Do not throw an error if it's a local ref and do not update existing value,
                    // so the first defined ref is always returned.
                    return this;
                }
                error(`The name ${name} is already defined in scope to be ${this.map.get(name)}`);
            }
            this.map.set(name, {
                retrievalLevel: retrievalLevel,
                lhs: lhs,
                declare: false,
                declareLocalCallback: declareLocalCallback,
                priority: priority,
                localRef: localRef || false
            });
            return this;
        }
        // Implemented as part of LocalResolver.
        getLocal(name) {
            return this.get(name);
        }
        // Implemented as part of LocalResolver.
        notifyImplicitReceiverUse() {
            if (this.bindingLevel !== 0) {
                // Since the implicit receiver is accessed in an embedded view, we need to
                // ensure that we declare a shared context variable for the current template
                // in the update variables.
                this.map.get(SHARED_CONTEXT_KEY + 0).declare = true;
            }
        }
        nestedScope(level) {
            const newScope = new BindingScope(level, this);
            if (level > 0)
                newScope.generateSharedContextVar(0);
            return newScope;
        }
        /**
         * Gets or creates a shared context variable and returns its expression. Note that
         * this does not mean that the shared variable will be declared. Variables in the
         * binding scope will be only declared if they are used.
         */
        getOrCreateSharedContextVar(retrievalLevel) {
            const bindingKey = SHARED_CONTEXT_KEY + retrievalLevel;
            if (!this.map.has(bindingKey)) {
                this.generateSharedContextVar(retrievalLevel);
            }
            // Shared context variables are always generated as "ReadVarExpr".
            return this.map.get(bindingKey).lhs;
        }
        getSharedContextName(retrievalLevel) {
            const sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + retrievalLevel);
            // Shared context variables are always generated as "ReadVarExpr".
            return sharedCtxObj && sharedCtxObj.declare ? sharedCtxObj.lhs : null;
        }
        maybeGenerateSharedContextVar(value) {
            if (value.priority === 1 /* CONTEXT */ &&
                value.retrievalLevel < this.bindingLevel) {
                const sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + value.retrievalLevel);
                if (sharedCtxObj) {
                    sharedCtxObj.declare = true;
                }
                else {
                    this.generateSharedContextVar(value.retrievalLevel);
                }
            }
        }
        generateSharedContextVar(retrievalLevel) {
            const lhs = variable(CONTEXT_NAME + this.freshReferenceName());
            this.map.set(SHARED_CONTEXT_KEY + retrievalLevel, {
                retrievalLevel: retrievalLevel,
                lhs: lhs,
                declareLocalCallback: (scope, relativeLevel) => {
                    // const ctx_r0 = nextContext(2);
                    return [lhs.set(generateNextContextExpr(relativeLevel)).toConstDecl()];
                },
                declare: false,
                priority: 2 /* SHARED_CONTEXT */,
                localRef: false
            });
        }
        getComponentProperty(name) {
            const componentValue = this.map.get(SHARED_CONTEXT_KEY + 0);
            componentValue.declare = true;
            this.maybeRestoreView(0, false);
            return componentValue.lhs.prop(name);
        }
        maybeRestoreView(retrievalLevel, localRefLookup) {
            // We want to restore the current view in listener fns if:
            // 1 - we are accessing a value in a parent view, which requires walking the view tree rather
            // than using the ctx arg. In this case, the retrieval and binding level will be different.
            // 2 - we are looking up a local ref, which requires restoring the view where the local
            // ref is stored
            if (this.isListenerScope() && (retrievalLevel < this.bindingLevel || localRefLookup)) {
                if (!this.parent.restoreViewVariable) {
                    // parent saves variable to generate a shared `const $s$ = getCurrentView();` instruction
                    this.parent.restoreViewVariable = variable(this.parent.freshReferenceName());
                }
                this.restoreViewVariable = this.parent.restoreViewVariable;
            }
        }
        restoreViewStatement() {
            // restoreView($state$);
            return this.restoreViewVariable ?
                [instruction(null, Identifiers$1.restoreView, [this.restoreViewVariable]).toStmt()] :
                [];
        }
        viewSnapshotStatements() {
            // const $state$ = getCurrentView();
            const getCurrentViewInstruction = instruction(null, Identifiers$1.getCurrentView, []);
            return this.restoreViewVariable ?
                [this.restoreViewVariable.set(getCurrentViewInstruction).toConstDecl()] :
                [];
        }
        isListenerScope() {
            return this.parent && this.parent.bindingLevel === this.bindingLevel;
        }
        variableDeclarations() {
            let currentContextLevel = 0;
            return Array.from(this.map.values())
                .filter(value => value.declare)
                .sort((a, b) => b.retrievalLevel - a.retrievalLevel || b.priority - a.priority)
                .reduce((stmts, value) => {
                const levelDiff = this.bindingLevel - value.retrievalLevel;
                const currStmts = value.declareLocalCallback(this, levelDiff - currentContextLevel);
                currentContextLevel = levelDiff;
                return stmts.concat(currStmts);
            }, []);
        }
        freshReferenceName() {
            let current = this;
            // Find the top scope as it maintains the global reference count
            while (current.parent)
                current = current.parent;
            const ref = `${REFERENCE_PREFIX}${current.referenceNameIndex++}`;
            return ref;
        }
    }
    /**
     * Creates a `CssSelector` given a tag name and a map of attributes
     */
    function createCssSelector(elementName, attributes) {
        const cssSelector = new CssSelector();
        const elementNameNoNs = splitNsName(elementName)[1];
        cssSelector.setElement(elementNameNoNs);
        Object.getOwnPropertyNames(attributes).forEach((name) => {
            const nameNoNs = splitNsName(name)[1];
            const value = attributes[name];
            cssSelector.addAttribute(nameNoNs, value);
            if (name.toLowerCase() === 'class') {
                const classes = value.trim().split(/\s+/);
                classes.forEach(className => cssSelector.addClassName(className));
            }
        });
        return cssSelector;
    }
    /**
     * Creates an array of expressions out of an `ngProjectAs` attributes
     * which can be added to the instruction parameters.
     */
    function getNgProjectAsLiteral(attribute) {
        // Parse the attribute value into a CssSelectorList. Note that we only take the
        // first selector, because we don't support multiple selectors in ngProjectAs.
        const parsedR3Selector = parseSelectorToR3Selector(attribute.value)[0];
        return [literal(5 /* ProjectAs */), asLiteral(parsedR3Selector)];
    }
    /**
     * Gets the instruction to generate for an interpolated property
     * @param interpolation An Interpolation AST
     */
    function getPropertyInterpolationExpression(interpolation) {
        switch (getInterpolationArgsLength(interpolation)) {
            case 1:
                return Identifiers$1.propertyInterpolate;
            case 3:
                return Identifiers$1.propertyInterpolate1;
            case 5:
                return Identifiers$1.propertyInterpolate2;
            case 7:
                return Identifiers$1.propertyInterpolate3;
            case 9:
                return Identifiers$1.propertyInterpolate4;
            case 11:
                return Identifiers$1.propertyInterpolate5;
            case 13:
                return Identifiers$1.propertyInterpolate6;
            case 15:
                return Identifiers$1.propertyInterpolate7;
            case 17:
                return Identifiers$1.propertyInterpolate8;
            default:
                return Identifiers$1.propertyInterpolateV;
        }
    }
    /**
     * Gets the instruction to generate for an interpolated attribute
     * @param interpolation An Interpolation AST
     */
    function getAttributeInterpolationExpression(interpolation) {
        switch (getInterpolationArgsLength(interpolation)) {
            case 3:
                return Identifiers$1.attributeInterpolate1;
            case 5:
                return Identifiers$1.attributeInterpolate2;
            case 7:
                return Identifiers$1.attributeInterpolate3;
            case 9:
                return Identifiers$1.attributeInterpolate4;
            case 11:
                return Identifiers$1.attributeInterpolate5;
            case 13:
                return Identifiers$1.attributeInterpolate6;
            case 15:
                return Identifiers$1.attributeInterpolate7;
            case 17:
                return Identifiers$1.attributeInterpolate8;
            default:
                return Identifiers$1.attributeInterpolateV;
        }
    }
    /**
     * Gets the instruction to generate for interpolated text.
     * @param interpolation An Interpolation AST
     */
    function getTextInterpolationExpression(interpolation) {
        switch (getInterpolationArgsLength(interpolation)) {
            case 1:
                return Identifiers$1.textInterpolate;
            case 3:
                return Identifiers$1.textInterpolate1;
            case 5:
                return Identifiers$1.textInterpolate2;
            case 7:
                return Identifiers$1.textInterpolate3;
            case 9:
                return Identifiers$1.textInterpolate4;
            case 11:
                return Identifiers$1.textInterpolate5;
            case 13:
                return Identifiers$1.textInterpolate6;
            case 15:
                return Identifiers$1.textInterpolate7;
            case 17:
                return Identifiers$1.textInterpolate8;
            default:
                return Identifiers$1.textInterpolateV;
        }
    }
    /**
     * Parse a template into render3 `Node`s and additional metadata, with no other dependencies.
     *
     * @param template text of the template to parse
     * @param templateUrl URL to use for source mapping of the parsed template
     * @param options options to modify how the template is parsed
     */
    function parseTemplate(template, templateUrl, options = {}) {
        const { interpolationConfig, preserveWhitespaces, enableI18nLegacyMessageIdFormat } = options;
        const bindingParser = makeBindingParser(interpolationConfig);
        const htmlParser = new HtmlParser();
        const parseResult = htmlParser.parse(template, templateUrl, Object.assign(Object.assign({ leadingTriviaChars: LEADING_TRIVIA_CHARS }, options), { tokenizeExpansionForms: true }));
        if (parseResult.errors && parseResult.errors.length > 0) {
            return {
                errors: parseResult.errors,
                nodes: [],
                styleUrls: [],
                styles: [],
                ngContentSelectors: []
            };
        }
        let rootNodes = parseResult.rootNodes;
        // process i18n meta information (scan attributes, generate ids)
        // before we run whitespace removal process, because existing i18n
        // extraction process (ng xi18n) relies on a raw content to generate
        // message ids
        const i18nMetaVisitor = new I18nMetaVisitor(interpolationConfig, /* keepI18nAttrs */ !preserveWhitespaces, enableI18nLegacyMessageIdFormat);
        rootNodes = visitAll$1(i18nMetaVisitor, rootNodes);
        if (!preserveWhitespaces) {
            rootNodes = visitAll$1(new WhitespaceVisitor(), rootNodes);
            // run i18n meta visitor again in case whitespaces are removed (because that might affect
            // generated i18n message content) and first pass indicated that i18n content is present in a
            // template. During this pass i18n IDs generated at the first pass will be preserved, so we can
            // mimic existing extraction process (ng xi18n)
            if (i18nMetaVisitor.hasI18nMeta) {
                rootNodes = visitAll$1(new I18nMetaVisitor(interpolationConfig, /* keepI18nAttrs */ false), rootNodes);
            }
        }
        const { nodes, errors, styleUrls, styles, ngContentSelectors } = htmlAstToRender3Ast(rootNodes, bindingParser);
        if (errors && errors.length > 0) {
            return { errors, nodes: [], styleUrls: [], styles: [], ngContentSelectors: [] };
        }
        return { nodes, styleUrls, styles, ngContentSelectors };
    }
    const elementRegistry = new DomElementSchemaRegistry();
    /**
     * Construct a `BindingParser` with a default configuration.
     */
    function makeBindingParser(interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
        return new BindingParser(new IvyParser(new Lexer()), interpolationConfig, elementRegistry, null, []);
    }
    function resolveSanitizationFn(context, isAttribute) {
        switch (context) {
            case SecurityContext.HTML:
                return importExpr(Identifiers$1.sanitizeHtml);
            case SecurityContext.SCRIPT:
                return importExpr(Identifiers$1.sanitizeScript);
            case SecurityContext.STYLE:
                // the compiler does not fill in an instruction for [style.prop?] binding
                // values because the style algorithm knows internally what props are subject
                // to sanitization (only [attr.style] values are explicitly sanitized)
                return isAttribute ? importExpr(Identifiers$1.sanitizeStyle) : null;
            case SecurityContext.URL:
                return importExpr(Identifiers$1.sanitizeUrl);
            case SecurityContext.RESOURCE_URL:
                return importExpr(Identifiers$1.sanitizeResourceUrl);
            default:
                return null;
        }
    }
    function isSingleElementTemplate(children) {
        return children.length === 1 && children[0] instanceof Element;
    }
    function isTextNode(node) {
        return node instanceof Text || node instanceof BoundText || node instanceof Icu;
    }
    function hasTextChildrenOnly(children) {
        return children.every(isTextNode);
    }
    /** Name of the global variable that is used to determine if we use Closure translations or not */
    const NG_I18N_CLOSURE_MODE = 'ngI18nClosureMode';
    /**
     * Generate statements that define a given translation message.
     *
     * ```
     * var I18N_1;
     * if (typeof ngI18nClosureMode !== undefined && ngI18nClosureMode) {
     *     var MSG_EXTERNAL_XXX = goog.getMsg(
     *          "Some message with {$interpolation}!",
     *          { "interpolation": "\uFFFD0\uFFFD" }
     *     );
     *     I18N_1 = MSG_EXTERNAL_XXX;
     * }
     * else {
     *     I18N_1 = $localize`Some message with ${'\uFFFD0\uFFFD'}!`;
     * }
     * ```
     *
     * @param message The original i18n AST message node
     * @param variable The variable that will be assigned the translation, e.g. `I18N_1`.
     * @param closureVar The variable for Closure `goog.getMsg` calls, e.g. `MSG_EXTERNAL_XXX`.
     * @param params Object mapping placeholder names to their values (e.g.
     * `{ "interpolation": "\uFFFD0\uFFFD" }`).
     * @param transformFn Optional transformation function that will be applied to the translation (e.g.
     * post-processing).
     * @returns An array of statements that defined a given translation.
     */
    function getTranslationDeclStmts(message, variable, closureVar, params = {}, transformFn) {
        const statements = [
            declareI18nVariable(variable),
            ifStmt(createClosureModeGuard(), createGoogleGetMsgStatements(variable, message, closureVar, i18nFormatPlaceholderNames(params, /* useCamelCase */ true)), createLocalizeStatements(variable, message, i18nFormatPlaceholderNames(params, /* useCamelCase */ false))),
        ];
        if (transformFn) {
            statements.push(new ExpressionStatement(variable.set(transformFn(variable))));
        }
        return statements;
    }
    /**
     * Create the expression that will be used to guard the closure mode block
     * It is equivalent to:
     *
     * ```
     * typeof ngI18nClosureMode !== undefined && ngI18nClosureMode
     * ```
     */
    function createClosureModeGuard() {
        return typeofExpr(variable(NG_I18N_CLOSURE_MODE))
            .notIdentical(literal('undefined', STRING_TYPE))
            .and(variable(NG_I18N_CLOSURE_MODE));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // This regex matches any binding names that contain the "attr." prefix, e.g. "attr.required"
    // If there is a match, the first matching group will contain the attribute name to bind.
    const ATTR_REGEX = /attr\.([^\]]+)/;
    function baseDirectiveFields(meta, constantPool, bindingParser) {
        const definitionMap = new DefinitionMap();
        const selectors = parseSelectorToR3Selector(meta.selector);
        // e.g. `type: MyDirective`
        definitionMap.set('type', meta.internalType);
        // e.g. `selectors: [['', 'someDir', '']]`
        if (selectors.length > 0) {
            definitionMap.set('selectors', asLiteral(selectors));
        }
        if (meta.queries.length > 0) {
            // e.g. `contentQueries: (rf, ctx, dirIndex) => { ... }
            definitionMap.set('contentQueries', createContentQueriesFunction(meta.queries, constantPool, meta.name));
        }
        if (meta.viewQueries.length) {
            definitionMap.set('viewQuery', createViewQueriesFunction(meta.viewQueries, constantPool, meta.name));
        }
        // e.g. `hostBindings: (rf, ctx) => { ... }
        definitionMap.set('hostBindings', createHostBindingsFunction(meta.host, meta.typeSourceSpan, bindingParser, constantPool, meta.selector || '', meta.name, definitionMap));
        // e.g 'inputs: {a: 'a'}`
        definitionMap.set('inputs', conditionallyCreateMapObjectLiteral(meta.inputs, true));
        // e.g 'outputs: {a: 'a'}`
        definitionMap.set('outputs', conditionallyCreateMapObjectLiteral(meta.outputs));
        if (meta.exportAs !== null) {
            definitionMap.set('exportAs', literalArr(meta.exportAs.map(e => literal(e))));
        }
        return definitionMap;
    }
    /**
     * Add features to the definition map.
     */
    function addFeatures(definitionMap, meta) {
        // e.g. `features: [NgOnChangesFeature]`
        const features = [];
        const providers = meta.providers;
        const viewProviders = meta.viewProviders;
        if (providers || viewProviders) {
            const args = [providers || new LiteralArrayExpr([])];
            if (viewProviders) {
                args.push(viewProviders);
            }
            features.push(importExpr(Identifiers$1.ProvidersFeature).callFn(args));
        }
        if (meta.usesInheritance) {
            features.push(importExpr(Identifiers$1.InheritDefinitionFeature));
        }
        if (meta.fullInheritance) {
            features.push(importExpr(Identifiers$1.CopyDefinitionFeature));
        }
        if (meta.lifecycle.usesOnChanges) {
            features.push(importExpr(Identifiers$1.NgOnChangesFeature));
        }
        if (features.length) {
            definitionMap.set('features', literalArr(features));
        }
    }
    /**
     * Compile a directive for the render3 runtime as defined by the `R3DirectiveMetadata`.
     */
    function compileDirectiveFromMetadata(meta, constantPool, bindingParser) {
        const definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);
        addFeatures(definitionMap, meta);
        const expression = importExpr(Identifiers$1.defineDirective).callFn([definitionMap.toLiteralMap()]);
        const typeParams = createDirectiveTypeParams(meta);
        const type = expressionType(importExpr(Identifiers$1.DirectiveDefWithMeta, typeParams));
        return { expression, type };
    }
    /**
     * Compile a component for the render3 runtime as defined by the `R3ComponentMetadata`.
     */
    function compileComponentFromMetadata(meta, constantPool, bindingParser) {
        const definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);
        addFeatures(definitionMap, meta);
        const selector = meta.selector && CssSelector.parse(meta.selector);
        const firstSelector = selector && selector[0];
        // e.g. `attr: ["class", ".my.app"]`
        // This is optional an only included if the first selector of a component specifies attributes.
        if (firstSelector) {
            const selectorAttributes = firstSelector.getAttrs();
            if (selectorAttributes.length) {
                definitionMap.set('attrs', constantPool.getConstLiteral(literalArr(selectorAttributes.map(value => value != null ? literal(value) : literal(undefined))), 
                /* forceShared */ true));
            }
        }
        // Generate the CSS matcher that recognize directive
        let directiveMatcher = null;
        if (meta.directives.length > 0) {
            const matcher = new SelectorMatcher();
            for (const { selector, expression } of meta.directives) {
                matcher.addSelectables(CssSelector.parse(selector), expression);
            }
            directiveMatcher = matcher;
        }
        // e.g. `template: function MyComponent_Template(_ctx, _cm) {...}`
        const templateTypeName = meta.name;
        const templateName = templateTypeName ? `${templateTypeName}_Template` : null;
        const directivesUsed = new Set();
        const pipesUsed = new Set();
        const changeDetection = meta.changeDetection;
        const template = meta.template;
        const templateBuilder = new TemplateDefinitionBuilder(constantPool, BindingScope.createRootScope(), 0, templateTypeName, null, null, templateName, directiveMatcher, directivesUsed, meta.pipes, pipesUsed, Identifiers$1.namespaceHTML, meta.relativeContextFilePath, meta.i18nUseExternalIds);
        const templateFunctionExpression = templateBuilder.buildTemplateFunction(template.nodes, []);
        // We need to provide this so that dynamically generated components know what
        // projected content blocks to pass through to the component when it is instantiated.
        const ngContentSelectors = templateBuilder.getNgContentSelectors();
        if (ngContentSelectors) {
            definitionMap.set('ngContentSelectors', ngContentSelectors);
        }
        // e.g. `decls: 2`
        definitionMap.set('decls', literal(templateBuilder.getConstCount()));
        // e.g. `vars: 2`
        definitionMap.set('vars', literal(templateBuilder.getVarCount()));
        // e.g. `consts: [['one', 'two'], ['three', 'four']]
        const consts = templateBuilder.getConsts();
        if (consts.length > 0) {
            definitionMap.set('consts', literalArr(consts));
        }
        definitionMap.set('template', templateFunctionExpression);
        // e.g. `directives: [MyDirective]`
        if (directivesUsed.size) {
            let directivesExpr = literalArr(Array.from(directivesUsed));
            if (meta.wrapDirectivesAndPipesInClosure) {
                directivesExpr = fn([], [new ReturnStatement(directivesExpr)]);
            }
            definitionMap.set('directives', directivesExpr);
        }
        // e.g. `pipes: [MyPipe]`
        if (pipesUsed.size) {
            let pipesExpr = literalArr(Array.from(pipesUsed));
            if (meta.wrapDirectivesAndPipesInClosure) {
                pipesExpr = fn([], [new ReturnStatement(pipesExpr)]);
            }
            definitionMap.set('pipes', pipesExpr);
        }
        if (meta.encapsulation === null) {
            meta.encapsulation = ViewEncapsulation.Emulated;
        }
        // e.g. `styles: [str1, str2]`
        if (meta.styles && meta.styles.length) {
            const styleValues = meta.encapsulation == ViewEncapsulation.Emulated ?
                compileStyles(meta.styles, CONTENT_ATTR, HOST_ATTR) :
                meta.styles;
            const strings = styleValues.map(str => constantPool.getConstLiteral(literal(str)));
            definitionMap.set('styles', literalArr(strings));
        }
        else if (meta.encapsulation === ViewEncapsulation.Emulated) {
            // If there is no style, don't generate css selectors on elements
            meta.encapsulation = ViewEncapsulation.None;
        }
        // Only set view encapsulation if it's not the default value
        if (meta.encapsulation !== ViewEncapsulation.Emulated) {
            definitionMap.set('encapsulation', literal(meta.encapsulation));
        }
        // e.g. `animation: [trigger('123', [])]`
        if (meta.animations !== null) {
            definitionMap.set('data', literalMap([{ key: 'animation', value: meta.animations, quoted: false }]));
        }
        // Only set the change detection flag if it's defined and it's not the default.
        if (changeDetection != null && changeDetection !== ChangeDetectionStrategy.Default) {
            definitionMap.set('changeDetection', literal(changeDetection));
        }
        const expression = importExpr(Identifiers$1.defineComponent).callFn([definitionMap.toLiteralMap()]);
        const typeParams = createDirectiveTypeParams(meta);
        typeParams.push(stringArrayAsType(meta.template.ngContentSelectors));
        const type = expressionType(importExpr(Identifiers$1.ComponentDefWithMeta, typeParams));
        return { expression, type };
    }
    function prepareQueryParams(query, constantPool) {
        const parameters = [getQueryPredicate(query, constantPool), literal(query.descendants)];
        if (query.read) {
            parameters.push(query.read);
        }
        return parameters;
    }
    function convertAttributesToExpressions(attributes) {
        const values = [];
        for (let key of Object.getOwnPropertyNames(attributes)) {
            const value = attributes[key];
            values.push(literal(key), value);
        }
        return values;
    }
    // Define and update any content queries
    function createContentQueriesFunction(queries, constantPool, name) {
        const createStatements = [];
        const updateStatements = [];
        const tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);
        for (const query of queries) {
            const queryInstruction = query.static ? Identifiers$1.staticContentQuery : Identifiers$1.contentQuery;
            // creation, e.g. r3.contentQuery(dirIndex, somePredicate, true, null);
            createStatements.push(importExpr(queryInstruction)
                .callFn([variable('dirIndex'), ...prepareQueryParams(query, constantPool)])
                .toStmt());
            // update, e.g. (r3.queryRefresh(tmp = r3.loadQuery()) && (ctx.someDir = tmp));
            const temporary = tempAllocator();
            const getQueryList = importExpr(Identifiers$1.loadQuery).callFn([]);
            const refresh = importExpr(Identifiers$1.queryRefresh).callFn([temporary.set(getQueryList)]);
            const updateDirective = variable(CONTEXT_NAME)
                .prop(query.propertyName)
                .set(query.first ? temporary.prop('first') : temporary);
            updateStatements.push(refresh.and(updateDirective).toStmt());
        }
        const contentQueriesFnName = name ? `${name}_ContentQueries` : null;
        return fn([
            new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null),
            new FnParam('dirIndex', null)
        ], [
            renderFlagCheckIfStmt(1 /* Create */, createStatements),
            renderFlagCheckIfStmt(2 /* Update */, updateStatements)
        ], INFERRED_TYPE, null, contentQueriesFnName);
    }
    function stringAsType(str) {
        return expressionType(literal(str));
    }
    function stringMapAsType(map) {
        const mapValues = Object.keys(map).map(key => {
            const value = Array.isArray(map[key]) ? map[key][0] : map[key];
            return {
                key,
                value: literal(value),
                quoted: true,
            };
        });
        return expressionType(literalMap(mapValues));
    }
    function stringArrayAsType(arr) {
        return arr.length > 0 ? expressionType(literalArr(arr.map(value => literal(value)))) :
            NONE_TYPE;
    }
    function createDirectiveTypeParams(meta) {
        // On the type side, remove newlines from the selector as it will need to fit into a TypeScript
        // string literal, which must be on one line.
        const selectorForType = meta.selector !== null ? meta.selector.replace(/\n/g, '') : null;
        return [
            typeWithParameters(meta.type.type, meta.typeArgumentCount),
            selectorForType !== null ? stringAsType(selectorForType) : NONE_TYPE,
            meta.exportAs !== null ? stringArrayAsType(meta.exportAs) : NONE_TYPE,
            stringMapAsType(meta.inputs),
            stringMapAsType(meta.outputs),
            stringArrayAsType(meta.queries.map(q => q.propertyName)),
        ];
    }
    // Define and update any view queries
    function createViewQueriesFunction(viewQueries, constantPool, name) {
        const createStatements = [];
        const updateStatements = [];
        const tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);
        viewQueries.forEach((query) => {
            const queryInstruction = query.static ? Identifiers$1.staticViewQuery : Identifiers$1.viewQuery;
            // creation, e.g. r3.viewQuery(somePredicate, true);
            const queryDefinition = importExpr(queryInstruction).callFn(prepareQueryParams(query, constantPool));
            createStatements.push(queryDefinition.toStmt());
            // update, e.g. (r3.queryRefresh(tmp = r3.loadQuery()) && (ctx.someDir = tmp));
            const temporary = tempAllocator();
            const getQueryList = importExpr(Identifiers$1.loadQuery).callFn([]);
            const refresh = importExpr(Identifiers$1.queryRefresh).callFn([temporary.set(getQueryList)]);
            const updateDirective = variable(CONTEXT_NAME)
                .prop(query.propertyName)
                .set(query.first ? temporary.prop('first') : temporary);
            updateStatements.push(refresh.and(updateDirective).toStmt());
        });
        const viewQueryFnName = name ? `${name}_Query` : null;
        return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], [
            renderFlagCheckIfStmt(1 /* Create */, createStatements),
            renderFlagCheckIfStmt(2 /* Update */, updateStatements)
        ], INFERRED_TYPE, null, viewQueryFnName);
    }
    // Return a host binding function or null if one is not necessary.
    function createHostBindingsFunction(hostBindingsMetadata, typeSourceSpan, bindingParser, constantPool, selector, name, definitionMap) {
        const bindingContext = variable(CONTEXT_NAME);
        const styleBuilder = new StylingBuilder(bindingContext);
        const { styleAttr, classAttr } = hostBindingsMetadata.specialAttributes;
        if (styleAttr !== undefined) {
            styleBuilder.registerStyleAttr(styleAttr);
        }
        if (classAttr !== undefined) {
            styleBuilder.registerClassAttr(classAttr);
        }
        const createStatements = [];
        const updateStatements = [];
        const hostBindingSourceSpan = typeSourceSpan;
        const directiveSummary = metadataAsSummary(hostBindingsMetadata);
        // Calculate host event bindings
        const eventBindings = bindingParser.createDirectiveHostEventAsts(directiveSummary, hostBindingSourceSpan);
        if (eventBindings && eventBindings.length) {
            const listeners = createHostListeners(eventBindings, name);
            createStatements.push(...listeners);
        }
        // Calculate the host property bindings
        const bindings = bindingParser.createBoundHostProperties(directiveSummary, hostBindingSourceSpan);
        const allOtherBindings = [];
        // We need to calculate the total amount of binding slots required by
        // all the instructions together before any value conversions happen.
        // Value conversions may require additional slots for interpolation and
        // bindings with pipes. These calculates happen after this block.
        let totalHostVarsCount = 0;
        bindings && bindings.forEach((binding) => {
            const name = binding.name;
            const stylingInputWasSet = styleBuilder.registerInputBasedOnName(name, binding.expression, binding.sourceSpan);
            if (stylingInputWasSet) {
                totalHostVarsCount += MIN_STYLING_BINDING_SLOTS_REQUIRED;
            }
            else {
                allOtherBindings.push(binding);
                totalHostVarsCount++;
            }
        });
        let valueConverter;
        const getValueConverter = () => {
            if (!valueConverter) {
                const hostVarsCountFn = (numSlots) => {
                    const originalVarsCount = totalHostVarsCount;
                    totalHostVarsCount += numSlots;
                    return originalVarsCount;
                };
                valueConverter = new ValueConverter(constantPool, () => error('Unexpected node'), // new nodes are illegal here
                hostVarsCountFn, () => error('Unexpected pipe')); // pipes are illegal here
            }
            return valueConverter;
        };
        const propertyBindings = [];
        const attributeBindings = [];
        const syntheticHostBindings = [];
        allOtherBindings.forEach((binding) => {
            // resolve literal arrays and literal objects
            const value = binding.expression.visit(getValueConverter());
            const bindingExpr = bindingFn(bindingContext, value);
            const { bindingName, instruction, isAttribute } = getBindingNameAndInstruction(binding);
            const securityContexts = bindingParser.calcPossibleSecurityContexts(selector, bindingName, isAttribute)
                .filter(context => context !== SecurityContext.NONE);
            let sanitizerFn = null;
            if (securityContexts.length) {
                if (securityContexts.length === 2 &&
                    securityContexts.indexOf(SecurityContext.URL) > -1 &&
                    securityContexts.indexOf(SecurityContext.RESOURCE_URL) > -1) {
                    // Special case for some URL attributes (such as "src" and "href") that may be a part
                    // of different security contexts. In this case we use special santitization function and
                    // select the actual sanitizer at runtime based on a tag name that is provided while
                    // invoking sanitization function.
                    sanitizerFn = importExpr(Identifiers$1.sanitizeUrlOrResourceUrl);
                }
                else {
                    sanitizerFn = resolveSanitizationFn(securityContexts[0], isAttribute);
                }
            }
            const instructionParams = [literal(bindingName), bindingExpr.currValExpr];
            if (sanitizerFn) {
                instructionParams.push(sanitizerFn);
            }
            updateStatements.push(...bindingExpr.stmts);
            if (instruction === Identifiers$1.hostProperty) {
                propertyBindings.push(instructionParams);
            }
            else if (instruction === Identifiers$1.attribute) {
                attributeBindings.push(instructionParams);
            }
            else if (instruction === Identifiers$1.syntheticHostProperty) {
                syntheticHostBindings.push(instructionParams);
            }
            else {
                updateStatements.push(importExpr(instruction).callFn(instructionParams).toStmt());
            }
        });
        if (propertyBindings.length > 0) {
            updateStatements.push(chainedInstruction(Identifiers$1.hostProperty, propertyBindings).toStmt());
        }
        if (attributeBindings.length > 0) {
            updateStatements.push(chainedInstruction(Identifiers$1.attribute, attributeBindings).toStmt());
        }
        if (syntheticHostBindings.length > 0) {
            updateStatements.push(chainedInstruction(Identifiers$1.syntheticHostProperty, syntheticHostBindings).toStmt());
        }
        // since we're dealing with directives/components and both have hostBinding
        // functions, we need to generate a special hostAttrs instruction that deals
        // with both the assignment of styling as well as static attributes to the host
        // element. The instruction below will instruct all initial styling (styling
        // that is inside of a host binding within a directive/component) to be attached
        // to the host element alongside any of the provided host attributes that were
        // collected earlier.
        const hostAttrs = convertAttributesToExpressions(hostBindingsMetadata.attributes);
        styleBuilder.assignHostAttrs(hostAttrs, definitionMap);
        if (styleBuilder.hasBindings) {
            // finally each binding that was registered in the statement above will need to be added to
            // the update block of a component/directive templateFn/hostBindingsFn so that the bindings
            // are evaluated and updated for the element.
            styleBuilder.buildUpdateLevelInstructions(getValueConverter()).forEach(instruction => {
                if (instruction.calls.length > 0) {
                    const calls = [];
                    instruction.calls.forEach(call => {
                        // we subtract a value of `1` here because the binding slot was already allocated
                        // at the top of this method when all the input bindings were counted.
                        totalHostVarsCount +=
                            Math.max(call.allocateBindingSlots - MIN_STYLING_BINDING_SLOTS_REQUIRED, 0);
                        calls.push(convertStylingCall(call, bindingContext, bindingFn));
                    });
                    updateStatements.push(chainedInstruction(instruction.reference, calls).toStmt());
                }
            });
        }
        if (totalHostVarsCount) {
            definitionMap.set('hostVars', literal(totalHostVarsCount));
        }
        if (createStatements.length > 0 || updateStatements.length > 0) {
            const hostBindingsFnName = name ? `${name}_HostBindings` : null;
            const statements = [];
            if (createStatements.length > 0) {
                statements.push(renderFlagCheckIfStmt(1 /* Create */, createStatements));
            }
            if (updateStatements.length > 0) {
                statements.push(renderFlagCheckIfStmt(2 /* Update */, updateStatements));
            }
            return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], statements, INFERRED_TYPE, null, hostBindingsFnName);
        }
        return null;
    }
    function bindingFn(implicit, value) {
        return convertPropertyBinding(null, implicit, value, 'b', BindingForm.Expression, () => error('Unexpected interpolation'));
    }
    function convertStylingCall(call, bindingContext, bindingFn) {
        return call.params(value => bindingFn(bindingContext, value).currValExpr);
    }
    function getBindingNameAndInstruction(binding) {
        let bindingName = binding.name;
        let instruction;
        // Check to see if this is an attr binding or a property binding
        const attrMatches = bindingName.match(ATTR_REGEX);
        if (attrMatches) {
            bindingName = attrMatches[1];
            instruction = Identifiers$1.attribute;
        }
        else {
            if (binding.isAnimation) {
                bindingName = prepareSyntheticPropertyName(bindingName);
                // host bindings that have a synthetic property (e.g. @foo) should always be rendered
                // in the context of the component and not the parent. Therefore there is a special
                // compatibility instruction available for this purpose.
                instruction = Identifiers$1.syntheticHostProperty;
            }
            else {
                instruction = Identifiers$1.hostProperty;
            }
        }
        return { bindingName, instruction, isAttribute: !!attrMatches };
    }
    function createHostListeners(eventBindings, name) {
        const listeners = [];
        const syntheticListeners = [];
        const instructions = [];
        eventBindings.forEach(binding => {
            let bindingName = binding.name && sanitizeIdentifier(binding.name);
            const bindingFnName = binding.type === 1 /* Animation */ ?
                prepareSyntheticListenerFunctionName(bindingName, binding.targetOrPhase) :
                bindingName;
            const handlerName = name && bindingName ? `${name}_${bindingFnName}_HostBindingHandler` : null;
            const params = prepareEventListenerParameters(BoundEvent.fromParsedEvent(binding), handlerName);
            if (binding.type == 1 /* Animation */) {
                syntheticListeners.push(params);
            }
            else {
                listeners.push(params);
            }
        });
        if (syntheticListeners.length > 0) {
            instructions.push(chainedInstruction(Identifiers$1.syntheticHostListener, syntheticListeners).toStmt());
        }
        if (listeners.length > 0) {
            instructions.push(chainedInstruction(Identifiers$1.listener, listeners).toStmt());
        }
        return instructions;
    }
    function metadataAsSummary(meta) {
        // clang-format off
        return {
            // This is used by the BindingParser, which only deals with listeners and properties. There's no
            // need to pass attributes to it.
            hostAttributes: {},
            hostListeners: meta.listeners,
            hostProperties: meta.properties,
        };
        // clang-format on
    }
    const HOST_REG_EXP = /^(?:\[([^\]]+)\])|(?:\(([^\)]+)\))$/;
    function parseHostBindings(host) {
        const attributes = {};
        const listeners = {};
        const properties = {};
        const specialAttributes = {};
        for (const key of Object.keys(host)) {
            const value = host[key];
            const matches = key.match(HOST_REG_EXP);
            if (matches === null) {
                switch (key) {
                    case 'class':
                        if (typeof value !== 'string') {
                            // TODO(alxhub): make this a diagnostic.
                            throw new Error(`Class binding must be string`);
                        }
                        specialAttributes.classAttr = value;
                        break;
                    case 'style':
                        if (typeof value !== 'string') {
                            // TODO(alxhub): make this a diagnostic.
                            throw new Error(`Style binding must be string`);
                        }
                        specialAttributes.styleAttr = value;
                        break;
                    default:
                        if (typeof value === 'string') {
                            attributes[key] = literal(value);
                        }
                        else {
                            attributes[key] = value;
                        }
                }
            }
            else if (matches[1 /* Binding */] != null) {
                if (typeof value !== 'string') {
                    // TODO(alxhub): make this a diagnostic.
                    throw new Error(`Property binding must be string`);
                }
                // synthetic properties (the ones that have a `@` as a prefix)
                // are still treated the same as regular properties. Therefore
                // there is no point in storing them in a separate map.
                properties[matches[1 /* Binding */]] = value;
            }
            else if (matches[2 /* Event */] != null) {
                if (typeof value !== 'string') {
                    // TODO(alxhub): make this a diagnostic.
                    throw new Error(`Event binding must be string`);
                }
                listeners[matches[2 /* Event */]] = value;
            }
        }
        return { attributes, listeners, properties, specialAttributes };
    }
    /**
     * Verifies host bindings and returns the list of errors (if any). Empty array indicates that a
     * given set of host bindings has no errors.
     *
     * @param bindings set of host bindings to verify.
     * @param sourceSpan source span where host bindings were defined.
     * @returns array of errors associated with a given set of host bindings.
     */
    function verifyHostBindings(bindings, sourceSpan) {
        const summary = metadataAsSummary(bindings);
        // TODO: abstract out host bindings verification logic and use it instead of
        // creating events and properties ASTs to detect errors (FW-996)
        const bindingParser = makeBindingParser();
        bindingParser.createDirectiveHostEventAsts(summary, sourceSpan);
        bindingParser.createBoundHostProperties(summary, sourceSpan);
        return bindingParser.errors;
    }
    function compileStyles(styles, selector, hostSelector) {
        const shadowCss = new ShadowCss();
        return styles.map(style => {
            return shadowCss.shimCssText(style, selector, hostSelector);
        });
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An interface for retrieving documents by URL that the compiler uses
     * to load templates.
     */
    class ResourceLoader {
        get(url) {
            return '';
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class CompilerFacadeImpl {
        constructor(jitEvaluator = new JitEvaluator()) {
            this.jitEvaluator = jitEvaluator;
            this.R3ResolvedDependencyType = R3ResolvedDependencyType;
            this.R3FactoryTarget = R3FactoryTarget;
            this.ResourceLoader = ResourceLoader;
            this.elementSchemaRegistry = new DomElementSchemaRegistry();
        }
        compilePipe(angularCoreEnv, sourceMapUrl, facade) {
            const metadata = {
                name: facade.name,
                type: wrapReference(facade.type),
                internalType: new WrappedNodeExpr(facade.type),
                typeArgumentCount: facade.typeArgumentCount,
                deps: convertR3DependencyMetadataArray(facade.deps),
                pipeName: facade.pipeName,
                pure: facade.pure,
            };
            const res = compilePipeFromMetadata(metadata);
            return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);
        }
        compileInjectable(angularCoreEnv, sourceMapUrl, facade) {
            const { expression, statements } = compileInjectable({
                name: facade.name,
                type: wrapReference(facade.type),
                internalType: new WrappedNodeExpr(facade.type),
                typeArgumentCount: facade.typeArgumentCount,
                providedIn: computeProvidedIn(facade.providedIn),
                useClass: wrapExpression(facade, USE_CLASS),
                useFactory: wrapExpression(facade, USE_FACTORY),
                useValue: wrapExpression(facade, USE_VALUE),
                useExisting: wrapExpression(facade, USE_EXISTING),
                userDeps: convertR3DependencyMetadataArray(facade.userDeps) || undefined,
            });
            return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);
        }
        compileInjector(angularCoreEnv, sourceMapUrl, facade) {
            const meta = {
                name: facade.name,
                type: wrapReference(facade.type),
                internalType: new WrappedNodeExpr(facade.type),
                deps: convertR3DependencyMetadataArray(facade.deps),
                providers: new WrappedNodeExpr(facade.providers),
                imports: facade.imports.map(i => new WrappedNodeExpr(i)),
            };
            const res = compileInjector(meta);
            return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, res.statements);
        }
        compileNgModule(angularCoreEnv, sourceMapUrl, facade) {
            const meta = {
                type: wrapReference(facade.type),
                internalType: new WrappedNodeExpr(facade.type),
                adjacentType: new WrappedNodeExpr(facade.type),
                bootstrap: facade.bootstrap.map(wrapReference),
                declarations: facade.declarations.map(wrapReference),
                imports: facade.imports.map(wrapReference),
                exports: facade.exports.map(wrapReference),
                emitInline: true,
                containsForwardDecls: false,
                schemas: facade.schemas ? facade.schemas.map(wrapReference) : null,
                id: facade.id ? new WrappedNodeExpr(facade.id) : null,
            };
            const res = compileNgModule(meta);
            return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);
        }
        compileDirective(angularCoreEnv, sourceMapUrl, facade) {
            const constantPool = new ConstantPool();
            const bindingParser = makeBindingParser();
            const meta = convertDirectiveFacadeToMetadata(facade);
            const res = compileDirectiveFromMetadata(meta, constantPool, bindingParser);
            return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);
        }
        compileComponent(angularCoreEnv, sourceMapUrl, facade) {
            // The ConstantPool is a requirement of the JIT'er.
            const constantPool = new ConstantPool();
            const interpolationConfig = facade.interpolation ?
                InterpolationConfig.fromArray(facade.interpolation) :
                DEFAULT_INTERPOLATION_CONFIG;
            // Parse the template and check for errors.
            const template = parseTemplate(facade.template, sourceMapUrl, { preserveWhitespaces: facade.preserveWhitespaces, interpolationConfig });
            if (template.errors !== undefined) {
                const errors = template.errors.map(err => err.toString()).join(', ');
                throw new Error(`Errors during JIT compilation of template for ${facade.name}: ${errors}`);
            }
            // Compile the component metadata, including template, into an expression.
            // TODO(alxhub): implement inputs, outputs, queries, etc.
            const metadata = Object.assign(Object.assign(Object.assign({}, facade), convertDirectiveFacadeToMetadata(facade)), { selector: facade.selector || this.elementSchemaRegistry.getDefaultComponentElementName(), template, wrapDirectivesAndPipesInClosure: false, styles: [...facade.styles, ...template.styles], encapsulation: facade.encapsulation, interpolation: interpolationConfig, changeDetection: facade.changeDetection, animations: facade.animations != null ? new WrappedNodeExpr(facade.animations) : null, viewProviders: facade.viewProviders != null ? new WrappedNodeExpr(facade.viewProviders) :
                    null, relativeContextFilePath: '', i18nUseExternalIds: true });
            const res = compileComponentFromMetadata(metadata, constantPool, makeBindingParser(interpolationConfig));
            const jitExpressionSourceMap = `ng:///${facade.name}.js`;
            return this.jitExpression(res.expression, angularCoreEnv, jitExpressionSourceMap, constantPool.statements);
        }
        compileFactory(angularCoreEnv, sourceMapUrl, meta) {
            const factoryRes = compileFactoryFunction({
                name: meta.name,
                type: wrapReference(meta.type),
                internalType: new WrappedNodeExpr(meta.type),
                typeArgumentCount: meta.typeArgumentCount,
                deps: convertR3DependencyMetadataArray(meta.deps),
                injectFn: meta.injectFn === 'directiveInject' ? Identifiers.directiveInject :
                    Identifiers.inject,
                target: meta.target,
            });
            return this.jitExpression(factoryRes.factory, angularCoreEnv, sourceMapUrl, factoryRes.statements);
        }
        createParseSourceSpan(kind, typeName, sourceUrl) {
            return r3JitTypeSourceSpan(kind, typeName, sourceUrl);
        }
        /**
         * JIT compiles an expression and returns the result of executing that expression.
         *
         * @param def the definition which will be compiled and executed to get the value to patch
         * @param context an object map of @angular/core symbol names to symbols which will be available
         * in the context of the compiled expression
         * @param sourceUrl a URL to use for the source map of the compiled expression
         * @param preStatements a collection of statements that should be evaluated before the expression.
         */
        jitExpression(def, context, sourceUrl, preStatements) {
            // The ConstantPool may contain Statements which declare variables used in the final expression.
            // Therefore, its statements need to precede the actual JIT operation. The final statement is a
            // declaration of $def which is set to the expression being compiled.
            const statements = [
                ...preStatements,
                new DeclareVarStmt('$def', def, undefined, [StmtModifier.Exported]),
            ];
            const res = this.jitEvaluator.evaluateStatements(sourceUrl, statements, new R3JitReflector(context), /* enableSourceMaps */ true);
            return res['$def'];
        }
    }
    const USE_CLASS = Object.keys({ useClass: null })[0];
    const USE_FACTORY = Object.keys({ useFactory: null })[0];
    const USE_VALUE = Object.keys({ useValue: null })[0];
    const USE_EXISTING = Object.keys({ useExisting: null })[0];
    const wrapReference = function (value) {
        const wrapped = new WrappedNodeExpr(value);
        return { value: wrapped, type: wrapped };
    };
    function convertToR3QueryMetadata(facade) {
        return Object.assign(Object.assign({}, facade), { predicate: Array.isArray(facade.predicate) ? facade.predicate :
                new WrappedNodeExpr(facade.predicate), read: facade.read ? new WrappedNodeExpr(facade.read) : null, static: facade.static });
    }
    function convertDirectiveFacadeToMetadata(facade) {
        const inputsFromMetadata = parseInputOutputs(facade.inputs || []);
        const outputsFromMetadata = parseInputOutputs(facade.outputs || []);
        const propMetadata = facade.propMetadata;
        const inputsFromType = {};
        const outputsFromType = {};
        for (const field in propMetadata) {
            if (propMetadata.hasOwnProperty(field)) {
                propMetadata[field].forEach(ann => {
                    if (isInput(ann)) {
                        inputsFromType[field] =
                            ann.bindingPropertyName ? [ann.bindingPropertyName, field] : field;
                    }
                    else if (isOutput(ann)) {
                        outputsFromType[field] = ann.bindingPropertyName || field;
                    }
                });
            }
        }
        return Object.assign(Object.assign({}, facade), { typeSourceSpan: facade.typeSourceSpan, type: wrapReference(facade.type), internalType: new WrappedNodeExpr(facade.type), deps: convertR3DependencyMetadataArray(facade.deps), host: extractHostBindings(facade.propMetadata, facade.typeSourceSpan, facade.host), inputs: Object.assign(Object.assign({}, inputsFromMetadata), inputsFromType), outputs: Object.assign(Object.assign({}, outputsFromMetadata), outputsFromType), queries: facade.queries.map(convertToR3QueryMetadata), providers: facade.providers != null ? new WrappedNodeExpr(facade.providers) : null, viewQueries: facade.viewQueries.map(convertToR3QueryMetadata), fullInheritance: false });
    }
    function wrapExpression(obj, property) {
        if (obj.hasOwnProperty(property)) {
            return new WrappedNodeExpr(obj[property]);
        }
        else {
            return undefined;
        }
    }
    function computeProvidedIn(providedIn) {
        if (providedIn == null || typeof providedIn === 'string') {
            return new LiteralExpr(providedIn);
        }
        else {
            return new WrappedNodeExpr(providedIn);
        }
    }
    function convertR3DependencyMetadata(facade) {
        let tokenExpr;
        if (facade.token === null) {
            tokenExpr = new LiteralExpr(null);
        }
        else if (facade.resolved === R3ResolvedDependencyType.Attribute) {
            tokenExpr = new LiteralExpr(facade.token);
        }
        else {
            tokenExpr = new WrappedNodeExpr(facade.token);
        }
        return {
            token: tokenExpr,
            attribute: null,
            resolved: facade.resolved,
            host: facade.host,
            optional: facade.optional,
            self: facade.self,
            skipSelf: facade.skipSelf,
        };
    }
    function convertR3DependencyMetadataArray(facades) {
        return facades == null ? null : facades.map(convertR3DependencyMetadata);
    }
    function extractHostBindings(propMetadata, sourceSpan, host) {
        // First parse the declarations from the metadata.
        const bindings = parseHostBindings(host || {});
        // After that check host bindings for errors
        const errors = verifyHostBindings(bindings, sourceSpan);
        if (errors.length) {
            throw new Error(errors.map((error) => error.msg).join('\n'));
        }
        // Next, loop over the properties of the object, looking for @HostBinding and @HostListener.
        for (const field in propMetadata) {
            if (propMetadata.hasOwnProperty(field)) {
                propMetadata[field].forEach(ann => {
                    if (isHostBinding(ann)) {
                        bindings.properties[ann.hostPropertyName || field] = field;
                    }
                    else if (isHostListener(ann)) {
                        bindings.listeners[ann.eventName || field] = `${field}(${(ann.args || []).join(',')})`;
                    }
                });
            }
        }
        return bindings;
    }
    function isHostBinding(value) {
        return value.ngMetadataName === 'HostBinding';
    }
    function isHostListener(value) {
        return value.ngMetadataName === 'HostListener';
    }
    function isInput(value) {
        return value.ngMetadataName === 'Input';
    }
    function isOutput(value) {
        return value.ngMetadataName === 'Output';
    }
    function parseInputOutputs(values) {
        return values.reduce((map, value) => {
            const [field, property] = value.split(',').map(piece => piece.trim());
            map[field] = property || field;
            return map;
        }, {});
    }
    function publishFacade(global) {
        const ng = global.ng || (global.ng = {});
        ng.compilerFacade = new CompilerFacadeImpl();
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const VERSION$1 = new Version('10.0.14');

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var _VisitorMode;
    (function (_VisitorMode) {
        _VisitorMode[_VisitorMode["Extract"] = 0] = "Extract";
        _VisitorMode[_VisitorMode["Merge"] = 1] = "Merge";
    })(_VisitorMode || (_VisitorMode = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class XmlTagDefinition {
        constructor() {
            this.closedByParent = false;
            this.contentType = TagContentType.PARSABLE_DATA;
            this.isVoid = false;
            this.ignoreFirstLf = false;
            this.canSelfClose = true;
        }
        requireExtraParent(currentParent) {
            return false;
        }
        isClosedByChild(name) {
            return false;
        }
    }
    const _TAG_DEFINITION = new XmlTagDefinition();

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var LifecycleHooks;
    (function (LifecycleHooks) {
        LifecycleHooks[LifecycleHooks["OnInit"] = 0] = "OnInit";
        LifecycleHooks[LifecycleHooks["OnDestroy"] = 1] = "OnDestroy";
        LifecycleHooks[LifecycleHooks["DoCheck"] = 2] = "DoCheck";
        LifecycleHooks[LifecycleHooks["OnChanges"] = 3] = "OnChanges";
        LifecycleHooks[LifecycleHooks["AfterContentInit"] = 4] = "AfterContentInit";
        LifecycleHooks[LifecycleHooks["AfterContentChecked"] = 5] = "AfterContentChecked";
        LifecycleHooks[LifecycleHooks["AfterViewInit"] = 6] = "AfterViewInit";
        LifecycleHooks[LifecycleHooks["AfterViewChecked"] = 7] = "AfterViewChecked";
    })(LifecycleHooks || (LifecycleHooks = {}));
    const LIFECYCLE_HOOKS_VALUES = [
        LifecycleHooks.OnInit, LifecycleHooks.OnDestroy, LifecycleHooks.DoCheck, LifecycleHooks.OnChanges,
        LifecycleHooks.AfterContentInit, LifecycleHooks.AfterContentChecked, LifecycleHooks.AfterViewInit,
        LifecycleHooks.AfterViewChecked
    ];

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const LOG_VAR = variable('_l');

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const LOG_VAR$1 = variable('_l');
    const VIEW_VAR = variable('_v');
    const CHECK_VAR = variable('_ck');
    const COMP_VAR = variable('_co');
    const EVENT_NAME_VAR = variable('en');
    const ALLOW_DEFAULT_VAR = variable(`ad`);

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * The index of each URI component in the return value of goog.uri.utils.split.
     * @enum {number}
     */
    var _ComponentIndex;
    (function (_ComponentIndex) {
        _ComponentIndex[_ComponentIndex["Scheme"] = 1] = "Scheme";
        _ComponentIndex[_ComponentIndex["UserInfo"] = 2] = "UserInfo";
        _ComponentIndex[_ComponentIndex["Domain"] = 3] = "Domain";
        _ComponentIndex[_ComponentIndex["Port"] = 4] = "Port";
        _ComponentIndex[_ComponentIndex["Path"] = 5] = "Path";
        _ComponentIndex[_ComponentIndex["QueryData"] = 6] = "QueryData";
        _ComponentIndex[_ComponentIndex["Fragment"] = 7] = "Fragment";
    })(_ComponentIndex || (_ComponentIndex = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Processes `Target`s with a given set of directives and performs a binding operation, which
     * returns an object similar to TypeScript's `ts.TypeChecker` that contains knowledge about the
     * target.
     */
    class R3TargetBinder {
        constructor(directiveMatcher) {
            this.directiveMatcher = directiveMatcher;
        }
        /**
         * Perform a binding operation on the given `Target` and return a `BoundTarget` which contains
         * metadata about the types referenced in the template.
         */
        bind(target) {
            if (!target.template) {
                // TODO(alxhub): handle targets which contain things like HostBindings, etc.
                throw new Error('Binding without a template not yet supported');
            }
            // First, parse the template into a `Scope` structure. This operation captures the syntactic
            // scopes in the template and makes them available for later use.
            const scope = Scope.apply(target.template);
            // Next, perform directive matching on the template using the `DirectiveBinder`. This returns:
            //   - directives: Map of nodes (elements & ng-templates) to the directives on them.
            //   - bindings: Map of inputs, outputs, and attributes to the directive/element that claims
            //     them. TODO(alxhub): handle multiple directives claiming an input/output/etc.
            //   - references: Map of #references to their targets.
            const { directives, bindings, references } = DirectiveBinder.apply(target.template, this.directiveMatcher);
            // Finally, run the TemplateBinder to bind references, variables, and other entities within the
            // template. This extracts all the metadata that doesn't depend on directive matching.
            const { expressions, symbols, nestingLevel, usedPipes } = TemplateBinder.apply(target.template, scope);
            return new R3BoundTarget(target, directives, bindings, references, expressions, symbols, nestingLevel, usedPipes);
        }
    }
    /**
     * Represents a binding scope within a template.
     *
     * Any variables, references, or other named entities declared within the template will
     * be captured and available by name in `namedEntities`. Additionally, child templates will
     * be analyzed and have their child `Scope`s available in `childScopes`.
     */
    class Scope {
        constructor(parentScope) {
            this.parentScope = parentScope;
            /**
             * Named members of the `Scope`, such as `Reference`s or `Variable`s.
             */
            this.namedEntities = new Map();
            /**
             * Child `Scope`s for immediately nested `Template`s.
             */
            this.childScopes = new Map();
        }
        /**
         * Process a template (either as a `Template` sub-template with variables, or a plain array of
         * template `Node`s) and construct its `Scope`.
         */
        static apply(template) {
            const scope = new Scope();
            scope.ingest(template);
            return scope;
        }
        /**
         * Internal method to process the template and populate the `Scope`.
         */
        ingest(template) {
            if (template instanceof Template) {
                // Variables on an <ng-template> are defined in the inner scope.
                template.variables.forEach(node => this.visitVariable(node));
                // Process the nodes of the template.
                template.children.forEach(node => node.visit(this));
            }
            else {
                // No overarching `Template` instance, so process the nodes directly.
                template.forEach(node => node.visit(this));
            }
        }
        visitElement(element) {
            // `Element`s in the template may have `Reference`s which are captured in the scope.
            element.references.forEach(node => this.visitReference(node));
            // Recurse into the `Element`'s children.
            element.children.forEach(node => node.visit(this));
        }
        visitTemplate(template) {
            // References on a <ng-template> are defined in the outer scope, so capture them before
            // processing the template's child scope.
            template.references.forEach(node => this.visitReference(node));
            // Next, create an inner scope and process the template within it.
            const scope = new Scope(this);
            scope.ingest(template);
            this.childScopes.set(template, scope);
        }
        visitVariable(variable) {
            // Declare the variable if it's not already.
            this.maybeDeclare(variable);
        }
        visitReference(reference) {
            // Declare the variable if it's not already.
            this.maybeDeclare(reference);
        }
        // Unused visitors.
        visitContent(content) { }
        visitBoundAttribute(attr) { }
        visitBoundEvent(event) { }
        visitBoundText(text) { }
        visitText(text) { }
        visitTextAttribute(attr) { }
        visitIcu(icu) { }
        maybeDeclare(thing) {
            // Declare something with a name, as long as that name isn't taken.
            if (!this.namedEntities.has(thing.name)) {
                this.namedEntities.set(thing.name, thing);
            }
        }
        /**
         * Look up a variable within this `Scope`.
         *
         * This can recurse into a parent `Scope` if it's available.
         */
        lookup(name) {
            if (this.namedEntities.has(name)) {
                // Found in the local scope.
                return this.namedEntities.get(name);
            }
            else if (this.parentScope !== undefined) {
                // Not in the local scope, but there's a parent scope so check there.
                return this.parentScope.lookup(name);
            }
            else {
                // At the top level and it wasn't found.
                return null;
            }
        }
        /**
         * Get the child scope for a `Template`.
         *
         * This should always be defined.
         */
        getChildScope(template) {
            const res = this.childScopes.get(template);
            if (res === undefined) {
                throw new Error(`Assertion error: child scope for ${template} not found`);
            }
            return res;
        }
    }
    /**
     * Processes a template and matches directives on nodes (elements and templates).
     *
     * Usually used via the static `apply()` method.
     */
    class DirectiveBinder {
        constructor(matcher, directives, bindings, references) {
            this.matcher = matcher;
            this.directives = directives;
            this.bindings = bindings;
            this.references = references;
        }
        /**
         * Process a template (list of `Node`s) and perform directive matching against each node.
         *
         * @param template the list of template `Node`s to match (recursively).
         * @param selectorMatcher a `SelectorMatcher` containing the directives that are in scope for
         * this template.
         * @returns three maps which contain information about directives in the template: the
         * `directives` map which lists directives matched on each node, the `bindings` map which
         * indicates which directives claimed which bindings (inputs, outputs, etc), and the `references`
         * map which resolves #references (`Reference`s) within the template to the named directive or
         * template node.
         */
        static apply(template, selectorMatcher) {
            const directives = new Map();
            const bindings = new Map();
            const references = new Map();
            const matcher = new DirectiveBinder(selectorMatcher, directives, bindings, references);
            matcher.ingest(template);
            return { directives, bindings, references };
        }
        ingest(template) {
            template.forEach(node => node.visit(this));
        }
        visitElement(element) {
            this.visitElementOrTemplate(element.name, element);
        }
        visitTemplate(template) {
            this.visitElementOrTemplate('ng-template', template);
        }
        visitElementOrTemplate(elementName, node) {
            // First, determine the HTML shape of the node for the purpose of directive matching.
            // Do this by building up a `CssSelector` for the node.
            const cssSelector = createCssSelector(elementName, getAttrsForDirectiveMatching(node));
            // Next, use the `SelectorMatcher` to get the list of directives on the node.
            const directives = [];
            this.matcher.match(cssSelector, (_, directive) => directives.push(directive));
            if (directives.length > 0) {
                this.directives.set(node, directives);
            }
            // Resolve any references that are created on this node.
            node.references.forEach(ref => {
                let dirTarget = null;
                // If the reference expression is empty, then it matches the "primary" directive on the node
                // (if there is one). Otherwise it matches the host node itself (either an element or
                // <ng-template> node).
                if (ref.value.trim() === '') {
                    // This could be a reference to a component if there is one.
                    dirTarget = directives.find(dir => dir.isComponent) || null;
                }
                else {
                    // This should be a reference to a directive exported via exportAs.
                    dirTarget =
                        directives.find(dir => dir.exportAs !== null && dir.exportAs.some(value => value === ref.value)) ||
                            null;
                    // Check if a matching directive was found.
                    if (dirTarget === null) {
                        // No matching directive was found - this reference points to an unknown target. Leave it
                        // unmapped.
                        return;
                    }
                }
                if (dirTarget !== null) {
                    // This reference points to a directive.
                    this.references.set(ref, { directive: dirTarget, node });
                }
                else {
                    // This reference points to the node itself.
                    this.references.set(ref, node);
                }
            });
            const setAttributeBinding = (attribute, ioType) => {
                const dir = directives.find(dir => dir[ioType].hasOwnProperty(attribute.name));
                const binding = dir !== undefined ? dir : node;
                this.bindings.set(attribute, binding);
            };
            // Node inputs (bound attributes) and text attributes can be bound to an
            // input on a directive.
            node.inputs.forEach(input => setAttributeBinding(input, 'inputs'));
            node.attributes.forEach(attr => setAttributeBinding(attr, 'inputs'));
            if (node instanceof Template) {
                node.templateAttrs.forEach(attr => setAttributeBinding(attr, 'inputs'));
            }
            // Node outputs (bound events) can be bound to an output on a directive.
            node.outputs.forEach(output => setAttributeBinding(output, 'outputs'));
            // Recurse into the node's children.
            node.children.forEach(child => child.visit(this));
        }
        // Unused visitors.
        visitContent(content) { }
        visitVariable(variable) { }
        visitReference(reference) { }
        visitTextAttribute(attribute) { }
        visitBoundAttribute(attribute) { }
        visitBoundEvent(attribute) { }
        visitBoundAttributeOrEvent(node) { }
        visitText(text) { }
        visitBoundText(text) { }
        visitIcu(icu) { }
    }
    /**
     * Processes a template and extract metadata about expressions and symbols within.
     *
     * This is a companion to the `DirectiveBinder` that doesn't require knowledge of directives matched
     * within the template in order to operate.
     *
     * Expressions are visited by the superclass `RecursiveAstVisitor`, with custom logic provided
     * by overridden methods from that visitor.
     */
    class TemplateBinder extends RecursiveAstVisitor {
        constructor(bindings, symbols, usedPipes, nestingLevel, scope, template, level) {
            super();
            this.bindings = bindings;
            this.symbols = symbols;
            this.usedPipes = usedPipes;
            this.nestingLevel = nestingLevel;
            this.scope = scope;
            this.template = template;
            this.level = level;
            this.pipesUsed = [];
            // Save a bit of processing time by constructing this closure in advance.
            this.visitNode = (node) => node.visit(this);
        }
        // This method is defined to reconcile the type of TemplateBinder since both
        // RecursiveAstVisitor and Visitor define the visit() method in their
        // interfaces.
        visit(node, context) {
            if (node instanceof AST) {
                node.visit(this, context);
            }
            else {
                node.visit(this);
            }
        }
        /**
         * Process a template and extract metadata about expressions and symbols within.
         *
         * @param template the nodes of the template to process
         * @param scope the `Scope` of the template being processed.
         * @returns three maps which contain metadata about the template: `expressions` which interprets
         * special `AST` nodes in expressions as pointing to references or variables declared within the
         * template, `symbols` which maps those variables and references to the nested `Template` which
         * declares them, if any, and `nestingLevel` which associates each `Template` with a integer
         * nesting level (how many levels deep within the template structure the `Template` is), starting
         * at 1.
         */
        static apply(template, scope) {
            const expressions = new Map();
            const symbols = new Map();
            const nestingLevel = new Map();
            const usedPipes = new Set();
            // The top-level template has nesting level 0.
            const binder = new TemplateBinder(expressions, symbols, usedPipes, nestingLevel, scope, template instanceof Template ? template : null, 0);
            binder.ingest(template);
            return { expressions, symbols, nestingLevel, usedPipes };
        }
        ingest(template) {
            if (template instanceof Template) {
                // For <ng-template>s, process only variables and child nodes. Inputs, outputs, templateAttrs,
                // and references were all processed in the scope of the containing template.
                template.variables.forEach(this.visitNode);
                template.children.forEach(this.visitNode);
                // Set the nesting level.
                this.nestingLevel.set(template, this.level);
            }
            else {
                // Visit each node from the top-level template.
                template.forEach(this.visitNode);
            }
        }
        visitElement(element) {
            // Visit the inputs, outputs, and children of the element.
            element.inputs.forEach(this.visitNode);
            element.outputs.forEach(this.visitNode);
            element.children.forEach(this.visitNode);
        }
        visitTemplate(template) {
            // First, visit inputs, outputs and template attributes of the template node.
            template.inputs.forEach(this.visitNode);
            template.outputs.forEach(this.visitNode);
            template.templateAttrs.forEach(this.visitNode);
            // References are also evaluated in the outer context.
            template.references.forEach(this.visitNode);
            // Next, recurse into the template using its scope, and bumping the nesting level up by one.
            const childScope = this.scope.getChildScope(template);
            const binder = new TemplateBinder(this.bindings, this.symbols, this.usedPipes, this.nestingLevel, childScope, template, this.level + 1);
            binder.ingest(template);
        }
        visitVariable(variable) {
            // Register the `Variable` as a symbol in the current `Template`.
            if (this.template !== null) {
                this.symbols.set(variable, this.template);
            }
        }
        visitReference(reference) {
            // Register the `Reference` as a symbol in the current `Template`.
            if (this.template !== null) {
                this.symbols.set(reference, this.template);
            }
        }
        // Unused template visitors
        visitText(text) { }
        visitContent(content) { }
        visitTextAttribute(attribute) { }
        visitIcu(icu) { }
        // The remaining visitors are concerned with processing AST expressions within template bindings
        visitBoundAttribute(attribute) {
            attribute.value.visit(this);
        }
        visitBoundEvent(event) {
            event.handler.visit(this);
        }
        visitBoundText(text) {
            text.value.visit(this);
        }
        visitPipe(ast, context) {
            this.usedPipes.add(ast.name);
            return super.visitPipe(ast, context);
        }
        // These five types of AST expressions can refer to expression roots, which could be variables
        // or references in the current scope.
        visitPropertyRead(ast, context) {
            this.maybeMap(context, ast, ast.name);
            return super.visitPropertyRead(ast, context);
        }
        visitSafePropertyRead(ast, context) {
            this.maybeMap(context, ast, ast.name);
            return super.visitSafePropertyRead(ast, context);
        }
        visitPropertyWrite(ast, context) {
            this.maybeMap(context, ast, ast.name);
            return super.visitPropertyWrite(ast, context);
        }
        visitMethodCall(ast, context) {
            this.maybeMap(context, ast, ast.name);
            return super.visitMethodCall(ast, context);
        }
        visitSafeMethodCall(ast, context) {
            this.maybeMap(context, ast, ast.name);
            return super.visitSafeMethodCall(ast, context);
        }
        maybeMap(scope, ast, name) {
            // If the receiver of the expression isn't the `ImplicitReceiver`, this isn't the root of an
            // `AST` expression that maps to a `Variable` or `Reference`.
            if (!(ast.receiver instanceof ImplicitReceiver)) {
                return;
            }
            // Check whether the name exists in the current scope. If so, map it. Otherwise, the name is
            // probably a property on the top-level component context.
            let target = this.scope.lookup(name);
            if (target !== null) {
                this.bindings.set(ast, target);
            }
        }
    }
    /**
     * Metadata container for a `Target` that allows queries for specific bits of metadata.
     *
     * See `BoundTarget` for documentation on the individual methods.
     */
    class R3BoundTarget {
        constructor(target, directives, bindings, references, exprTargets, symbols, nestingLevel, usedPipes) {
            this.target = target;
            this.directives = directives;
            this.bindings = bindings;
            this.references = references;
            this.exprTargets = exprTargets;
            this.symbols = symbols;
            this.nestingLevel = nestingLevel;
            this.usedPipes = usedPipes;
        }
        getDirectivesOfNode(node) {
            return this.directives.get(node) || null;
        }
        getReferenceTarget(ref) {
            return this.references.get(ref) || null;
        }
        getConsumerOfBinding(binding) {
            return this.bindings.get(binding) || null;
        }
        getExpressionTarget(expr) {
            return this.exprTargets.get(expr) || null;
        }
        getTemplateOfSymbol(symbol) {
            return this.symbols.get(symbol) || null;
        }
        getNestingLevel(template) {
            return this.nestingLevel.get(template) || 0;
        }
        getUsedDirectives() {
            const set = new Set();
            this.directives.forEach(dirs => dirs.forEach(dir => set.add(dir)));
            return Array.from(set.values());
        }
        getUsedPipes() {
            return Array.from(this.usedPipes);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // This file only reexports content of the `src` folder. Keep it that way.
    // This function call has a global side effects and publishes the compiler into global namespace for
    // the late binding of the Compiler to the @angular/core for jit compilation.
    publishFacade(_global);

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const VERSION$2 = new Version('10.0.14');

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // In TypeScript 2.1 the spread element kind was renamed.
    const spreadElementSyntaxKind = ts.SyntaxKind.SpreadElement || ts.SyntaxKind.SpreadElementExpression;
    const empty$1 = ts.createNodeArray();

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var EmitFlags;
    (function (EmitFlags) {
        EmitFlags[EmitFlags["DTS"] = 1] = "DTS";
        EmitFlags[EmitFlags["JS"] = 2] = "JS";
        EmitFlags[EmitFlags["Metadata"] = 4] = "Metadata";
        EmitFlags[EmitFlags["I18nBundle"] = 8] = "I18nBundle";
        EmitFlags[EmitFlags["Codegen"] = 16] = "Codegen";
        EmitFlags[EmitFlags["Default"] = 19] = "Default";
        EmitFlags[EmitFlags["All"] = 31] = "All";
    })(EmitFlags || (EmitFlags = {}));

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class FatalDiagnosticError {
        constructor(code, node, message, relatedInformation) {
            this.code = code;
            this.node = node;
            this.message = message;
            this.relatedInformation = relatedInformation;
            /**
             * @internal
             */
            this._isFatalDiagnosticError = true;
        }
        toDiagnostic() {
            return makeDiagnostic(this.code, this.node, this.message, this.relatedInformation);
        }
    }
    function makeDiagnostic(code, node, messageText, relatedInformation) {
        node = ts.getOriginalNode(node);
        return {
            category: ts.DiagnosticCategory.Error,
            code: Number('-99' + code.valueOf()),
            file: ts.getOriginalNode(node).getSourceFile(),
            start: node.getStart(undefined, false),
            length: node.getWidth(),
            messageText,
            relatedInformation,
        };
    }
    function makeRelatedInformation(node, messageText) {
        node = ts.getOriginalNode(node);
        return {
            category: ts.DiagnosticCategory.Message,
            code: 0,
            file: node.getSourceFile(),
            start: node.getStart(),
            length: node.getWidth(),
            messageText,
        };
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @publicApi
     */
    var ErrorCode;
    (function (ErrorCode) {
        ErrorCode[ErrorCode["DECORATOR_ARG_NOT_LITERAL"] = 1001] = "DECORATOR_ARG_NOT_LITERAL";
        ErrorCode[ErrorCode["DECORATOR_ARITY_WRONG"] = 1002] = "DECORATOR_ARITY_WRONG";
        ErrorCode[ErrorCode["DECORATOR_NOT_CALLED"] = 1003] = "DECORATOR_NOT_CALLED";
        ErrorCode[ErrorCode["DECORATOR_ON_ANONYMOUS_CLASS"] = 1004] = "DECORATOR_ON_ANONYMOUS_CLASS";
        ErrorCode[ErrorCode["DECORATOR_UNEXPECTED"] = 1005] = "DECORATOR_UNEXPECTED";
        /**
         * This error code indicates that there are incompatible decorators on a type or a class field.
         */
        ErrorCode[ErrorCode["DECORATOR_COLLISION"] = 1006] = "DECORATOR_COLLISION";
        ErrorCode[ErrorCode["VALUE_HAS_WRONG_TYPE"] = 1010] = "VALUE_HAS_WRONG_TYPE";
        ErrorCode[ErrorCode["VALUE_NOT_LITERAL"] = 1011] = "VALUE_NOT_LITERAL";
        ErrorCode[ErrorCode["COMPONENT_MISSING_TEMPLATE"] = 2001] = "COMPONENT_MISSING_TEMPLATE";
        ErrorCode[ErrorCode["PIPE_MISSING_NAME"] = 2002] = "PIPE_MISSING_NAME";
        ErrorCode[ErrorCode["PARAM_MISSING_TOKEN"] = 2003] = "PARAM_MISSING_TOKEN";
        ErrorCode[ErrorCode["DIRECTIVE_MISSING_SELECTOR"] = 2004] = "DIRECTIVE_MISSING_SELECTOR";
        /** Raised when an undecorated class is passed in as a provider to a module or a directive. */
        ErrorCode[ErrorCode["UNDECORATED_PROVIDER"] = 2005] = "UNDECORATED_PROVIDER";
        /**
         * Raised when a Directive inherits its constructor from a base class without an Angular
         * decorator.
         */
        ErrorCode[ErrorCode["DIRECTIVE_INHERITS_UNDECORATED_CTOR"] = 2006] = "DIRECTIVE_INHERITS_UNDECORATED_CTOR";
        /**
         * Raised when an undecorated class that is using Angular features
         * has been discovered.
         */
        ErrorCode[ErrorCode["UNDECORATED_CLASS_USING_ANGULAR_FEATURES"] = 2007] = "UNDECORATED_CLASS_USING_ANGULAR_FEATURES";
        ErrorCode[ErrorCode["SYMBOL_NOT_EXPORTED"] = 3001] = "SYMBOL_NOT_EXPORTED";
        ErrorCode[ErrorCode["SYMBOL_EXPORTED_UNDER_DIFFERENT_NAME"] = 3002] = "SYMBOL_EXPORTED_UNDER_DIFFERENT_NAME";
        ErrorCode[ErrorCode["CONFIG_FLAT_MODULE_NO_INDEX"] = 4001] = "CONFIG_FLAT_MODULE_NO_INDEX";
        ErrorCode[ErrorCode["CONFIG_STRICT_TEMPLATES_IMPLIES_FULL_TEMPLATE_TYPECHECK"] = 4002] = "CONFIG_STRICT_TEMPLATES_IMPLIES_FULL_TEMPLATE_TYPECHECK";
        /**
         * Raised when a host expression has a parse error, such as a host listener or host binding
         * expression containing a pipe.
         */
        ErrorCode[ErrorCode["HOST_BINDING_PARSE_ERROR"] = 5001] = "HOST_BINDING_PARSE_ERROR";
        /**
         * Raised when an NgModule contains an invalid reference in `declarations`.
         */
        ErrorCode[ErrorCode["NGMODULE_INVALID_DECLARATION"] = 6001] = "NGMODULE_INVALID_DECLARATION";
        /**
         * Raised when an NgModule contains an invalid type in `imports`.
         */
        ErrorCode[ErrorCode["NGMODULE_INVALID_IMPORT"] = 6002] = "NGMODULE_INVALID_IMPORT";
        /**
         * Raised when an NgModule contains an invalid type in `exports`.
         */
        ErrorCode[ErrorCode["NGMODULE_INVALID_EXPORT"] = 6003] = "NGMODULE_INVALID_EXPORT";
        /**
         * Raised when an NgModule contains a type in `exports` which is neither in `declarations` nor
         * otherwise imported.
         */
        ErrorCode[ErrorCode["NGMODULE_INVALID_REEXPORT"] = 6004] = "NGMODULE_INVALID_REEXPORT";
        /**
         * Raised when a `ModuleWithProviders` with a missing
         * generic type argument is passed into an `NgModule`.
         */
        ErrorCode[ErrorCode["NGMODULE_MODULE_WITH_PROVIDERS_MISSING_GENERIC"] = 6005] = "NGMODULE_MODULE_WITH_PROVIDERS_MISSING_GENERIC";
        /**
         * Raised when an NgModule exports multiple directives/pipes of the same name and the compiler
         * attempts to generate private re-exports within the NgModule file.
         */
        ErrorCode[ErrorCode["NGMODULE_REEXPORT_NAME_COLLISION"] = 6006] = "NGMODULE_REEXPORT_NAME_COLLISION";
        /**
         * Raised when a directive/pipe is part of the declarations of two or more NgModules.
         */
        ErrorCode[ErrorCode["NGMODULE_DECLARATION_NOT_UNIQUE"] = 6007] = "NGMODULE_DECLARATION_NOT_UNIQUE";
        /**
         * An element name failed validation against the DOM schema.
         */
        ErrorCode[ErrorCode["SCHEMA_INVALID_ELEMENT"] = 8001] = "SCHEMA_INVALID_ELEMENT";
        /**
         * An element's attribute name failed validation against the DOM schema.
         */
        ErrorCode[ErrorCode["SCHEMA_INVALID_ATTRIBUTE"] = 8002] = "SCHEMA_INVALID_ATTRIBUTE";
        /**
         * No matching directive was found for a `#ref="target"` expression.
         */
        ErrorCode[ErrorCode["MISSING_REFERENCE_TARGET"] = 8003] = "MISSING_REFERENCE_TARGET";
        /**
         * No matching pipe was found for a
         */
        ErrorCode[ErrorCode["MISSING_PIPE"] = 8004] = "MISSING_PIPE";
        /**
         * The left-hand side of an assignment expression was a template variable. Effectively, the
         * template looked like:
         *
         * ```
         * <ng-template let-something>
         *   <button (click)="something = ...">...</button>
         * </ng-template>
         * ```
         *
         * Template variables are read-only.
         */
        ErrorCode[ErrorCode["WRITE_TO_READ_ONLY_VARIABLE"] = 8005] = "WRITE_TO_READ_ONLY_VARIABLE";
        /**
         * A template variable was declared twice. For example:
         *
         * ```html
         * <div *ngFor="let i of items; let i = index">
         * </div>
         * ```
         */
        ErrorCode[ErrorCode["DUPLICATE_VARIABLE_DECLARATION"] = 8006] = "DUPLICATE_VARIABLE_DECLARATION";
        /**
         * The template type-checking engine would need to generate an inline type check block for a
         * component, but the current type-checking environment doesn't support it.
         */
        ErrorCode[ErrorCode["INLINE_TCB_REQUIRED"] = 8900] = "INLINE_TCB_REQUIRED";
        /**
         * The template type-checking engine would need to generate an inline type constructor for a
         * directive or component, but the current type-checking environment doesn't support it.
         */
        ErrorCode[ErrorCode["INLINE_TYPE_CTOR_REQUIRED"] = 8901] = "INLINE_TYPE_CTOR_REQUIRED";
        /**
         * An injectable already has a `prov` property.
         */
        ErrorCode[ErrorCode["INJECTABLE_DUPLICATE_PROV"] = 9001] = "INJECTABLE_DUPLICATE_PROV";
    })(ErrorCode || (ErrorCode = {}));
    /**
     * @internal
     */
    function ngErrorCode(code) {
        return parseInt('-99' + code);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const D_TS = /\.d\.ts$/i;
    function isDtsPath(filePath) {
        return D_TS.test(filePath);
    }
    function nodeNameForError(node) {
        if (node.name !== undefined && ts.isIdentifier(node.name)) {
            return node.name.text;
        }
        else {
            const kind = ts.SyntaxKind[node.kind];
            const { line, character } = ts.getLineAndCharacterOfPosition(node.getSourceFile(), node.getStart());
            return `${kind}@${line}:${character}`;
        }
    }
    function getSourceFile(node) {
        // In certain transformation contexts, `ts.Node.getSourceFile()` can actually return `undefined`,
        // despite the type signature not allowing it. In that event, get the `ts.SourceFile` via the
        // original node instead (which works).
        const directSf = node.getSourceFile();
        return directSf !== undefined ? directSf : ts.getOriginalNode(node).getSourceFile();
    }
    function getSourceFileOrNull(program, fileName) {
        return program.getSourceFile(fileName) || null;
    }
    function getTokenAtPosition(sf, pos) {
        // getTokenAtPosition is part of TypeScript's private API.
        return ts.getTokenAtPosition(sf, pos);
    }
    function identifierOfNode(decl) {
        if (decl.name !== undefined && ts.isIdentifier(decl.name)) {
            return decl.name;
        }
        else {
            return null;
        }
    }
    function isDeclaration(node) {
        return isValueDeclaration(node) || isTypeDeclaration(node);
    }
    function isValueDeclaration(node) {
        return ts.isClassDeclaration(node) || ts.isFunctionDeclaration(node) ||
            ts.isVariableDeclaration(node);
    }
    function isTypeDeclaration(node) {
        return ts.isEnumDeclaration(node) || ts.isTypeAliasDeclaration(node) ||
            ts.isInterfaceDeclaration(node);
    }
    function isExported(node) {
        let topLevel = node;
        if (ts.isVariableDeclaration(node) && ts.isVariableDeclarationList(node.parent)) {
            topLevel = node.parent.parent;
        }
        return topLevel.modifiers !== undefined &&
            topLevel.modifiers.some(modifier => modifier.kind === ts.SyntaxKind.ExportKeyword);
    }
    function nodeDebugInfo(node) {
        const sf = getSourceFile(node);
        const { line, character } = ts.getLineAndCharacterOfPosition(sf, node.pos);
        return `[${sf.fileName}: ${ts.SyntaxKind[node.kind]} @ ${line}:${character}]`;
    }
    /**
     * Resolve the specified `moduleName` using the given `compilerOptions` and `compilerHost`.
     *
     * This helper will attempt to use the `CompilerHost.resolveModuleNames()` method if available.
     * Otherwise it will fallback on the `ts.ResolveModuleName()` function.
     */
    function resolveModuleName(moduleName, containingFile, compilerOptions, compilerHost, moduleResolutionCache) {
        if (compilerHost.resolveModuleNames) {
            return compilerHost.resolveModuleNames([moduleName], containingFile, undefined, // reusedNames
            undefined, // redirectedReference
            compilerOptions)[0];
        }
        else {
            return ts.resolveModuleName(moduleName, containingFile, compilerOptions, compilerHost, moduleResolutionCache !== null ? moduleResolutionCache : undefined)
                .resolvedModule;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Find the name, if any, by which a node is exported from a given file.
     */
    function findExportedNameOfNode(target, file, reflector) {
        const exports = reflector.getExportsOfModule(file);
        if (exports === null) {
            return null;
        }
        // Look for the export which declares the node.
        const keys = Array.from(exports.keys());
        const name = keys.find(key => {
            const decl = exports.get(key);
            return decl !== undefined && decl.node === target;
        });
        if (name === undefined) {
            throw new Error(`Failed to find exported name of node (${target.getText()}) in '${file.fileName}'.`);
        }
        return name;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Flags which alter the imports generated by the `ReferenceEmitter`.
     */
    var ImportFlags;
    (function (ImportFlags) {
        ImportFlags[ImportFlags["None"] = 0] = "None";
        /**
         * Force the generation of a new import when generating a reference, even if an identifier already
         * exists in the target file which could be used instead.
         *
         * This is sometimes required if there's a risk TypeScript might remove imports during emit.
         */
        ImportFlags[ImportFlags["ForceNewImport"] = 1] = "ForceNewImport";
        /**
         * Don't make use of any aliasing information when emitting a reference.
         *
         * This is sometimes required if emitting into a context where generated references will be fed
         * into TypeScript and type-checked (such as in template type-checking).
         */
        ImportFlags[ImportFlags["NoAliasing"] = 2] = "NoAliasing";
        /**
         * Indicates that an import to a type-only declaration is allowed.
         *
         * For references that occur in type-positions, the referred declaration may be a type-only
         * declaration that is not retained during emit. Including this flag allows to emit references to
         * type-only declarations as used in e.g. template type-checking.
         */
        ImportFlags[ImportFlags["AllowTypeImports"] = 4] = "AllowTypeImports";
    })(ImportFlags || (ImportFlags = {}));
    /**
     * Generates `Expression`s which refer to `Reference`s in a given context.
     *
     * A `ReferenceEmitter` uses one or more `ReferenceEmitStrategy` implementations to produce an
     * `Expression` which refers to a `Reference` in the context of a particular file.
     */
    class ReferenceEmitter {
        constructor(strategies) {
            this.strategies = strategies;
        }
        emit(ref, context, importFlags = ImportFlags.None) {
            for (const strategy of this.strategies) {
                const emitted = strategy.emit(ref, context, importFlags);
                if (emitted !== null) {
                    return emitted;
                }
            }
            throw new Error(`Unable to write a reference to ${nodeNameForError(ref.node)} in ${ref.node.getSourceFile().fileName} from ${context.fileName}`);
        }
    }
    /**
     * A `ReferenceEmitStrategy` which will refer to declarations by any local `ts.Identifier`s, if
     * such identifiers are available.
     */
    class LocalIdentifierStrategy {
        emit(ref, context, importFlags) {
            // If the emitter has specified ForceNewImport, then LocalIdentifierStrategy should not use a
            // local identifier at all, *except* in the source file where the node is actually declared.
            if (importFlags & ImportFlags.ForceNewImport &&
                getSourceFile(ref.node) !== getSourceFile(context)) {
                return null;
            }
            // A Reference can have multiple identities in different files, so it may already have an
            // Identifier in the requested context file.
            const identifier = ref.getIdentityIn(context);
            if (identifier !== null) {
                return new WrappedNodeExpr(identifier);
            }
            else {
                return null;
            }
        }
    }
    /**
     * A `ReferenceEmitStrategy` which will refer to declarations that come from `node_modules` using
     * an absolute import.
     *
     * Part of this strategy involves looking at the target entry point and identifying the exported
     * name of the targeted declaration, as it might be different from the declared name (e.g. a
     * directive might be declared as FooDirImpl, but exported as FooDir). If no export can be found
     * which maps back to the original directive, an error is thrown.
     */
    class AbsoluteModuleStrategy {
        constructor(program, checker, moduleResolver, reflectionHost) {
            this.program = program;
            this.checker = checker;
            this.moduleResolver = moduleResolver;
            this.reflectionHost = reflectionHost;
            /**
             * A cache of the exports of specific modules, because resolving a module to its exports is a
             * costly operation.
             */
            this.moduleExportsCache = new Map();
        }
        emit(ref, context, importFlags) {
            if (ref.bestGuessOwningModule === null) {
                // There is no module name available for this Reference, meaning it was arrived at via a
                // relative path.
                return null;
            }
            else if (!isDeclaration(ref.node)) {
                // It's not possible to import something which isn't a declaration.
                throw new Error(`Debug assert: unable to import a Reference to non-declaration of type ${ts.SyntaxKind[ref.node.kind]}.`);
            }
            else if ((importFlags & ImportFlags.AllowTypeImports) === 0 && isTypeDeclaration(ref.node)) {
                throw new Error(`Importing a type-only declaration of type ${ts.SyntaxKind[ref.node.kind]} in a value position is not allowed.`);
            }
            // Try to find the exported name of the declaration, if one is available.
            const { specifier, resolutionContext } = ref.bestGuessOwningModule;
            const symbolName = this.resolveImportName(specifier, ref.node, resolutionContext);
            if (symbolName === null) {
                // TODO(alxhub): make this error a ts.Diagnostic pointing at whatever caused this import to be
                // triggered.
                throw new Error(`Symbol ${ref.debugName} declared in ${getSourceFile(ref.node).fileName} is not exported from ${specifier} (import into ${context.fileName})`);
            }
            return new ExternalExpr(new ExternalReference(specifier, symbolName));
        }
        resolveImportName(moduleName, target, fromFile) {
            const exports = this.getExportsOfModule(moduleName, fromFile);
            if (exports !== null && exports.has(target)) {
                return exports.get(target);
            }
            else {
                return null;
            }
        }
        getExportsOfModule(moduleName, fromFile) {
            if (!this.moduleExportsCache.has(moduleName)) {
                this.moduleExportsCache.set(moduleName, this.enumerateExportsOfModule(moduleName, fromFile));
            }
            return this.moduleExportsCache.get(moduleName);
        }
        enumerateExportsOfModule(specifier, fromFile) {
            // First, resolve the module specifier to its entry point, and get the ts.Symbol for it.
            const entryPointFile = this.moduleResolver.resolveModule(specifier, fromFile);
            if (entryPointFile === null) {
                return null;
            }
            const exports = this.reflectionHost.getExportsOfModule(entryPointFile);
            if (exports === null) {
                return null;
            }
            const exportMap = new Map();
            exports.forEach((declaration, name) => {
                // It's okay to skip inline declarations, since by definition they're not target-able with a
                // ts.Declaration anyway.
                if (declaration.node !== null) {
                    exportMap.set(declaration.node, name);
                }
            });
            return exportMap;
        }
    }
    /**
     * A `ReferenceEmitStrategy` which will refer to declarations via relative paths, provided they're
     * both in the logical project "space" of paths.
     *
     * This is trickier than it sounds, as the two files may be in different root directories in the
     * project. Simply calculating a file system relative path between the two is not sufficient.
     * Instead, `LogicalProjectPath`s are used.
     */
    class LogicalProjectStrategy {
        constructor(reflector, logicalFs) {
            this.reflector = reflector;
            this.logicalFs = logicalFs;
        }
        emit(ref, context) {
            const destSf = getSourceFile(ref.node);
            // Compute the relative path from the importing file to the file being imported. This is done
            // as a logical path computation, because the two files might be in different rootDirs.
            const destPath = this.logicalFs.logicalPathOfSf(destSf);
            if (destPath === null) {
                // The imported file is not within the logical project filesystem.
                return null;
            }
            const originPath = this.logicalFs.logicalPathOfSf(context);
            if (originPath === null) {
                throw new Error(`Debug assert: attempt to import from ${context.fileName} but it's outside the program?`);
            }
            // There's no way to emit a relative reference from a file to itself.
            if (destPath === originPath) {
                return null;
            }
            const name = findExportedNameOfNode(ref.node, destSf, this.reflector);
            if (name === null) {
                // The target declaration isn't exported from the file it's declared in. This is an issue!
                return null;
            }
            // With both files expressed as LogicalProjectPaths, getting the module specifier as a relative
            // path is now straightforward.
            const moduleName = LogicalProjectPath.relativePathBetween(originPath, destPath);
            return new ExternalExpr({ moduleName, name });
        }
    }
    /**
     * A `ReferenceEmitStrategy` which constructs relatives paths between `ts.SourceFile`s.
     *
     * This strategy can be used if there is no `rootDir`/`rootDirs` structure for the project which
     * necessitates the stronger logic of `LogicalProjectStrategy`.
     */
    class RelativePathStrategy {
        constructor(reflector) {
            this.reflector = reflector;
        }
        emit(ref, context) {
            const destSf = getSourceFile(ref.node);
            const relativePath = relative(dirname(absoluteFromSourceFile(context)), absoluteFromSourceFile(destSf));
            const moduleName = toRelativeImport(stripExtension(relativePath));
            const name = findExportedNameOfNode(ref.node, destSf, this.reflector);
            return new ExternalExpr({ moduleName, name });
        }
    }
    /**
     * A `ReferenceEmitStrategy` which uses a `UnifiedModulesHost` to generate absolute import
     * references.
     */
    class UnifiedModulesStrategy {
        constructor(reflector, unifiedModulesHost) {
            this.reflector = reflector;
            this.unifiedModulesHost = unifiedModulesHost;
        }
        emit(ref, context) {
            const destSf = getSourceFile(ref.node);
            const name = findExportedNameOfNode(ref.node, destSf, this.reflector);
            if (name === null) {
                return null;
            }
            const moduleName = this.unifiedModulesHost.fileNameToModuleName(destSf.fileName, context.fileName);
            return new ExternalExpr({ moduleName, name });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // Escape anything that isn't alphanumeric, '/' or '_'.
    const CHARS_TO_ESCAPE = /[^a-zA-Z0-9/_]/g;
    /**
     * An `AliasingHost` which generates and consumes alias re-exports when module names for each file
     * are determined by a `UnifiedModulesHost`.
     *
     * When using a `UnifiedModulesHost`, aliasing prevents issues with transitive dependencies. See the
     * README.md for more details.
     */
    class UnifiedModulesAliasingHost {
        constructor(unifiedModulesHost) {
            this.unifiedModulesHost = unifiedModulesHost;
            /**
             * With a `UnifiedModulesHost`, aliases are chosen automatically without the need to look through
             * the exports present in a .d.ts file, so we can avoid cluttering the .d.ts files.
             */
            this.aliasExportsInDts = false;
        }
        maybeAliasSymbolAs(ref, context, ngModuleName, isReExport) {
            if (!isReExport) {
                // Aliasing is used with a UnifiedModulesHost to prevent transitive dependencies. Thus,
                // aliases
                // only need to be created for directives/pipes which are not direct declarations of an
                // NgModule which exports them.
                return null;
            }
            return this.aliasName(ref.node, context);
        }
        /**
         * Generates an `Expression` to import `decl` from `via`, assuming an export was added when `via`
         * was compiled per `maybeAliasSymbolAs` above.
         */
        getAliasIn(decl, via, isReExport) {
            if (!isReExport) {
                // Directly exported directives/pipes don't require an alias, per the logic in
                // `maybeAliasSymbolAs`.
                return null;
            }
            // viaModule is the module it'll actually be imported from.
            const moduleName = this.unifiedModulesHost.fileNameToModuleName(via.fileName, via.fileName);
            return new ExternalExpr({ moduleName, name: this.aliasName(decl, via) });
        }
        /**
         * Generates an alias name based on the full module name of the file which declares the aliased
         * directive/pipe.
         */
        aliasName(decl, context) {
            // The declared module is used to get the name of the alias.
            const declModule = this.unifiedModulesHost.fileNameToModuleName(decl.getSourceFile().fileName, context.fileName);
            const replaced = declModule.replace(CHARS_TO_ESCAPE, '_').replace(/\//g, '$');
            return 'ng$' + replaced + '$$' + decl.name.text;
        }
    }
    /**
     * An `AliasingHost` which exports directives from any file containing an NgModule in which they're
     * declared/exported, under a private symbol name.
     *
     * These exports support cases where an NgModule is imported deeply from an absolute module path
     * (that is, it's not part of an Angular Package Format entrypoint), and the compiler needs to
     * import any matched directives/pipes from the same path (to the NgModule file). See README.md for
     * more details.
     */
    class PrivateExportAliasingHost {
        constructor(host) {
            this.host = host;
            /**
             * Under private export aliasing, the `AbsoluteModuleStrategy` used for emitting references will
             * will select aliased exports that it finds in the .d.ts file for an NgModule's file. Thus,
             * emitting these exports in .d.ts is a requirement for the `PrivateExportAliasingHost` to
             * function correctly.
             */
            this.aliasExportsInDts = true;
        }
        maybeAliasSymbolAs(ref, context, ngModuleName) {
            if (ref.hasOwningModuleGuess) {
                // Skip nodes that already have an associated absolute module specifier, since they can be
                // safely imported from that specifier.
                return null;
            }
            // Look for a user-provided export of `decl` in `context`. If one exists, then an alias export
            // is not needed.
            // TODO(alxhub): maybe add a host method to check for the existence of an export without going
            // through the entire list of exports.
            const exports = this.host.getExportsOfModule(context);
            if (exports === null) {
                // Something went wrong, and no exports were available at all. Bail rather than risk creating
                // re-exports when they're not needed.
                throw new Error(`Could not determine the exports of: ${context.fileName}`);
            }
            let found = false;
            exports.forEach(value => {
                if (value.node === ref.node) {
                    found = true;
                }
            });
            if (found) {
                // The module exports the declared class directly, no alias is necessary.
                return null;
            }
            return `ngExport${ngModuleName}${ref.node.name.text}`;
        }
        /**
         * A `PrivateExportAliasingHost` only generates re-exports and does not direct the compiler to
         * directly consume the aliases it creates.
         *
         * Instead, they're consumed indirectly: `AbsoluteModuleStrategy` `ReferenceEmitterStrategy` will
         * select these alias exports automatically when looking for an export of the directive/pipe from
         * the same path as the NgModule was imported.
         *
         * Thus, `getAliasIn` always returns `null`.
         */
        getAliasIn() {
            return null;
        }
    }
    /**
     * A `ReferenceEmitStrategy` which will consume the alias attached to a particular `Reference` to a
     * directive or pipe, if it exists.
     */
    class AliasStrategy {
        emit(ref, context, importMode) {
            if (importMode & ImportFlags.NoAliasing) {
                return null;
            }
            return ref.alias;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function relativePathBetween(from, to) {
        const relativePath = stripExtension(relative(dirname(resolve(from)), resolve(to)));
        return relativePath !== '' ? toRelativeImport(relativePath) : null;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * `ImportRewriter` that does no rewriting.
     */
    class NoopImportRewriter {
        shouldImportSymbol(symbol, specifier) {
            return true;
        }
        rewriteSymbol(symbol, specifier) {
            return symbol;
        }
        rewriteSpecifier(specifier, inContextOfFile) {
            return specifier;
        }
    }
    /**
     * A mapping of supported symbols that can be imported from within @angular/core, and the names by
     * which they're exported from r3_symbols.
     */
    const CORE_SUPPORTED_SYMBOLS = new Map([
        ['defineInjectable', 'defineInjectable'],
        ['defineInjector', 'defineInjector'],
        ['defineNgModule', 'defineNgModule'],
        ['setNgModuleScope', 'setNgModuleScope'],
        ['inject', 'inject'],
        ['FactoryDef', 'FactoryDef'],
        ['setClassMetadata', 'setClassMetadata'],
        ['InjectableDef', 'InjectableDef'],
        ['InjectorDef', 'InjectorDef'],
        ['NgModuleDefWithMeta', 'NgModuleDefWithMeta'],
        ['NgModuleFactory', 'NgModuleFactory'],
        ['noSideEffects', 'noSideEffects'],
    ]);
    const CORE_MODULE = '@angular/core';
    /**
     * `ImportRewriter` that rewrites imports from '@angular/core' to be imported from the r3_symbols.ts
     * file instead.
     */
    class R3SymbolsImportRewriter {
        constructor(r3SymbolsPath) {
            this.r3SymbolsPath = r3SymbolsPath;
        }
        shouldImportSymbol(symbol, specifier) {
            return true;
        }
        rewriteSymbol(symbol, specifier) {
            if (specifier !== CORE_MODULE) {
                // This import isn't from core, so ignore it.
                return symbol;
            }
            return validateAndRewriteCoreSymbol(symbol);
        }
        rewriteSpecifier(specifier, inContextOfFile) {
            if (specifier !== CORE_MODULE) {
                // This module isn't core, so ignore it.
                return specifier;
            }
            const relativePathToR3Symbols = relativePathBetween(inContextOfFile, this.r3SymbolsPath);
            if (relativePathToR3Symbols === null) {
                throw new Error(`Failed to rewrite import inside ${CORE_MODULE}: ${inContextOfFile} -> ${this.r3SymbolsPath}`);
            }
            return relativePathToR3Symbols;
        }
    }
    function validateAndRewriteCoreSymbol(name) {
        if (!CORE_SUPPORTED_SYMBOLS.has(name)) {
            throw new Error(`Importing unexpected symbol ${name} while compiling ${CORE_MODULE}`);
        }
        return CORE_SUPPORTED_SYMBOLS.get(name);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An implementation of `DefaultImportRecorder` which does nothing.
     *
     * This is useful when default import tracking isn't required, such as when emitting .d.ts code
     * or for ngcc.
     */
    const NOOP_DEFAULT_IMPORT_RECORDER = {
        recordImportedIdentifier: (id) => void {},
        recordUsedIdentifier: (id) => void {},
    };
    /**
     * TypeScript has trouble with generating default imports inside of transformers for some module
     * formats. The issue is that for the statement:
     *
     * import X from 'some/module';
     * console.log(X);
     *
     * TypeScript will not use the "X" name in generated code. For normal user code, this is fine
     * because references to X will also be renamed. However, if both the import and any references are
     * added in a transformer, TypeScript does not associate the two, and will leave the "X" references
     * dangling while renaming the import variable. The generated code looks something like:
     *
     * const module_1 = require('some/module');
     * console.log(X); // now X is a dangling reference.
     *
     * Therefore, we cannot synthetically add default imports, and must reuse the imports that users
     * include. Doing this poses a challenge for imports that are only consumed in the type position in
     * the user's code. If Angular reuses the imported symbol in a value position (for example, we
     * see a constructor parameter of type Foo and try to write "inject(Foo)") we will also end up with
     * a dangling reference, as TS will elide the import because it was only used in the type position
     * originally.
     *
     * To avoid this, the compiler must "touch" the imports with `ts.getMutableClone`, and should
     * only do this for imports which are actually consumed. The `DefaultImportTracker` keeps track of
     * these imports as they're encountered and emitted, and implements a transform which can correctly
     * flag the imports as required.
     *
     * This problem does not exist for non-default imports as the compiler can easily insert
     * "import * as X" style imports for those, and the "X" identifier survives transformation.
     */
    class DefaultImportTracker {
        constructor() {
            /**
             * A `Map` which tracks the `Map` of default import `ts.Identifier`s to their
             * `ts.ImportDeclaration`s. These declarations are not guaranteed to be used.
             */
            this.sourceFileToImportMap = new Map();
            /**
             * A `Map` which tracks the `Set` of `ts.ImportDeclaration`s for default imports that were used in
             * a given `ts.SourceFile` and need to be preserved.
             */
            this.sourceFileToUsedImports = new Map();
        }
        recordImportedIdentifier(id, decl) {
            const sf = getSourceFile(id);
            if (!this.sourceFileToImportMap.has(sf)) {
                this.sourceFileToImportMap.set(sf, new Map());
            }
            this.sourceFileToImportMap.get(sf).set(id, decl);
        }
        recordUsedIdentifier(id) {
            const sf = getSourceFile(id);
            if (!this.sourceFileToImportMap.has(sf)) {
                // The identifier's source file has no registered default imports at all.
                return;
            }
            const identiferToDeclaration = this.sourceFileToImportMap.get(sf);
            if (!identiferToDeclaration.has(id)) {
                // The identifier isn't from a registered default import.
                return;
            }
            const decl = identiferToDeclaration.get(id);
            // Add the default import declaration to the set of used import declarations for the file.
            if (!this.sourceFileToUsedImports.has(sf)) {
                this.sourceFileToUsedImports.set(sf, new Set());
            }
            this.sourceFileToUsedImports.get(sf).add(decl);
        }
        /**
         * Get a `ts.TransformerFactory` which will preserve default imports that were previously marked
         * as used.
         *
         * This transformer must run after any other transformers which call `recordUsedIdentifier`.
         */
        importPreservingTransformer() {
            return (context) => {
                return (sf) => {
                    return this.transformSourceFile(sf);
                };
            };
        }
        /**
         * Process a `ts.SourceFile` and replace any `ts.ImportDeclaration`s.
         */
        transformSourceFile(sf) {
            const originalSf = ts.getOriginalNode(sf);
            // Take a fast path if no import declarations need to be preserved in the file.
            if (!this.sourceFileToUsedImports.has(originalSf)) {
                return sf;
            }
            // There are declarations that need to be preserved.
            const importsToPreserve = this.sourceFileToUsedImports.get(originalSf);
            // Generate a new statement list which preserves any imports present in `importsToPreserve`.
            const statements = sf.statements.map(stmt => {
                if (ts.isImportDeclaration(stmt) && importsToPreserve.has(stmt)) {
                    // Preserving an import that's marked as unreferenced (type-only) is tricky in TypeScript.
                    //
                    // Various approaches have been tried, with mixed success:
                    //
                    // 1. Using `ts.updateImportDeclaration` does not cause the import to be retained.
                    //
                    // 2. Using `ts.createImportDeclaration` with the same `ts.ImportClause` causes the import
                    //    to correctly be retained, but when emitting CommonJS module format code, references
                    //    to the imported value will not match the import variable.
                    //
                    // 3. Emitting "import * as" imports instead generates the correct import variable, but
                    //    references are missing the ".default" access. This happens to work for tsickle code
                    //    with goog.module transformations as tsickle strips the ".default" anyway.
                    //
                    // 4. It's possible to trick TypeScript by setting `ts.NodeFlag.Synthesized` on the import
                    //    declaration. This causes the import to be correctly retained and generated, but can
                    //    violate invariants elsewhere in the compiler and cause crashes.
                    //
                    // 5. Using `ts.getMutableClone` seems to correctly preserve the import and correctly
                    //    generate references to the import variable across all module types.
                    //
                    // Therefore, option 5 is the one used here. It seems to be implemented as the correct way
                    // to perform option 4, which preserves all the compiler's invariants.
                    //
                    // TODO(alxhub): discuss with the TypeScript team and determine if there's a better way to
                    // deal with this issue.
                    stmt = ts.getMutableClone(stmt);
                }
                return stmt;
            });
            // Save memory - there's no need to keep these around once the transform has run for the given
            // file.
            this.sourceFileToImportMap.delete(originalSf);
            this.sourceFileToUsedImports.delete(originalSf);
            return ts.updateSourceFileNode(sf, statements);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A `ts.Node` plus the context in which it was discovered.
     *
     * A `Reference` is a pointer to a `ts.Node` that was extracted from the program somehow. It
     * contains not only the node itself, but the information regarding how the node was located. In
     * particular, it might track different identifiers by which the node is exposed, as well as
     * potentially a module specifier which might expose the node.
     *
     * The Angular compiler uses `Reference`s instead of `ts.Node`s when tracking classes or generating
     * imports.
     */
    class Reference$1 {
        constructor(node, bestGuessOwningModule = null) {
            this.node = node;
            this.identifiers = [];
            /**
             * Indicates that the Reference was created synthetically, not as a result of natural value
             * resolution.
             *
             * This is used to avoid misinterpreting the Reference in certain contexts.
             */
            this.synthetic = false;
            this._alias = null;
            this.bestGuessOwningModule = bestGuessOwningModule;
            const id = identifierOfNode(node);
            if (id !== null) {
                this.identifiers.push(id);
            }
        }
        /**
         * The best guess at which module specifier owns this particular reference, or `null` if there
         * isn't one.
         */
        get ownedByModuleGuess() {
            if (this.bestGuessOwningModule !== null) {
                return this.bestGuessOwningModule.specifier;
            }
            else {
                return null;
            }
        }
        /**
         * Whether this reference has a potential owning module or not.
         *
         * See `bestGuessOwningModule`.
         */
        get hasOwningModuleGuess() {
            return this.bestGuessOwningModule !== null;
        }
        /**
         * A name for the node, if one is available.
         *
         * This is only suited for debugging. Any actual references to this node should be made with
         * `ts.Identifier`s (see `getIdentityIn`).
         */
        get debugName() {
            const id = identifierOfNode(this.node);
            return id !== null ? id.text : null;
        }
        get alias() {
            return this._alias;
        }
        /**
         * Record a `ts.Identifier` by which it's valid to refer to this node, within the context of this
         * `Reference`.
         */
        addIdentifier(identifier) {
            this.identifiers.push(identifier);
        }
        /**
         * Get a `ts.Identifier` within this `Reference` that can be used to refer within the context of a
         * given `ts.SourceFile`, if any.
         */
        getIdentityIn(context) {
            return this.identifiers.find(id => id.getSourceFile() === context) || null;
        }
        /**
         * Get a `ts.Identifier` for this `Reference` that exists within the given expression.
         *
         * This is very useful for producing `ts.Diagnostic`s that reference `Reference`s that were
         * extracted from some larger expression, as it can be used to pinpoint the `ts.Identifier` within
         * the expression from which the `Reference` originated.
         */
        getIdentityInExpression(expr) {
            const sf = expr.getSourceFile();
            return this.identifiers.find(id => {
                if (id.getSourceFile() !== sf) {
                    return false;
                }
                // This identifier is a match if its position lies within the given expression.
                return id.pos >= expr.pos && id.end <= expr.end;
            }) ||
                null;
        }
        /**
         * Given the 'container' expression from which this `Reference` was extracted, produce a
         * `ts.Expression` to use in a diagnostic which best indicates the position within the container
         * expression that generated the `Reference`.
         *
         * For example, given a `Reference` to the class 'Bar' and the containing expression:
         * `[Foo, Bar, Baz]`, this function would attempt to return the `ts.Identifier` for `Bar` within
         * the array. This could be used to produce a nice diagnostic context:
         *
         * ```text
         * [Foo, Bar, Baz]
         *       ~~~
         * ```
         *
         * If no specific node can be found, then the `fallback` expression is used, which defaults to the
         * entire containing expression.
         */
        getOriginForDiagnostics(container, fallback = container) {
            const id = this.getIdentityInExpression(container);
            return id !== null ? id : fallback;
        }
        cloneWithAlias(alias) {
            const ref = new Reference$1(this.node, this.bestGuessOwningModule);
            ref.identifiers = [...this.identifiers];
            ref._alias = alias;
            return ref;
        }
        cloneWithNoIdentifiers() {
            const ref = new Reference$1(this.node, this.bestGuessOwningModule);
            ref._alias = this._alias;
            ref.identifiers = [];
            return ref;
        }
    }

    /**
     * Used by `RouterEntryPointManager` and `NgModuleRouteAnalyzer` (which is in turn is used by
     * `NgModuleDecoratorHandler`) for resolving the module source-files references in lazy-loaded
     * routes (relative to the source-file containing the `NgModule` that provides the route
     * definitions).
     */
    class ModuleResolver {
        constructor(program, compilerOptions, host, moduleResolutionCache) {
            this.program = program;
            this.compilerOptions = compilerOptions;
            this.host = host;
            this.moduleResolutionCache = moduleResolutionCache;
        }
        resolveModule(moduleName, containingFile) {
            const resolved = resolveModuleName(moduleName, containingFile, this.compilerOptions, this.host, this.moduleResolutionCache);
            if (resolved === undefined) {
                return null;
            }
            return getSourceFileOrNull(this.program, absoluteFrom(resolved.resolvedFileName));
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const Decorator = {
        nodeForError: (decorator) => {
            if (decorator.node !== null) {
                return decorator.node;
            }
            else {
                // TODO(alxhub): we can't rely on narrowing until TS 3.6 is in g3.
                return decorator.synthesizedFor;
            }
        },
    };
    function isDecoratorIdentifier(exp) {
        return ts.isIdentifier(exp) ||
            ts.isPropertyAccessExpression(exp) && ts.isIdentifier(exp.expression) &&
                ts.isIdentifier(exp.name);
    }
    /**
     * An enumeration of possible kinds of class members.
     */
    var ClassMemberKind;
    (function (ClassMemberKind) {
        ClassMemberKind[ClassMemberKind["Constructor"] = 0] = "Constructor";
        ClassMemberKind[ClassMemberKind["Getter"] = 1] = "Getter";
        ClassMemberKind[ClassMemberKind["Setter"] = 2] = "Setter";
        ClassMemberKind[ClassMemberKind["Property"] = 3] = "Property";
        ClassMemberKind[ClassMemberKind["Method"] = 4] = "Method";
    })(ClassMemberKind || (ClassMemberKind = {}));
    /**
     * Possible declarations of known values, such as built-in objects/functions or TypeScript helpers.
     */
    var KnownDeclaration;
    (function (KnownDeclaration) {
        /**
         * Indicates the JavaScript global `Object` class.
         */
        KnownDeclaration[KnownDeclaration["JsGlobalObject"] = 0] = "JsGlobalObject";
        /**
         * Indicates the `__assign` TypeScript helper function.
         */
        KnownDeclaration[KnownDeclaration["TsHelperAssign"] = 1] = "TsHelperAssign";
        /**
         * Indicates the `__spread` TypeScript helper function.
         */
        KnownDeclaration[KnownDeclaration["TsHelperSpread"] = 2] = "TsHelperSpread";
        /**
         * Indicates the `__spreadArrays` TypeScript helper function.
         */
        KnownDeclaration[KnownDeclaration["TsHelperSpreadArrays"] = 3] = "TsHelperSpreadArrays";
    })(KnownDeclaration || (KnownDeclaration = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Potentially convert a `ts.TypeNode` to a `TypeValueReference`, which indicates how to use the
     * type given in the `ts.TypeNode` in a value position.
     *
     * This can return `null` if the `typeNode` is `null`, if it does not refer to a symbol with a value
     * declaration, or if it is not possible to statically understand.
     */
    function typeToValue(typeNode, checker) {
        // It's not possible to get a value expression if the parameter doesn't even have a type.
        if (typeNode === null) {
            return missingType();
        }
        if (!ts.isTypeReferenceNode(typeNode)) {
            return unsupportedType(typeNode);
        }
        const symbols = resolveTypeSymbols(typeNode, checker);
        if (symbols === null) {
            return unknownReference(typeNode);
        }
        const { local, decl } = symbols;
        // It's only valid to convert a type reference to a value reference if the type actually
        // has a value declaration associated with it. Note that const enums are an exception,
        // because while they do have a value declaration, they don't exist at runtime.
        if (decl.valueDeclaration === undefined || decl.flags & ts.SymbolFlags.ConstEnum) {
            return noValueDeclaration(typeNode, decl.declarations[0]);
        }
        // The type points to a valid value declaration. Rewrite the TypeReference into an
        // Expression which references the value pointed to by the TypeReference, if possible.
        // Look at the local `ts.Symbol`'s declarations and see if it comes from an import
        // statement. If so, extract the module specifier and the name of the imported type.
        const firstDecl = local.declarations && local.declarations[0];
        if (firstDecl !== undefined) {
            if (ts.isImportClause(firstDecl) && firstDecl.name !== undefined) {
                // This is a default import.
                //   import Foo from 'foo';
                if (firstDecl.isTypeOnly) {
                    // Type-only imports cannot be represented as value.
                    return typeOnlyImport(typeNode, firstDecl);
                }
                return {
                    kind: 0 /* LOCAL */,
                    // Copying the name here ensures the generated references will be correctly transformed
                    // along with the import.
                    expression: ts.updateIdentifier(firstDecl.name),
                    defaultImportStatement: firstDecl.parent,
                };
            }
            else if (ts.isImportSpecifier(firstDecl)) {
                // The symbol was imported by name
                //   import {Foo} from 'foo';
                // or
                //   import {Foo as Bar} from 'foo';
                if (firstDecl.parent.parent.isTypeOnly) {
                    // Type-only imports cannot be represented as value.
                    return typeOnlyImport(typeNode, firstDecl.parent.parent);
                }
                // Determine the name to import (`Foo`) from the import specifier, as the symbol names of
                // the imported type could refer to a local alias (like `Bar` in the example above).
                const importedName = (firstDecl.propertyName || firstDecl.name).text;
                // The first symbol name refers to the local name, which is replaced by `importedName` above.
                // Any remaining symbol names make up the complete path to the value.
                const [_localName, ...nestedPath] = symbols.symbolNames;
                const moduleName = extractModuleName(firstDecl.parent.parent.parent);
                return {
                    kind: 1 /* IMPORTED */,
                    valueDeclaration: decl.valueDeclaration,
                    moduleName,
                    importedName,
                    nestedPath
                };
            }
            else if (ts.isNamespaceImport(firstDecl)) {
                // The import is a namespace import
                //   import * as Foo from 'foo';
                if (firstDecl.parent.isTypeOnly) {
                    // Type-only imports cannot be represented as value.
                    return typeOnlyImport(typeNode, firstDecl.parent);
                }
                if (symbols.symbolNames.length === 1) {
                    // The type refers to the namespace itself, which cannot be represented as a value.
                    return namespaceImport(typeNode, firstDecl.parent);
                }
                // The first symbol name refers to the local name of the namespace, which is is discarded
                // as a new namespace import will be generated. This is followed by the symbol name that needs
                // to be imported and any remaining names that constitute the complete path to the value.
                const [_ns, importedName, ...nestedPath] = symbols.symbolNames;
                const moduleName = extractModuleName(firstDecl.parent.parent);
                return {
                    kind: 1 /* IMPORTED */,
                    valueDeclaration: decl.valueDeclaration,
                    moduleName,
                    importedName,
                    nestedPath
                };
            }
        }
        // If the type is not imported, the type reference can be converted into an expression as is.
        const expression = typeNodeToValueExpr(typeNode);
        if (expression !== null) {
            return {
                kind: 0 /* LOCAL */,
                expression,
                defaultImportStatement: null,
            };
        }
        else {
            return unsupportedType(typeNode);
        }
    }
    function unsupportedType(typeNode) {
        return {
            kind: 2 /* UNAVAILABLE */,
            reason: { kind: 5 /* UNSUPPORTED */, typeNode },
        };
    }
    function noValueDeclaration(typeNode, decl) {
        return {
            kind: 2 /* UNAVAILABLE */,
            reason: { kind: 1 /* NO_VALUE_DECLARATION */, typeNode, decl },
        };
    }
    function typeOnlyImport(typeNode, importClause) {
        return {
            kind: 2 /* UNAVAILABLE */,
            reason: { kind: 2 /* TYPE_ONLY_IMPORT */, typeNode, importClause },
        };
    }
    function unknownReference(typeNode) {
        return {
            kind: 2 /* UNAVAILABLE */,
            reason: { kind: 3 /* UNKNOWN_REFERENCE */, typeNode },
        };
    }
    function namespaceImport(typeNode, importClause) {
        return {
            kind: 2 /* UNAVAILABLE */,
            reason: { kind: 4 /* NAMESPACE */, typeNode, importClause },
        };
    }
    function missingType() {
        return {
            kind: 2 /* UNAVAILABLE */,
            reason: { kind: 0 /* MISSING_TYPE */ },
        };
    }
    /**
     * Attempt to extract a `ts.Expression` that's equivalent to a `ts.TypeNode`, as the two have
     * different AST shapes but can reference the same symbols.
     *
     * This will return `null` if an equivalent expression cannot be constructed.
     */
    function typeNodeToValueExpr(node) {
        if (ts.isTypeReferenceNode(node)) {
            return entityNameToValue(node.typeName);
        }
        else {
            return null;
        }
    }
    /**
     * Resolve a `TypeReference` node to the `ts.Symbol`s for both its declaration and its local source.
     *
     * In the event that the `TypeReference` refers to a locally declared symbol, these will be the
     * same. If the `TypeReference` refers to an imported symbol, then `decl` will be the fully resolved
     * `ts.Symbol` of the referenced symbol. `local` will be the `ts.Symbol` of the `ts.Identifier`
     * which points to the import statement by which the symbol was imported.
     *
     * All symbol names that make up the type reference are returned left-to-right into the
     * `symbolNames` array, which is guaranteed to include at least one entry.
     */
    function resolveTypeSymbols(typeRef, checker) {
        const typeName = typeRef.typeName;
        // typeRefSymbol is the ts.Symbol of the entire type reference.
        const typeRefSymbol = checker.getSymbolAtLocation(typeName);
        if (typeRefSymbol === undefined) {
            return null;
        }
        // `local` is the `ts.Symbol` for the local `ts.Identifier` for the type.
        // If the type is actually locally declared or is imported by name, for example:
        //   import {Foo} from './foo';
        // then it'll be the same as `typeRefSymbol`.
        //
        // If the type is imported via a namespace import, for example:
        //   import * as foo from './foo';
        // and then referenced as:
        //   constructor(f: foo.Foo)
        // then `local` will be the `ts.Symbol` of `foo`, whereas `typeRefSymbol` will be the `ts.Symbol`
        // of `foo.Foo`. This allows tracking of the import behind whatever type reference exists.
        let local = typeRefSymbol;
        // Destructure a name like `foo.X.Y.Z` as follows:
        // - in `leftMost`, the `ts.Identifier` of the left-most name (`foo`) in the qualified name.
        //   This identifier is used to resolve the `ts.Symbol` for `local`.
        // - in `symbolNames`, all names involved in the qualified path, or a single symbol name if the
        //   type is not qualified.
        let leftMost = typeName;
        const symbolNames = [];
        while (ts.isQualifiedName(leftMost)) {
            symbolNames.unshift(leftMost.right.text);
            leftMost = leftMost.left;
        }
        symbolNames.unshift(leftMost.text);
        if (leftMost !== typeName) {
            const localTmp = checker.getSymbolAtLocation(leftMost);
            if (localTmp !== undefined) {
                local = localTmp;
            }
        }
        // De-alias the top-level type reference symbol to get the symbol of the actual declaration.
        let decl = typeRefSymbol;
        if (typeRefSymbol.flags & ts.SymbolFlags.Alias) {
            decl = checker.getAliasedSymbol(typeRefSymbol);
        }
        return { local, decl, symbolNames };
    }
    function entityNameToValue(node) {
        if (ts.isQualifiedName(node)) {
            const left = entityNameToValue(node.left);
            return left !== null ? ts.createPropertyAccess(left, node.right) : null;
        }
        else if (ts.isIdentifier(node)) {
            return ts.getMutableClone(node);
        }
        else {
            return null;
        }
    }
    function extractModuleName(node) {
        if (!ts.isStringLiteral(node.moduleSpecifier)) {
            throw new Error('not a module specifier');
        }
        return node.moduleSpecifier.text;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function isNamedClassDeclaration(node) {
        return ts.isClassDeclaration(node) && (node.name !== undefined);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * reflector.ts implements static reflection of declarations using the TypeScript `ts.TypeChecker`.
     */
    class TypeScriptReflectionHost {
        constructor(checker) {
            this.checker = checker;
        }
        getDecoratorsOfDeclaration(declaration) {
            if (declaration.decorators === undefined || declaration.decorators.length === 0) {
                return null;
            }
            return declaration.decorators.map(decorator => this._reflectDecorator(decorator))
                .filter((dec) => dec !== null);
        }
        getMembersOfClass(clazz) {
            const tsClazz = castDeclarationToClassOrDie(clazz);
            return tsClazz.members.map(member => this._reflectMember(member))
                .filter((member) => member !== null);
        }
        getConstructorParameters(clazz) {
            const tsClazz = castDeclarationToClassOrDie(clazz);
            // First, find the constructor with a `body`. The constructors without a `body` are overloads
            // whereas we want the implementation since it's the one that'll be executed and which can
            // have decorators.
            const ctor = tsClazz.members.find((member) => ts.isConstructorDeclaration(member) && member.body !== undefined);
            if (ctor === undefined) {
                return null;
            }
            return ctor.parameters.map(node => {
                // The name of the parameter is easy.
                const name = parameterName(node.name);
                const decorators = this.getDecoratorsOfDeclaration(node);
                // It may or may not be possible to write an expression that refers to the value side of the
                // type named for the parameter.
                let originalTypeNode = node.type || null;
                let typeNode = originalTypeNode;
                // Check if we are dealing with a simple nullable union type e.g. `foo: Foo|null`
                // and extract the type. More complex union types e.g. `foo: Foo|Bar` are not supported.
                // We also don't need to support `foo: Foo|undefined` because Angular's DI injects `null` for
                // optional tokes that don't have providers.
                if (typeNode && ts.isUnionTypeNode(typeNode)) {
                    let childTypeNodes = typeNode.types.filter(childTypeNode => childTypeNode.kind !== ts.SyntaxKind.NullKeyword);
                    if (childTypeNodes.length === 1) {
                        typeNode = childTypeNodes[0];
                    }
                }
                const typeValueReference = typeToValue(typeNode, this.checker);
                return {
                    name,
                    nameNode: node.name,
                    typeValueReference,
                    typeNode: originalTypeNode,
                    decorators,
                };
            });
        }
        getImportOfIdentifier(id) {
            const directImport = this.getDirectImportOfIdentifier(id);
            if (directImport !== null) {
                return directImport;
            }
            else if (ts.isQualifiedName(id.parent) && id.parent.right === id) {
                return this.getImportOfNamespacedIdentifier(id, getQualifiedNameRoot(id.parent));
            }
            else if (ts.isPropertyAccessExpression(id.parent) && id.parent.name === id) {
                return this.getImportOfNamespacedIdentifier(id, getFarLeftIdentifier(id.parent));
            }
            else {
                return null;
            }
        }
        getExportsOfModule(node) {
            // In TypeScript code, modules are only ts.SourceFiles. Throw if the node isn't a module.
            if (!ts.isSourceFile(node)) {
                throw new Error(`getExportsOfModule() called on non-SourceFile in TS code`);
            }
            const map = new Map();
            // Reflect the module to a Symbol, and use getExportsOfModule() to get a list of exported
            // Symbols.
            const symbol = this.checker.getSymbolAtLocation(node);
            if (symbol === undefined) {
                return null;
            }
            this.checker.getExportsOfModule(symbol).forEach(exportSymbol => {
                // Map each exported Symbol to a Declaration and add it to the map.
                const decl = this.getDeclarationOfSymbol(exportSymbol, null);
                if (decl !== null) {
                    map.set(exportSymbol.name, decl);
                }
            });
            return map;
        }
        isClass(node) {
            // For our purposes, classes are "named" ts.ClassDeclarations;
            // (`node.name` can be undefined in unnamed default exports: `default export class { ... }`).
            return isNamedClassDeclaration(node);
        }
        hasBaseClass(clazz) {
            return this.getBaseClassExpression(clazz) !== null;
        }
        getBaseClassExpression(clazz) {
            if (!(ts.isClassDeclaration(clazz) || ts.isClassExpression(clazz)) ||
                clazz.heritageClauses === undefined) {
                return null;
            }
            const extendsClause = clazz.heritageClauses.find(clause => clause.token === ts.SyntaxKind.ExtendsKeyword);
            if (extendsClause === undefined) {
                return null;
            }
            const extendsType = extendsClause.types[0];
            if (extendsType === undefined) {
                return null;
            }
            return extendsType.expression;
        }
        getDeclarationOfIdentifier(id) {
            // Resolve the identifier to a Symbol, and return the declaration of that.
            let symbol = this.checker.getSymbolAtLocation(id);
            if (symbol === undefined) {
                return null;
            }
            return this.getDeclarationOfSymbol(symbol, id);
        }
        getDefinitionOfFunction(node) {
            if (!ts.isFunctionDeclaration(node) && !ts.isMethodDeclaration(node) &&
                !ts.isFunctionExpression(node)) {
                return null;
            }
            return {
                node,
                body: node.body !== undefined ? Array.from(node.body.statements) : null,
                parameters: node.parameters.map(param => {
                    const name = parameterName(param.name);
                    const initializer = param.initializer || null;
                    return { name, node: param, initializer };
                }),
            };
        }
        getGenericArityOfClass(clazz) {
            if (!ts.isClassDeclaration(clazz)) {
                return null;
            }
            return clazz.typeParameters !== undefined ? clazz.typeParameters.length : 0;
        }
        getVariableValue(declaration) {
            return declaration.initializer || null;
        }
        getDtsDeclaration(_) {
            return null;
        }
        getInternalNameOfClass(clazz) {
            return clazz.name;
        }
        getAdjacentNameOfClass(clazz) {
            return clazz.name;
        }
        getDirectImportOfIdentifier(id) {
            const symbol = this.checker.getSymbolAtLocation(id);
            if (symbol === undefined || symbol.declarations === undefined ||
                symbol.declarations.length !== 1) {
                return null;
            }
            const decl = symbol.declarations[0];
            const importDecl = getContainingImportDeclaration(decl);
            // Ignore declarations that are defined locally (not imported).
            if (importDecl === null) {
                return null;
            }
            // The module specifier is guaranteed to be a string literal, so this should always pass.
            if (!ts.isStringLiteral(importDecl.moduleSpecifier)) {
                // Not allowed to happen in TypeScript ASTs.
                return null;
            }
            return { from: importDecl.moduleSpecifier.text, name: getExportedName(decl, id) };
        }
        /**
         * Try to get the import info for this identifier as though it is a namespaced import.
         *
         * For example, if the identifier is the `Directive` part of a qualified type chain like:
         *
         * ```
         * core.Directive
         * ```
         *
         * then it might be that `core` is a namespace import such as:
         *
         * ```
         * import * as core from 'tslib';
         * ```
         *
         * @param id the TypeScript identifier to find the import info for.
         * @returns The import info if this is a namespaced import or `null`.
         */
        getImportOfNamespacedIdentifier(id, namespaceIdentifier) {
            if (namespaceIdentifier === null) {
                return null;
            }
            const namespaceSymbol = this.checker.getSymbolAtLocation(namespaceIdentifier);
            if (!namespaceSymbol) {
                return null;
            }
            const declaration = namespaceSymbol.declarations.length === 1 ? namespaceSymbol.declarations[0] : null;
            if (!declaration) {
                return null;
            }
            const namespaceDeclaration = ts.isNamespaceImport(declaration) ? declaration : null;
            if (!namespaceDeclaration) {
                return null;
            }
            const importDeclaration = namespaceDeclaration.parent.parent;
            if (!ts.isStringLiteral(importDeclaration.moduleSpecifier)) {
                // Should not happen as this would be invalid TypesScript
                return null;
            }
            return {
                from: importDeclaration.moduleSpecifier.text,
                name: id.text,
            };
        }
        /**
         * Resolve a `ts.Symbol` to its declaration, keeping track of the `viaModule` along the way.
         */
        getDeclarationOfSymbol(symbol, originalId) {
            // If the symbol points to a ShorthandPropertyAssignment, resolve it.
            let valueDeclaration = undefined;
            if (symbol.valueDeclaration !== undefined) {
                valueDeclaration = symbol.valueDeclaration;
            }
            else if (symbol.declarations !== undefined && symbol.declarations.length > 0) {
                valueDeclaration = symbol.declarations[0];
            }
            if (valueDeclaration !== undefined && ts.isShorthandPropertyAssignment(valueDeclaration)) {
                const shorthandSymbol = this.checker.getShorthandAssignmentValueSymbol(valueDeclaration);
                if (shorthandSymbol === undefined) {
                    return null;
                }
                return this.getDeclarationOfSymbol(shorthandSymbol, originalId);
            }
            else if (valueDeclaration !== undefined && ts.isExportSpecifier(valueDeclaration)) {
                const targetSymbol = this.checker.getExportSpecifierLocalTargetSymbol(valueDeclaration);
                if (targetSymbol === undefined) {
                    return null;
                }
                return this.getDeclarationOfSymbol(targetSymbol, originalId);
            }
            const importInfo = originalId && this.getImportOfIdentifier(originalId);
            const viaModule = importInfo !== null && importInfo.from !== null && !importInfo.from.startsWith('.') ?
                importInfo.from :
                null;
            // Now, resolve the Symbol to its declaration by following any and all aliases.
            while (symbol.flags & ts.SymbolFlags.Alias) {
                symbol = this.checker.getAliasedSymbol(symbol);
            }
            // Look at the resolved Symbol's declarations and pick one of them to return. Value declarations
            // are given precedence over type declarations.
            if (symbol.valueDeclaration !== undefined) {
                return {
                    node: symbol.valueDeclaration,
                    known: null,
                    viaModule,
                    identity: null,
                };
            }
            else if (symbol.declarations !== undefined && symbol.declarations.length > 0) {
                return {
                    node: symbol.declarations[0],
                    known: null,
                    viaModule,
                    identity: null,
                };
            }
            else {
                return null;
            }
        }
        _reflectDecorator(node) {
            // Attempt to resolve the decorator expression into a reference to a concrete Identifier. The
            // expression may contain a call to a function which returns the decorator function, in which
            // case we want to return the arguments.
            let decoratorExpr = node.expression;
            let args = null;
            // Check for call expressions.
            if (ts.isCallExpression(decoratorExpr)) {
                args = Array.from(decoratorExpr.arguments);
                decoratorExpr = decoratorExpr.expression;
            }
            // The final resolved decorator should be a `ts.Identifier` - if it's not, then something is
            // wrong and the decorator can't be resolved statically.
            if (!isDecoratorIdentifier(decoratorExpr)) {
                return null;
            }
            const decoratorIdentifier = ts.isIdentifier(decoratorExpr) ? decoratorExpr : decoratorExpr.name;
            const importDecl = this.getImportOfIdentifier(decoratorIdentifier);
            return {
                name: decoratorIdentifier.text,
                identifier: decoratorExpr,
                import: importDecl,
                node,
                args,
            };
        }
        _reflectMember(node) {
            let kind = null;
            let value = null;
            let name = null;
            let nameNode = null;
            if (ts.isPropertyDeclaration(node)) {
                kind = ClassMemberKind.Property;
                value = node.initializer || null;
            }
            else if (ts.isGetAccessorDeclaration(node)) {
                kind = ClassMemberKind.Getter;
            }
            else if (ts.isSetAccessorDeclaration(node)) {
                kind = ClassMemberKind.Setter;
            }
            else if (ts.isMethodDeclaration(node)) {
                kind = ClassMemberKind.Method;
            }
            else if (ts.isConstructorDeclaration(node)) {
                kind = ClassMemberKind.Constructor;
            }
            else {
                return null;
            }
            if (ts.isConstructorDeclaration(node)) {
                name = 'constructor';
            }
            else if (ts.isIdentifier(node.name)) {
                name = node.name.text;
                nameNode = node.name;
            }
            else if (ts.isStringLiteral(node.name)) {
                name = node.name.text;
                nameNode = node.name;
            }
            else {
                return null;
            }
            const decorators = this.getDecoratorsOfDeclaration(node);
            const isStatic = node.modifiers !== undefined &&
                node.modifiers.some(mod => mod.kind === ts.SyntaxKind.StaticKeyword);
            return {
                node,
                implementation: node,
                kind,
                type: node.type || null,
                name,
                nameNode,
                decorators,
                value,
                isStatic,
            };
        }
    }
    function reflectTypeEntityToDeclaration(type, checker) {
        let realSymbol = checker.getSymbolAtLocation(type);
        if (realSymbol === undefined) {
            throw new Error(`Cannot resolve type entity ${type.getText()} to symbol`);
        }
        while (realSymbol.flags & ts.SymbolFlags.Alias) {
            realSymbol = checker.getAliasedSymbol(realSymbol);
        }
        let node = null;
        if (realSymbol.valueDeclaration !== undefined) {
            node = realSymbol.valueDeclaration;
        }
        else if (realSymbol.declarations !== undefined && realSymbol.declarations.length === 1) {
            node = realSymbol.declarations[0];
        }
        else {
            throw new Error(`Cannot resolve type entity symbol to declaration`);
        }
        if (ts.isQualifiedName(type)) {
            if (!ts.isIdentifier(type.left)) {
                throw new Error(`Cannot handle qualified name with non-identifier lhs`);
            }
            const symbol = checker.getSymbolAtLocation(type.left);
            if (symbol === undefined || symbol.declarations === undefined ||
                symbol.declarations.length !== 1) {
                throw new Error(`Cannot resolve qualified type entity lhs to symbol`);
            }
            const decl = symbol.declarations[0];
            if (ts.isNamespaceImport(decl)) {
                const clause = decl.parent;
                const importDecl = clause.parent;
                if (!ts.isStringLiteral(importDecl.moduleSpecifier)) {
                    throw new Error(`Module specifier is not a string`);
                }
                return { node, from: importDecl.moduleSpecifier.text };
            }
            else {
                throw new Error(`Unknown import type?`);
            }
        }
        else {
            return { node, from: null };
        }
    }
    function filterToMembersWithDecorator(members, name, module) {
        return members.filter(member => !member.isStatic)
            .map(member => {
            if (member.decorators === null) {
                return null;
            }
            const decorators = member.decorators.filter(dec => {
                if (dec.import !== null) {
                    return dec.import.name === name && (module === undefined || dec.import.from === module);
                }
                else {
                    return dec.name === name && module === undefined;
                }
            });
            if (decorators.length === 0) {
                return null;
            }
            return { member, decorators };
        })
            .filter((value) => value !== null);
    }
    function reflectObjectLiteral(node) {
        const map = new Map();
        node.properties.forEach(prop => {
            if (ts.isPropertyAssignment(prop)) {
                const name = propertyNameToString(prop.name);
                if (name === null) {
                    return;
                }
                map.set(name, prop.initializer);
            }
            else if (ts.isShorthandPropertyAssignment(prop)) {
                map.set(prop.name.text, prop.name);
            }
            else {
                return;
            }
        });
        return map;
    }
    function castDeclarationToClassOrDie(declaration) {
        if (!ts.isClassDeclaration(declaration)) {
            throw new Error(`Reflecting on a ${ts.SyntaxKind[declaration.kind]} instead of a ClassDeclaration.`);
        }
        return declaration;
    }
    function parameterName(name) {
        if (ts.isIdentifier(name)) {
            return name.text;
        }
        else {
            return null;
        }
    }
    function propertyNameToString(node) {
        if (ts.isIdentifier(node) || ts.isStringLiteral(node) || ts.isNumericLiteral(node)) {
            return node.text;
        }
        else {
            return null;
        }
    }
    /**
     * Compute the left most identifier in a qualified type chain. E.g. the `a` of `a.b.c.SomeType`.
     * @param qualifiedName The starting property access expression from which we want to compute
     * the left most identifier.
     * @returns the left most identifier in the chain or `null` if it is not an identifier.
     */
    function getQualifiedNameRoot(qualifiedName) {
        while (ts.isQualifiedName(qualifiedName.left)) {
            qualifiedName = qualifiedName.left;
        }
        return ts.isIdentifier(qualifiedName.left) ? qualifiedName.left : null;
    }
    /**
     * Compute the left most identifier in a property access chain. E.g. the `a` of `a.b.c.d`.
     * @param propertyAccess The starting property access expression from which we want to compute
     * the left most identifier.
     * @returns the left most identifier in the chain or `null` if it is not an identifier.
     */
    function getFarLeftIdentifier(propertyAccess) {
        while (ts.isPropertyAccessExpression(propertyAccess.expression)) {
            propertyAccess = propertyAccess.expression;
        }
        return ts.isIdentifier(propertyAccess.expression) ? propertyAccess.expression : null;
    }
    /**
     * Return the ImportDeclaration for the given `node` if it is either an `ImportSpecifier` or a
     * `NamespaceImport`. If not return `null`.
     */
    function getContainingImportDeclaration(node) {
        return ts.isImportSpecifier(node) ? node.parent.parent.parent :
            ts.isNamespaceImport(node) ? node.parent.parent : null;
    }
    /**
     * Compute the name by which the `decl` was exported, not imported.
     * If no such declaration can be found (e.g. it is a namespace import)
     * then fallback to the `originalId`.
     */
    function getExportedName(decl, originalId) {
        return ts.isImportSpecifier(decl) ?
            (decl.propertyName !== undefined ? decl.propertyName : decl.name).text :
            originalId.text;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function extractReferencesFromType(checker, def, ngModuleImportedFrom, resolutionContext) {
        if (!ts.isTupleTypeNode(def)) {
            return [];
        }
        return def.elementTypes.map(element => {
            if (!ts.isTypeQueryNode(element)) {
                throw new Error(`Expected TypeQueryNode: ${nodeDebugInfo(element)}`);
            }
            const type = element.exprName;
            const { node, from } = reflectTypeEntityToDeclaration(type, checker);
            if (!isNamedClassDeclaration(node)) {
                throw new Error(`Expected named ClassDeclaration: ${nodeDebugInfo(node)}`);
            }
            const specifier = (from !== null && !from.startsWith('.') ? from : ngModuleImportedFrom);
            if (specifier !== null) {
                return new Reference$1(node, { specifier, resolutionContext });
            }
            else {
                return new Reference$1(node);
            }
        });
    }
    function readStringType(type) {
        if (!ts.isLiteralTypeNode(type) || !ts.isStringLiteral(type.literal)) {
            return null;
        }
        return type.literal.text;
    }
    function readStringMapType(type) {
        if (!ts.isTypeLiteralNode(type)) {
            return {};
        }
        const obj = {};
        type.members.forEach(member => {
            if (!ts.isPropertySignature(member) || member.type === undefined || member.name === undefined ||
                !ts.isStringLiteral(member.name)) {
                return;
            }
            const value = readStringType(member.type);
            if (value === null) {
                return null;
            }
            obj[member.name.text] = value;
        });
        return obj;
    }
    function readStringArrayType(type) {
        if (!ts.isTupleTypeNode(type)) {
            return [];
        }
        const res = [];
        type.elementTypes.forEach(el => {
            if (!ts.isLiteralTypeNode(el) || !ts.isStringLiteral(el.literal)) {
                return;
            }
            res.push(el.literal.text);
        });
        return res;
    }
    function extractDirectiveGuards(node, reflector) {
        const staticMembers = reflector.getMembersOfClass(node).filter(member => member.isStatic);
        const ngTemplateGuards = staticMembers.map(extractTemplateGuard)
            .filter((guard) => guard !== null);
        const hasNgTemplateContextGuard = staticMembers.some(member => member.kind === ClassMemberKind.Method && member.name === 'ngTemplateContextGuard');
        const coercedInputFields = new Set(staticMembers.map(extractCoercedInput)
            .filter((inputName) => inputName !== null));
        return { hasNgTemplateContextGuard, ngTemplateGuards, coercedInputFields };
    }
    function extractTemplateGuard(member) {
        if (!member.name.startsWith('ngTemplateGuard_')) {
            return null;
        }
        const inputName = afterUnderscore(member.name);
        if (member.kind === ClassMemberKind.Property) {
            let type = null;
            if (member.type !== null && ts.isLiteralTypeNode(member.type) &&
                ts.isStringLiteral(member.type.literal)) {
                type = member.type.literal.text;
            }
            // Only property members with string literal type 'binding' are considered as template guard.
            if (type !== 'binding') {
                return null;
            }
            return { inputName, type };
        }
        else if (member.kind === ClassMemberKind.Method) {
            return { inputName, type: 'invocation' };
        }
        else {
            return null;
        }
    }
    function extractCoercedInput(member) {
        if (member.kind !== ClassMemberKind.Property || !member.name.startsWith('ngAcceptInputType_')) {
            return null;
        }
        return afterUnderscore(member.name);
    }
    /**
     * A `MetadataReader` that reads from an ordered set of child readers until it obtains the requested
     * metadata.
     *
     * This is used to combine `MetadataReader`s that read from different sources (e.g. from a registry
     * and from .d.ts files).
     */
    class CompoundMetadataReader {
        constructor(readers) {
            this.readers = readers;
        }
        getDirectiveMetadata(node) {
            for (const reader of this.readers) {
                const meta = reader.getDirectiveMetadata(node);
                if (meta !== null) {
                    return meta;
                }
            }
            return null;
        }
        getNgModuleMetadata(node) {
            for (const reader of this.readers) {
                const meta = reader.getNgModuleMetadata(node);
                if (meta !== null) {
                    return meta;
                }
            }
            return null;
        }
        getPipeMetadata(node) {
            for (const reader of this.readers) {
                const meta = reader.getPipeMetadata(node);
                if (meta !== null) {
                    return meta;
                }
            }
            return null;
        }
    }
    function afterUnderscore(str) {
        const pos = str.indexOf('_');
        if (pos === -1) {
            throw new Error(`Expected '${str}' to contain '_'`);
        }
        return str.substr(pos + 1);
    }
    /** Returns whether a class declaration has the necessary class fields to make it injectable. */
    function hasInjectableFields(clazz, host) {
        const members = host.getMembersOfClass(clazz);
        return members.some(({ isStatic, name }) => isStatic && (name === 'prov' || name === 'fac' || name === 'inj'));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A `MetadataReader` that can read metadata from `.d.ts` files, which have static Ivy properties
     * from an upstream compilation already.
     */
    class DtsMetadataReader {
        constructor(checker, reflector) {
            this.checker = checker;
            this.reflector = reflector;
        }
        /**
         * Read the metadata from a class that has already been compiled somehow (either it's in a .d.ts
         * file, or in a .ts file with a handwritten definition).
         *
         * @param ref `Reference` to the class of interest, with the context of how it was obtained.
         */
        getNgModuleMetadata(ref) {
            const clazz = ref.node;
            const resolutionContext = clazz.getSourceFile().fileName;
            // This operation is explicitly not memoized, as it depends on `ref.ownedByModuleGuess`.
            // TODO(alxhub): investigate caching of .d.ts module metadata.
            const ngModuleDef = this.reflector.getMembersOfClass(clazz).find(member => member.name === 'mod' && member.isStatic);
            if (ngModuleDef === undefined) {
                return null;
            }
            else if (
            // Validate that the shape of the ngModuleDef type is correct.
            ngModuleDef.type === null || !ts.isTypeReferenceNode(ngModuleDef.type) ||
                ngModuleDef.type.typeArguments === undefined ||
                ngModuleDef.type.typeArguments.length !== 4) {
                return null;
            }
            // Read the ModuleData out of the type arguments.
            const [_, declarationMetadata, importMetadata, exportMetadata] = ngModuleDef.type.typeArguments;
            return {
                ref,
                declarations: extractReferencesFromType(this.checker, declarationMetadata, ref.ownedByModuleGuess, resolutionContext),
                exports: extractReferencesFromType(this.checker, exportMetadata, ref.ownedByModuleGuess, resolutionContext),
                imports: extractReferencesFromType(this.checker, importMetadata, ref.ownedByModuleGuess, resolutionContext),
                schemas: [],
                rawDeclarations: null,
            };
        }
        /**
         * Read directive (or component) metadata from a referenced class in a .d.ts file.
         */
        getDirectiveMetadata(ref) {
            const clazz = ref.node;
            const def = this.reflector.getMembersOfClass(clazz).find(field => field.isStatic && (field.name === 'cmp' || field.name === 'dir'));
            if (def === undefined) {
                // No definition could be found.
                return null;
            }
            else if (def.type === null || !ts.isTypeReferenceNode(def.type) ||
                def.type.typeArguments === undefined || def.type.typeArguments.length < 2) {
                // The type metadata was the wrong shape.
                return null;
            }
            return Object.assign(Object.assign({ ref, name: clazz.name.text, isComponent: def.name === 'cmp', selector: readStringType(def.type.typeArguments[1]), exportAs: readStringArrayType(def.type.typeArguments[2]), inputs: readStringMapType(def.type.typeArguments[3]), outputs: readStringMapType(def.type.typeArguments[4]), queries: readStringArrayType(def.type.typeArguments[5]) }, extractDirectiveGuards(clazz, this.reflector)), { baseClass: readBaseClass(clazz, this.checker, this.reflector) });
        }
        /**
         * Read pipe metadata from a referenced class in a .d.ts file.
         */
        getPipeMetadata(ref) {
            const def = this.reflector.getMembersOfClass(ref.node).find(field => field.isStatic && field.name === 'pipe');
            if (def === undefined) {
                // No definition could be found.
                return null;
            }
            else if (def.type === null || !ts.isTypeReferenceNode(def.type) ||
                def.type.typeArguments === undefined || def.type.typeArguments.length < 2) {
                // The type metadata was the wrong shape.
                return null;
            }
            const type = def.type.typeArguments[1];
            if (!ts.isLiteralTypeNode(type) || !ts.isStringLiteral(type.literal)) {
                // The type metadata was the wrong type.
                return null;
            }
            const name = type.literal.text;
            return { ref, name };
        }
    }
    function readBaseClass(clazz, checker, reflector) {
        if (!isNamedClassDeclaration(clazz)) {
            // Technically this is an error in a .d.ts file, but for the purposes of finding the base class
            // it's ignored.
            return reflector.hasBaseClass(clazz) ? 'dynamic' : null;
        }
        if (clazz.heritageClauses !== undefined) {
            for (const clause of clazz.heritageClauses) {
                if (clause.token === ts.SyntaxKind.ExtendsKeyword) {
                    const baseExpr = clause.types[0].expression;
                    let symbol = checker.getSymbolAtLocation(baseExpr);
                    if (symbol === undefined) {
                        return 'dynamic';
                    }
                    else if (symbol.flags & ts.SymbolFlags.Alias) {
                        symbol = checker.getAliasedSymbol(symbol);
                    }
                    if (symbol.valueDeclaration !== undefined &&
                        isNamedClassDeclaration(symbol.valueDeclaration)) {
                        return new Reference$1(symbol.valueDeclaration);
                    }
                    else {
                        return 'dynamic';
                    }
                }
            }
        }
        return null;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A registry of directive, pipe, and module metadata for types defined in the current compilation
     * unit, which supports both reading and registering.
     */
    class LocalMetadataRegistry {
        constructor() {
            this.directives = new Map();
            this.ngModules = new Map();
            this.pipes = new Map();
        }
        getDirectiveMetadata(ref) {
            return this.directives.has(ref.node) ? this.directives.get(ref.node) : null;
        }
        getNgModuleMetadata(ref) {
            return this.ngModules.has(ref.node) ? this.ngModules.get(ref.node) : null;
        }
        getPipeMetadata(ref) {
            return this.pipes.has(ref.node) ? this.pipes.get(ref.node) : null;
        }
        registerDirectiveMetadata(meta) {
            this.directives.set(meta.ref.node, meta);
        }
        registerNgModuleMetadata(meta) {
            this.ngModules.set(meta.ref.node, meta);
        }
        registerPipeMetadata(meta) {
            this.pipes.set(meta.ref.node, meta);
        }
    }
    /**
     * A `MetadataRegistry` which registers metdata with multiple delegate `MetadataRegistry` instances.
     */
    class CompoundMetadataRegistry {
        constructor(registries) {
            this.registries = registries;
        }
        registerDirectiveMetadata(meta) {
            for (const registry of this.registries) {
                registry.registerDirectiveMetadata(meta);
            }
        }
        registerNgModuleMetadata(meta) {
            for (const registry of this.registries) {
                registry.registerNgModuleMetadata(meta);
            }
        }
        registerPipeMetadata(meta) {
            for (const registry of this.registries) {
                registry.registerPipeMetadata(meta);
            }
        }
    }
    /**
     * Registry that keeps track of classes that can be constructed via dependency injection (e.g.
     * injectables, directives, pipes).
     */
    class InjectableClassRegistry {
        constructor(host) {
            this.host = host;
            this.classes = new Set();
        }
        registerInjectable(declaration) {
            this.classes.add(declaration);
        }
        isInjectable(declaration) {
            // Figure out whether the class is injectable based on the registered classes, otherwise
            // fall back to looking at its members since we might not have been able register the class
            // if it was compiled already.
            return this.classes.has(declaration) || hasInjectableFields(declaration, this.host);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Given a reference to a directive, return a flattened version of its `DirectiveMeta` metadata
     * which includes metadata from its entire inheritance chain.
     *
     * The returned `DirectiveMeta` will either have `baseClass: null` if the inheritance chain could be
     * fully resolved, or `baseClass: 'dynamic'` if the inheritance chain could not be completely
     * followed.
     */
    function flattenInheritedDirectiveMetadata(reader, dir) {
        const topMeta = reader.getDirectiveMetadata(dir);
        if (topMeta === null) {
            throw new Error(`Metadata not found for directive: ${dir.debugName}`);
        }
        let inputs = {};
        let outputs = {};
        let coercedInputFields = new Set();
        let isDynamic = false;
        const addMetadata = (meta) => {
            if (meta.baseClass === 'dynamic') {
                isDynamic = true;
            }
            else if (meta.baseClass !== null) {
                const baseMeta = reader.getDirectiveMetadata(meta.baseClass);
                if (baseMeta !== null) {
                    addMetadata(baseMeta);
                }
                else {
                    // Missing metadata for the base class means it's effectively dynamic.
                    isDynamic = true;
                }
            }
            inputs = Object.assign(Object.assign({}, inputs), meta.inputs);
            outputs = Object.assign(Object.assign({}, outputs), meta.outputs);
            for (const coercedInputField of meta.coercedInputFields) {
                coercedInputFields.add(coercedInputField);
            }
        };
        addMetadata(topMeta);
        return Object.assign(Object.assign({}, topMeta), { inputs,
            outputs,
            coercedInputFields, baseClass: isDynamic ? 'dynamic' : null });
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Represents a value which cannot be determined statically.
     */
    class DynamicValue {
        constructor(node, reason, code) {
            this.node = node;
            this.reason = reason;
            this.code = code;
        }
        static fromDynamicInput(node, input) {
            return new DynamicValue(node, input, 0 /* DYNAMIC_INPUT */);
        }
        static fromDynamicString(node) {
            return new DynamicValue(node, undefined, 1 /* DYNAMIC_STRING */);
        }
        static fromExternalReference(node, ref) {
            return new DynamicValue(node, ref, 2 /* EXTERNAL_REFERENCE */);
        }
        static fromUnsupportedSyntax(node) {
            return new DynamicValue(node, undefined, 3 /* UNSUPPORTED_SYNTAX */);
        }
        static fromUnknownIdentifier(node) {
            return new DynamicValue(node, undefined, 4 /* UNKNOWN_IDENTIFIER */);
        }
        static fromInvalidExpressionType(node, value) {
            return new DynamicValue(node, value, 5 /* INVALID_EXPRESSION_TYPE */);
        }
        static fromUnknown(node) {
            return new DynamicValue(node, undefined, 6 /* UNKNOWN */);
        }
        isFromDynamicInput() {
            return this.code === 0 /* DYNAMIC_INPUT */;
        }
        isFromDynamicString() {
            return this.code === 1 /* DYNAMIC_STRING */;
        }
        isFromExternalReference() {
            return this.code === 2 /* EXTERNAL_REFERENCE */;
        }
        isFromUnsupportedSyntax() {
            return this.code === 3 /* UNSUPPORTED_SYNTAX */;
        }
        isFromUnknownIdentifier() {
            return this.code === 4 /* UNKNOWN_IDENTIFIER */;
        }
        isFromInvalidExpressionType() {
            return this.code === 5 /* INVALID_EXPRESSION_TYPE */;
        }
        isFromUnknown() {
            return this.code === 6 /* UNKNOWN */;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A collection of publicly exported declarations from a module. Each declaration is evaluated
     * lazily upon request.
     */
    class ResolvedModule {
        constructor(exports, evaluate) {
            this.exports = exports;
            this.evaluate = evaluate;
        }
        getExport(name) {
            if (!this.exports.has(name)) {
                return undefined;
            }
            return this.evaluate(this.exports.get(name));
        }
        getExports() {
            const map = new Map();
            this.exports.forEach((decl, name) => {
                map.set(name, this.evaluate(decl));
            });
            return map;
        }
    }
    /**
     * A value member of an enumeration.
     *
     * Contains a `Reference` to the enumeration itself, and the name of the referenced member.
     */
    class EnumValue {
        constructor(enumRef, name, resolved) {
            this.enumRef = enumRef;
            this.name = name;
            this.resolved = resolved;
        }
    }
    /**
     * An implementation of a known function that can be statically evaluated.
     * It could be a built-in function or method (such as `Array.prototype.slice`) or a TypeScript
     * helper (such as `__spread`).
     */
    class KnownFn {
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class ArraySliceBuiltinFn extends KnownFn {
        constructor(lhs) {
            super();
            this.lhs = lhs;
        }
        evaluate(node, args) {
            if (args.length === 0) {
                return this.lhs;
            }
            else {
                return DynamicValue.fromUnknown(node);
            }
        }
    }
    class ArrayConcatBuiltinFn extends KnownFn {
        constructor(lhs) {
            super();
            this.lhs = lhs;
        }
        evaluate(node, args) {
            const result = [...this.lhs];
            for (const arg of args) {
                if (arg instanceof DynamicValue) {
                    result.push(DynamicValue.fromDynamicInput(node, arg));
                }
                else if (Array.isArray(arg)) {
                    result.push(...arg);
                }
                else {
                    result.push(arg);
                }
            }
            return result;
        }
    }
    class ObjectAssignBuiltinFn extends KnownFn {
        evaluate(node, args) {
            if (args.length === 0) {
                return DynamicValue.fromUnsupportedSyntax(node);
            }
            for (const arg of args) {
                if (arg instanceof DynamicValue) {
                    return DynamicValue.fromDynamicInput(node, arg);
                }
                else if (!(arg instanceof Map)) {
                    return DynamicValue.fromUnsupportedSyntax(node);
                }
            }
            const [target, ...sources] = args;
            for (const source of sources) {
                source.forEach((value, key) => target.set(key, value));
            }
            return target;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // Use the same implementation we use for `Object.assign()`. Semantically these functions are the
    // same, so they can also share the same evaluation code.
    class AssignHelperFn extends ObjectAssignBuiltinFn {
    }
    // Used for both `__spread()` and `__spreadArrays()` TypeScript helper functions.
    class SpreadHelperFn extends KnownFn {
        evaluate(node, args) {
            const result = [];
            for (const arg of args) {
                if (arg instanceof DynamicValue) {
                    result.push(DynamicValue.fromDynamicInput(node, arg));
                }
                else if (Array.isArray(arg)) {
                    result.push(...arg);
                }
                else {
                    result.push(arg);
                }
            }
            return result;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /** Resolved value for the JavaScript global `Object` declaration. */
    const jsGlobalObjectValue = new Map([['assign', new ObjectAssignBuiltinFn()]]);
    /** Resolved value for the `__assign()` TypeScript helper declaration. */
    const assignTsHelperFn = new AssignHelperFn();
    /** Resolved value for the `__spread()` and `__spreadArrays()` TypeScript helper declarations. */
    const spreadTsHelperFn = new SpreadHelperFn();
    /**
     * Resolves the specified known declaration to a resolved value. For example,
     * the known JavaScript global `Object` will resolve to a `Map` that provides the
     * `assign` method with a built-in function. This enables evaluation of `Object.assign`.
     */
    function resolveKnownDeclaration(decl) {
        switch (decl) {
            case KnownDeclaration.JsGlobalObject:
                return jsGlobalObjectValue;
            case KnownDeclaration.TsHelperAssign:
                return assignTsHelperFn;
            case KnownDeclaration.TsHelperSpread:
            case KnownDeclaration.TsHelperSpreadArrays:
                return spreadTsHelperFn;
            default:
                throw new Error(`Cannot resolve known declaration. Received: ${KnownDeclaration[decl]}.`);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function literalBinaryOp(op) {
        return { op, literal: true };
    }
    function referenceBinaryOp(op) {
        return { op, literal: false };
    }
    const BINARY_OPERATORS = new Map([
        [ts.SyntaxKind.PlusToken, literalBinaryOp((a, b) => a + b)],
        [ts.SyntaxKind.MinusToken, literalBinaryOp((a, b) => a - b)],
        [ts.SyntaxKind.AsteriskToken, literalBinaryOp((a, b) => a * b)],
        [ts.SyntaxKind.SlashToken, literalBinaryOp((a, b) => a / b)],
        [ts.SyntaxKind.PercentToken, literalBinaryOp((a, b) => a % b)],
        [ts.SyntaxKind.AmpersandToken, literalBinaryOp((a, b) => a & b)],
        [ts.SyntaxKind.BarToken, literalBinaryOp((a, b) => a | b)],
        [ts.SyntaxKind.CaretToken, literalBinaryOp((a, b) => a ^ b)],
        [ts.SyntaxKind.LessThanToken, literalBinaryOp((a, b) => a < b)],
        [ts.SyntaxKind.LessThanEqualsToken, literalBinaryOp((a, b) => a <= b)],
        [ts.SyntaxKind.GreaterThanToken, literalBinaryOp((a, b) => a > b)],
        [ts.SyntaxKind.GreaterThanEqualsToken, literalBinaryOp((a, b) => a >= b)],
        [ts.SyntaxKind.EqualsEqualsToken, literalBinaryOp((a, b) => a == b)],
        [ts.SyntaxKind.EqualsEqualsEqualsToken, literalBinaryOp((a, b) => a === b)],
        [ts.SyntaxKind.ExclamationEqualsToken, literalBinaryOp((a, b) => a != b)],
        [ts.SyntaxKind.ExclamationEqualsEqualsToken, literalBinaryOp((a, b) => a !== b)],
        [ts.SyntaxKind.LessThanLessThanToken, literalBinaryOp((a, b) => a << b)],
        [ts.SyntaxKind.GreaterThanGreaterThanToken, literalBinaryOp((a, b) => a >> b)],
        [ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken, literalBinaryOp((a, b) => a >>> b)],
        [ts.SyntaxKind.AsteriskAsteriskToken, literalBinaryOp((a, b) => Math.pow(a, b))],
        [ts.SyntaxKind.AmpersandAmpersandToken, referenceBinaryOp((a, b) => a && b)],
        [ts.SyntaxKind.BarBarToken, referenceBinaryOp((a, b) => a || b)]
    ]);
    const UNARY_OPERATORS = new Map([
        [ts.SyntaxKind.TildeToken, a => ~a], [ts.SyntaxKind.MinusToken, a => -a],
        [ts.SyntaxKind.PlusToken, a => +a], [ts.SyntaxKind.ExclamationToken, a => !a]
    ]);
    class StaticInterpreter {
        constructor(host, checker, dependencyTracker) {
            this.host = host;
            this.checker = checker;
            this.dependencyTracker = dependencyTracker;
        }
        visit(node, context) {
            return this.visitExpression(node, context);
        }
        visitExpression(node, context) {
            let result;
            if (node.kind === ts.SyntaxKind.TrueKeyword) {
                return true;
            }
            else if (node.kind === ts.SyntaxKind.FalseKeyword) {
                return false;
            }
            else if (node.kind === ts.SyntaxKind.NullKeyword) {
                return null;
            }
            else if (ts.isStringLiteral(node)) {
                return node.text;
            }
            else if (ts.isNoSubstitutionTemplateLiteral(node)) {
                return node.text;
            }
            else if (ts.isTemplateExpression(node)) {
                result = this.visitTemplateExpression(node, context);
            }
            else if (ts.isNumericLiteral(node)) {
                return parseFloat(node.text);
            }
            else if (ts.isObjectLiteralExpression(node)) {
                result = this.visitObjectLiteralExpression(node, context);
            }
            else if (ts.isIdentifier(node)) {
                result = this.visitIdentifier(node, context);
            }
            else if (ts.isPropertyAccessExpression(node)) {
                result = this.visitPropertyAccessExpression(node, context);
            }
            else if (ts.isCallExpression(node)) {
                result = this.visitCallExpression(node, context);
            }
            else if (ts.isConditionalExpression(node)) {
                result = this.visitConditionalExpression(node, context);
            }
            else if (ts.isPrefixUnaryExpression(node)) {
                result = this.visitPrefixUnaryExpression(node, context);
            }
            else if (ts.isBinaryExpression(node)) {
                result = this.visitBinaryExpression(node, context);
            }
            else if (ts.isArrayLiteralExpression(node)) {
                result = this.visitArrayLiteralExpression(node, context);
            }
            else if (ts.isParenthesizedExpression(node)) {
                result = this.visitParenthesizedExpression(node, context);
            }
            else if (ts.isElementAccessExpression(node)) {
                result = this.visitElementAccessExpression(node, context);
            }
            else if (ts.isAsExpression(node)) {
                result = this.visitExpression(node.expression, context);
            }
            else if (ts.isNonNullExpression(node)) {
                result = this.visitExpression(node.expression, context);
            }
            else if (this.host.isClass(node)) {
                result = this.visitDeclaration(node, context);
            }
            else {
                return DynamicValue.fromUnsupportedSyntax(node);
            }
            if (result instanceof DynamicValue && result.node !== node) {
                return DynamicValue.fromDynamicInput(node, result);
            }
            return result;
        }
        visitArrayLiteralExpression(node, context) {
            const array = [];
            for (let i = 0; i < node.elements.length; i++) {
                const element = node.elements[i];
                if (ts.isSpreadElement(element)) {
                    array.push(...this.visitSpreadElement(element, context));
                }
                else {
                    array.push(this.visitExpression(element, context));
                }
            }
            return array;
        }
        visitObjectLiteralExpression(node, context) {
            const map = new Map();
            for (let i = 0; i < node.properties.length; i++) {
                const property = node.properties[i];
                if (ts.isPropertyAssignment(property)) {
                    const name = this.stringNameFromPropertyName(property.name, context);
                    // Check whether the name can be determined statically.
                    if (name === undefined) {
                        return DynamicValue.fromDynamicInput(node, DynamicValue.fromDynamicString(property.name));
                    }
                    map.set(name, this.visitExpression(property.initializer, context));
                }
                else if (ts.isShorthandPropertyAssignment(property)) {
                    const symbol = this.checker.getShorthandAssignmentValueSymbol(property);
                    if (symbol === undefined || symbol.valueDeclaration === undefined) {
                        map.set(property.name.text, DynamicValue.fromUnknown(property));
                    }
                    else {
                        map.set(property.name.text, this.visitDeclaration(symbol.valueDeclaration, context));
                    }
                }
                else if (ts.isSpreadAssignment(property)) {
                    const spread = this.visitExpression(property.expression, context);
                    if (spread instanceof DynamicValue) {
                        return DynamicValue.fromDynamicInput(node, spread);
                    }
                    else if (spread instanceof Map) {
                        spread.forEach((value, key) => map.set(key, value));
                    }
                    else if (spread instanceof ResolvedModule) {
                        spread.getExports().forEach((value, key) => map.set(key, value));
                    }
                    else {
                        return DynamicValue.fromDynamicInput(node, DynamicValue.fromInvalidExpressionType(property, spread));
                    }
                }
                else {
                    return DynamicValue.fromUnknown(node);
                }
            }
            return map;
        }
        visitTemplateExpression(node, context) {
            const pieces = [node.head.text];
            for (let i = 0; i < node.templateSpans.length; i++) {
                const span = node.templateSpans[i];
                const value = literal$1(this.visit(span.expression, context), () => DynamicValue.fromDynamicString(span.expression));
                if (value instanceof DynamicValue) {
                    return DynamicValue.fromDynamicInput(node, value);
                }
                pieces.push(`${value}`, span.literal.text);
            }
            return pieces.join('');
        }
        visitIdentifier(node, context) {
            const decl = this.host.getDeclarationOfIdentifier(node);
            if (decl === null) {
                if (node.originalKeywordKind === ts.SyntaxKind.UndefinedKeyword) {
                    return undefined;
                }
                else {
                    return DynamicValue.fromUnknownIdentifier(node);
                }
            }
            if (decl.known !== null) {
                return resolveKnownDeclaration(decl.known);
            }
            else if (isConcreteDeclaration(decl) && decl.identity !== null &&
                decl.identity.kind === 0 /* DownleveledEnum */) {
                return this.getResolvedEnum(decl.node, decl.identity.enumMembers, context);
            }
            const declContext = Object.assign(Object.assign({}, context), joinModuleContext(context, node, decl));
            // The identifier's declaration is either concrete (a ts.Declaration exists for it) or inline
            // (a direct reference to a ts.Expression).
            // TODO(alxhub): remove cast once TS is upgraded in g3.
            const result = decl.node !== null ?
                this.visitDeclaration(decl.node, declContext) :
                this.visitExpression(decl.expression, declContext);
            if (result instanceof Reference$1) {
                // Only record identifiers to non-synthetic references. Synthetic references may not have the
                // same value at runtime as they do at compile time, so it's not legal to refer to them by the
                // identifier here.
                if (!result.synthetic) {
                    result.addIdentifier(node);
                }
            }
            else if (result instanceof DynamicValue) {
                return DynamicValue.fromDynamicInput(node, result);
            }
            return result;
        }
        visitDeclaration(node, context) {
            if (this.dependencyTracker !== null) {
                this.dependencyTracker.addDependency(context.originatingFile, node.getSourceFile());
            }
            if (this.host.isClass(node)) {
                return this.getReference(node, context);
            }
            else if (ts.isVariableDeclaration(node)) {
                return this.visitVariableDeclaration(node, context);
            }
            else if (ts.isParameter(node) && context.scope.has(node)) {
                return context.scope.get(node);
            }
            else if (ts.isExportAssignment(node)) {
                return this.visitExpression(node.expression, context);
            }
            else if (ts.isEnumDeclaration(node)) {
                return this.visitEnumDeclaration(node, context);
            }
            else if (ts.isSourceFile(node)) {
                return this.visitSourceFile(node, context);
            }
            else if (ts.isBindingElement(node)) {
                return this.visitBindingElement(node, context);
            }
            else {
                return this.getReference(node, context);
            }
        }
        visitVariableDeclaration(node, context) {
            const value = this.host.getVariableValue(node);
            if (value !== null) {
                return this.visitExpression(value, context);
            }
            else if (isVariableDeclarationDeclared(node)) {
                return this.getReference(node, context);
            }
            else {
                return undefined;
            }
        }
        visitEnumDeclaration(node, context) {
            const enumRef = this.getReference(node, context);
            const map = new Map();
            node.members.forEach(member => {
                const name = this.stringNameFromPropertyName(member.name, context);
                if (name !== undefined) {
                    const resolved = member.initializer && this.visit(member.initializer, context);
                    map.set(name, new EnumValue(enumRef, name, resolved));
                }
            });
            return map;
        }
        visitElementAccessExpression(node, context) {
            const lhs = this.visitExpression(node.expression, context);
            if (lhs instanceof DynamicValue) {
                return DynamicValue.fromDynamicInput(node, lhs);
            }
            const rhs = this.visitExpression(node.argumentExpression, context);
            if (rhs instanceof DynamicValue) {
                return DynamicValue.fromDynamicInput(node, rhs);
            }
            if (typeof rhs !== 'string' && typeof rhs !== 'number') {
                return DynamicValue.fromInvalidExpressionType(node, rhs);
            }
            return this.accessHelper(node, lhs, rhs, context);
        }
        visitPropertyAccessExpression(node, context) {
            const lhs = this.visitExpression(node.expression, context);
            const rhs = node.name.text;
            // TODO: handle reference to class declaration.
            if (lhs instanceof DynamicValue) {
                return DynamicValue.fromDynamicInput(node, lhs);
            }
            return this.accessHelper(node, lhs, rhs, context);
        }
        visitSourceFile(node, context) {
            const declarations = this.host.getExportsOfModule(node);
            if (declarations === null) {
                return DynamicValue.fromUnknown(node);
            }
            return new ResolvedModule(declarations, decl => {
                if (decl.known !== null) {
                    return resolveKnownDeclaration(decl.known);
                }
                const declContext = Object.assign(Object.assign({}, context), joinModuleContext(context, node, decl));
                // Visit both concrete and inline declarations.
                // TODO(alxhub): remove cast once TS is upgraded in g3.
                return decl.node !== null ?
                    this.visitDeclaration(decl.node, declContext) :
                    this.visitExpression(decl.expression, declContext);
            });
        }
        accessHelper(node, lhs, rhs, context) {
            const strIndex = `${rhs}`;
            if (lhs instanceof Map) {
                if (lhs.has(strIndex)) {
                    return lhs.get(strIndex);
                }
                else {
                    return undefined;
                }
            }
            else if (lhs instanceof ResolvedModule) {
                return lhs.getExport(strIndex);
            }
            else if (Array.isArray(lhs)) {
                if (rhs === 'length') {
                    return lhs.length;
                }
                else if (rhs === 'slice') {
                    return new ArraySliceBuiltinFn(lhs);
                }
                else if (rhs === 'concat') {
                    return new ArrayConcatBuiltinFn(lhs);
                }
                if (typeof rhs !== 'number' || !Number.isInteger(rhs)) {
                    return DynamicValue.fromInvalidExpressionType(node, rhs);
                }
                return lhs[rhs];
            }
            else if (lhs instanceof Reference$1) {
                const ref = lhs.node;
                if (this.host.isClass(ref)) {
                    const module = owningModule(context, lhs.bestGuessOwningModule);
                    let value = undefined;
                    const member = this.host.getMembersOfClass(ref).find(member => member.isStatic && member.name === strIndex);
                    if (member !== undefined) {
                        if (member.value !== null) {
                            value = this.visitExpression(member.value, context);
                        }
                        else if (member.implementation !== null) {
                            value = new Reference$1(member.implementation, module);
                        }
                        else if (member.node) {
                            value = new Reference$1(member.node, module);
                        }
                    }
                    return value;
                }
                else if (isDeclaration(ref)) {
                    return DynamicValue.fromDynamicInput(node, DynamicValue.fromExternalReference(ref, lhs));
                }
            }
            else if (lhs instanceof DynamicValue) {
                return DynamicValue.fromDynamicInput(node, lhs);
            }
            return DynamicValue.fromUnknown(node);
        }
        visitCallExpression(node, context) {
            const lhs = this.visitExpression(node.expression, context);
            if (lhs instanceof DynamicValue) {
                return DynamicValue.fromDynamicInput(node, lhs);
            }
            // If the call refers to a builtin function, attempt to evaluate the function.
            if (lhs instanceof KnownFn) {
                return lhs.evaluate(node, this.evaluateFunctionArguments(node, context));
            }
            if (!(lhs instanceof Reference$1)) {
                return DynamicValue.fromInvalidExpressionType(node.expression, lhs);
            }
            const fn = this.host.getDefinitionOfFunction(lhs.node);
            if (fn === null) {
                return DynamicValue.fromInvalidExpressionType(node.expression, lhs);
            }
            if (!isFunctionOrMethodReference(lhs)) {
                return DynamicValue.fromInvalidExpressionType(node.expression, lhs);
            }
            // If the function is foreign (declared through a d.ts file), attempt to resolve it with the
            // foreignFunctionResolver, if one is specified.
            if (fn.body === null) {
                let expr = null;
                if (context.foreignFunctionResolver) {
                    expr = context.foreignFunctionResolver(lhs, node.arguments);
                }
                if (expr === null) {
                    return DynamicValue.fromDynamicInput(node, DynamicValue.fromExternalReference(node.expression, lhs));
                }
                // If the function is declared in a different file, resolve the foreign function expression
                // using the absolute module name of that file (if any).
                if (lhs.bestGuessOwningModule !== null) {
                    context = Object.assign(Object.assign({}, context), { absoluteModuleName: lhs.bestGuessOwningModule.specifier, resolutionContext: node.getSourceFile().fileName });
                }
                return this.visitFfrExpression(expr, context);
            }
            let res = this.visitFunctionBody(node, fn, context);
            // If the result of attempting to resolve the function body was a DynamicValue, attempt to use
            // the foreignFunctionResolver if one is present. This could still potentially yield a usable
            // value.
            if (res instanceof DynamicValue && context.foreignFunctionResolver !== undefined) {
                const ffrExpr = context.foreignFunctionResolver(lhs, node.arguments);
                if (ffrExpr !== null) {
                    // The foreign function resolver was able to extract an expression from this function. See
                    // if that expression leads to a non-dynamic result.
                    const ffrRes = this.visitFfrExpression(ffrExpr, context);
                    if (!(ffrRes instanceof DynamicValue)) {
                        // FFR yielded an actual result that's not dynamic, so use that instead of the original
                        // resolution.
                        res = ffrRes;
                    }
                }
            }
            return res;
        }
        /**
         * Visit an expression which was extracted from a foreign-function resolver.
         *
         * This will process the result and ensure it's correct for FFR-resolved values, including marking
         * `Reference`s as synthetic.
         */
        visitFfrExpression(expr, context) {
            const res = this.visitExpression(expr, context);
            if (res instanceof Reference$1) {
                // This Reference was created synthetically, via a foreign function resolver. The real
                // runtime value of the function expression may be different than the foreign function
                // resolved value, so mark the Reference as synthetic to avoid it being misinterpreted.
                res.synthetic = true;
            }
            return res;
        }
        visitFunctionBody(node, fn, context) {
            if (fn.body === null || fn.body.length !== 1 || !ts.isReturnStatement(fn.body[0])) {
                return DynamicValue.fromUnknown(node);
            }
            const ret = fn.body[0];
            const args = this.evaluateFunctionArguments(node, context);
            const newScope = new Map();
            const calleeContext = Object.assign(Object.assign({}, context), { scope: newScope });
            fn.parameters.forEach((param, index) => {
                let arg = args[index];
                if (param.node.dotDotDotToken !== undefined) {
                    arg = args.slice(index);
                }
                if (arg === undefined && param.initializer !== null) {
                    arg = this.visitExpression(param.initializer, calleeContext);
                }
                newScope.set(param.node, arg);
            });
            return ret.expression !== undefined ? this.visitExpression(ret.expression, calleeContext) :
                undefined;
        }
        visitConditionalExpression(node, context) {
            const condition = this.visitExpression(node.condition, context);
            if (condition instanceof DynamicValue) {
                return DynamicValue.fromDynamicInput(node, condition);
            }
            if (condition) {
                return this.visitExpression(node.whenTrue, context);
            }
            else {
                return this.visitExpression(node.whenFalse, context);
            }
        }
        visitPrefixUnaryExpression(node, context) {
            const operatorKind = node.operator;
            if (!UNARY_OPERATORS.has(operatorKind)) {
                return DynamicValue.fromUnsupportedSyntax(node);
            }
            const op = UNARY_OPERATORS.get(operatorKind);
            const value = this.visitExpression(node.operand, context);
            if (value instanceof DynamicValue) {
                return DynamicValue.fromDynamicInput(node, value);
            }
            else {
                return op(value);
            }
        }
        visitBinaryExpression(node, context) {
            const tokenKind = node.operatorToken.kind;
            if (!BINARY_OPERATORS.has(tokenKind)) {
                return DynamicValue.fromUnsupportedSyntax(node);
            }
            const opRecord = BINARY_OPERATORS.get(tokenKind);
            let lhs, rhs;
            if (opRecord.literal) {
                lhs = literal$1(this.visitExpression(node.left, context), value => DynamicValue.fromInvalidExpressionType(node.left, value));
                rhs = literal$1(this.visitExpression(node.right, context), value => DynamicValue.fromInvalidExpressionType(node.right, value));
            }
            else {
                lhs = this.visitExpression(node.left, context);
                rhs = this.visitExpression(node.right, context);
            }
            if (lhs instanceof DynamicValue) {
                return DynamicValue.fromDynamicInput(node, lhs);
            }
            else if (rhs instanceof DynamicValue) {
                return DynamicValue.fromDynamicInput(node, rhs);
            }
            else {
                return opRecord.op(lhs, rhs);
            }
        }
        visitParenthesizedExpression(node, context) {
            return this.visitExpression(node.expression, context);
        }
        evaluateFunctionArguments(node, context) {
            const args = [];
            for (const arg of node.arguments) {
                if (ts.isSpreadElement(arg)) {
                    args.push(...this.visitSpreadElement(arg, context));
                }
                else {
                    args.push(this.visitExpression(arg, context));
                }
            }
            return args;
        }
        visitSpreadElement(node, context) {
            const spread = this.visitExpression(node.expression, context);
            if (spread instanceof DynamicValue) {
                return [DynamicValue.fromDynamicInput(node, spread)];
            }
            else if (!Array.isArray(spread)) {
                return [DynamicValue.fromInvalidExpressionType(node, spread)];
            }
            else {
                return spread;
            }
        }
        visitBindingElement(node, context) {
            const path = [];
            let closestDeclaration = node;
            while (ts.isBindingElement(closestDeclaration) ||
                ts.isArrayBindingPattern(closestDeclaration) ||
                ts.isObjectBindingPattern(closestDeclaration)) {
                if (ts.isBindingElement(closestDeclaration)) {
                    path.unshift(closestDeclaration);
                }
                closestDeclaration = closestDeclaration.parent;
            }
            if (!ts.isVariableDeclaration(closestDeclaration) ||
                closestDeclaration.initializer === undefined) {
                return DynamicValue.fromUnknown(node);
            }
            let value = this.visit(closestDeclaration.initializer, context);
            for (const element of path) {
                let key;
                if (ts.isArrayBindingPattern(element.parent)) {
                    key = element.parent.elements.indexOf(element);
                }
                else {
                    const name = element.propertyName || element.name;
                    if (ts.isIdentifier(name)) {
                        key = name.text;
                    }
                    else {
                        return DynamicValue.fromUnknown(element);
                    }
                }
                value = this.accessHelper(element, value, key, context);
                if (value instanceof DynamicValue) {
                    return value;
                }
            }
            return value;
        }
        stringNameFromPropertyName(node, context) {
            if (ts.isIdentifier(node) || ts.isStringLiteral(node) || ts.isNumericLiteral(node)) {
                return node.text;
            }
            else if (ts.isComputedPropertyName(node)) {
                const literal = this.visitExpression(node.expression, context);
                return typeof literal === 'string' ? literal : undefined;
            }
            else {
                return undefined;
            }
        }
        getResolvedEnum(node, enumMembers, context) {
            const enumRef = this.getReference(node, context);
            const map = new Map();
            enumMembers.forEach(member => {
                const name = this.stringNameFromPropertyName(member.name, context);
                if (name !== undefined) {
                    const resolved = this.visit(member.initializer, context);
                    map.set(name, new EnumValue(enumRef, name, resolved));
                }
            });
            return map;
        }
        getReference(node, context) {
            return new Reference$1(node, owningModule(context));
        }
    }
    function isFunctionOrMethodReference(ref) {
        return ts.isFunctionDeclaration(ref.node) || ts.isMethodDeclaration(ref.node) ||
            ts.isFunctionExpression(ref.node);
    }
    function literal$1(value, reject) {
        if (value instanceof EnumValue) {
            value = value.resolved;
        }
        if (value instanceof DynamicValue || value === null || value === undefined ||
            typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
            return value;
        }
        return reject(value);
    }
    function isVariableDeclarationDeclared(node) {
        if (node.parent === undefined || !ts.isVariableDeclarationList(node.parent)) {
            return false;
        }
        const declList = node.parent;
        if (declList.parent === undefined || !ts.isVariableStatement(declList.parent)) {
            return false;
        }
        const varStmt = declList.parent;
        return varStmt.modifiers !== undefined &&
            varStmt.modifiers.some(mod => mod.kind === ts.SyntaxKind.DeclareKeyword);
    }
    const EMPTY = {};
    function joinModuleContext(existing, node, decl) {
        if (decl.viaModule !== null && decl.viaModule !== existing.absoluteModuleName) {
            return {
                absoluteModuleName: decl.viaModule,
                resolutionContext: node.getSourceFile().fileName,
            };
        }
        else {
            return EMPTY;
        }
    }
    function owningModule(context, override = null) {
        let specifier = context.absoluteModuleName;
        if (override !== null) {
            specifier = override.specifier;
        }
        if (specifier !== null) {
            return {
                specifier,
                resolutionContext: context.resolutionContext,
            };
        }
        else {
            return null;
        }
    }
    /**
     * Helper type guard to workaround a narrowing limitation in g3, where testing for
     * `decl.node !== null` would not narrow `decl` to be of type `ConcreteDeclaration`.
     */
    function isConcreteDeclaration(decl) {
        return decl.node !== null;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class PartialEvaluator {
        constructor(host, checker, dependencyTracker) {
            this.host = host;
            this.checker = checker;
            this.dependencyTracker = dependencyTracker;
        }
        evaluate(expr, foreignFunctionResolver) {
            const interpreter = new StaticInterpreter(this.host, this.checker, this.dependencyTracker);
            const sourceFile = expr.getSourceFile();
            return interpreter.visit(expr, {
                originatingFile: sourceFile,
                absoluteModuleName: null,
                resolutionContext: sourceFile.fileName,
                scope: new Map(),
                foreignFunctionResolver,
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var HandlerPrecedence;
    (function (HandlerPrecedence) {
        /**
         * Handler with PRIMARY precedence cannot overlap - there can only be one on a given class.
         *
         * If more than one PRIMARY handler matches a class, an error is produced.
         */
        HandlerPrecedence[HandlerPrecedence["PRIMARY"] = 0] = "PRIMARY";
        /**
         * Handlers with SHARED precedence can match any class, possibly in addition to a single PRIMARY
         * handler.
         *
         * It is not an error for a class to have any number of SHARED handlers.
         */
        HandlerPrecedence[HandlerPrecedence["SHARED"] = 1] = "SHARED";
        /**
         * Handlers with WEAK precedence that match a class are ignored if any handlers with stronger
         * precedence match a class.
         */
        HandlerPrecedence[HandlerPrecedence["WEAK"] = 2] = "WEAK";
    })(HandlerPrecedence || (HandlerPrecedence = {}));
    /**
     * A set of options which can be passed to a `DecoratorHandler` by a consumer, to tailor the output
     * of compilation beyond the decorators themselves.
     */
    var HandlerFlags;
    (function (HandlerFlags) {
        /**
         * No flags set.
         */
        HandlerFlags[HandlerFlags["NONE"] = 0] = "NONE";
        /**
         * Indicates that this decorator is fully inherited from its parent at runtime. In addition to
         * normally inherited aspects such as inputs and queries, full inheritance applies to every aspect
         * of the component or directive, such as the template function itself.
         *
         * Its primary effect is to cause the `CopyDefinitionFeature` to be applied to the definition
         * being compiled. See that class for more information.
         */
        HandlerFlags[HandlerFlags["FULL_INHERITANCE"] = 1] = "FULL_INHERITANCE";
    })(HandlerFlags || (HandlerFlags = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function aliasTransformFactory(exportStatements) {
        return (context) => {
            return (file) => {
                if (ts.isBundle(file) || !exportStatements.has(file.fileName)) {
                    return file;
                }
                const statements = [...file.statements];
                exportStatements.get(file.fileName).forEach(([moduleName, symbolName], aliasName) => {
                    const stmt = ts.createExportDeclaration(
                    /* decorators */ undefined, 
                    /* modifiers */ undefined, 
                    /* exportClause */ ts.createNamedExports([ts.createExportSpecifier(
                        /* propertyName */ symbolName, 
                        /* name */ aliasName)]), 
                    /* moduleSpecifier */ ts.createStringLiteral(moduleName));
                    statements.push(stmt);
                });
                file = ts.getMutableClone(file);
                file.statements = ts.createNodeArray(statements);
                return file;
            };
        };
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var TraitState;
    (function (TraitState) {
        /**
         * Pending traits are freshly created and have never been analyzed.
         */
        TraitState[TraitState["PENDING"] = 1] = "PENDING";
        /**
         * Analyzed traits have successfully been analyzed, but are pending resolution.
         */
        TraitState[TraitState["ANALYZED"] = 2] = "ANALYZED";
        /**
         * Resolved traits have successfully been analyzed and resolved and are ready for compilation.
         */
        TraitState[TraitState["RESOLVED"] = 4] = "RESOLVED";
        /**
         * Errored traits have failed either analysis or resolution and as a result contain diagnostics
         * describing the failure(s).
         */
        TraitState[TraitState["ERRORED"] = 8] = "ERRORED";
        /**
         * Skipped traits are no longer considered for compilation.
         */
        TraitState[TraitState["SKIPPED"] = 16] = "SKIPPED";
    })(TraitState || (TraitState = {}));
    /**
     * The value side of `Trait` exposes a helper to create a `Trait` in a pending state (by delegating
     * to `TraitImpl`).
     */
    const Trait = {
        pending: (handler, detected) => TraitImpl.pending(handler, detected),
    };
    /**
     * An implementation of the `Trait` type which transitions safely between the various
     * `TraitState`s.
     */
    class TraitImpl {
        constructor(handler, detected) {
            this.state = TraitState.PENDING;
            this.analysis = null;
            this.resolution = null;
            this.diagnostics = null;
            this.handler = handler;
            this.detected = detected;
        }
        toAnalyzed(analysis) {
            // Only pending traits can be analyzed.
            this.assertTransitionLegal(TraitState.PENDING, TraitState.ANALYZED);
            this.analysis = analysis;
            this.state = TraitState.ANALYZED;
            return this;
        }
        toErrored(diagnostics) {
            // Pending traits (during analysis) or analyzed traits (during resolution) can produce
            // diagnostics and enter an errored state.
            this.assertTransitionLegal(TraitState.PENDING | TraitState.ANALYZED, TraitState.RESOLVED);
            this.diagnostics = diagnostics;
            this.analysis = null;
            this.state = TraitState.ERRORED;
            return this;
        }
        toResolved(resolution) {
            // Only analyzed traits can be resolved.
            this.assertTransitionLegal(TraitState.ANALYZED, TraitState.RESOLVED);
            this.resolution = resolution;
            this.state = TraitState.RESOLVED;
            return this;
        }
        toSkipped() {
            // Only pending traits can be skipped.
            this.assertTransitionLegal(TraitState.PENDING, TraitState.SKIPPED);
            this.state = TraitState.SKIPPED;
            return this;
        }
        /**
         * Verifies that the trait is currently in one of the `allowedState`s.
         *
         * If correctly used, the `Trait` type and transition methods prevent illegal transitions from
         * occurring. However, if a reference to the `TraitImpl` instance typed with the previous
         * interface is retained after calling one of its transition methods, it will allow for illegal
         * transitions to take place. Hence, this assertion provides a little extra runtime protection.
         */
        assertTransitionLegal(allowedState, transitionTo) {
            if (!(this.state & allowedState)) {
                throw new Error(`Assertion failure: cannot transition from ${TraitState[this.state]} to ${TraitState[transitionTo]}.`);
            }
        }
        /**
         * Construct a new `TraitImpl` in the pending state.
         */
        static pending(handler, detected) {
            return new TraitImpl(handler, detected);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * The heart of Angular compilation.
     *
     * The `TraitCompiler` is responsible for processing all classes in the program. Any time a
     * `DecoratorHandler` matches a class, a "trait" is created to represent that Angular aspect of the
     * class (such as the class having a component definition).
     *
     * The `TraitCompiler` transitions each trait through the various phases of compilation, culminating
     * in the production of `CompileResult`s instructing the compiler to apply various mutations to the
     * class (like adding fields or type declarations).
     */
    class TraitCompiler {
        constructor(handlers, reflector, perf, incrementalBuild, compileNonExportedClasses, dtsTransforms) {
            this.handlers = handlers;
            this.reflector = reflector;
            this.perf = perf;
            this.incrementalBuild = incrementalBuild;
            this.compileNonExportedClasses = compileNonExportedClasses;
            this.dtsTransforms = dtsTransforms;
            /**
             * Maps class declarations to their `ClassRecord`, which tracks the Ivy traits being applied to
             * those classes.
             */
            this.classes = new Map();
            /**
             * Maps source files to any class declaration(s) within them which have been discovered to contain
             * Ivy traits.
             */
            this.fileToClasses = new Map();
            this.reexportMap = new Map();
            this.handlersByName = new Map();
            for (const handler of handlers) {
                this.handlersByName.set(handler.name, handler);
            }
        }
        analyzeSync(sf) {
            this.analyze(sf, false);
        }
        analyzeAsync(sf) {
            return this.analyze(sf, true);
        }
        analyze(sf, preanalyze) {
            // We shouldn't analyze declaration files.
            if (sf.isDeclarationFile) {
                return undefined;
            }
            // analyze() really wants to return `Promise<void>|void`, but TypeScript cannot narrow a return
            // type of 'void', so `undefined` is used instead.
            const promises = [];
            const priorWork = this.incrementalBuild.priorWorkFor(sf);
            if (priorWork !== null) {
                for (const priorRecord of priorWork) {
                    this.adopt(priorRecord);
                }
                // Skip the rest of analysis, as this file's prior traits are being reused.
                return;
            }
            const visit = (node) => {
                if (this.reflector.isClass(node)) {
                    this.analyzeClass(node, preanalyze ? promises : null);
                }
                ts.forEachChild(node, visit);
            };
            visit(sf);
            if (preanalyze && promises.length > 0) {
                return Promise.all(promises).then(() => undefined);
            }
            else {
                return undefined;
            }
        }
        recordFor(clazz) {
            if (this.classes.has(clazz)) {
                return this.classes.get(clazz);
            }
            else {
                return null;
            }
        }
        recordsFor(sf) {
            if (!this.fileToClasses.has(sf)) {
                return null;
            }
            const records = [];
            for (const clazz of this.fileToClasses.get(sf)) {
                records.push(this.classes.get(clazz));
            }
            return records;
        }
        /**
         * Import a `ClassRecord` from a previous compilation.
         *
         * Traits from the `ClassRecord` have accurate metadata, but the `handler` is from the old program
         * and needs to be updated (matching is done by name). A new pending trait is created and then
         * transitioned to analyzed using the previous analysis. If the trait is in the errored state,
         * instead the errors are copied over.
         */
        adopt(priorRecord) {
            const record = {
                hasPrimaryHandler: priorRecord.hasPrimaryHandler,
                hasWeakHandlers: priorRecord.hasWeakHandlers,
                metaDiagnostics: priorRecord.metaDiagnostics,
                node: priorRecord.node,
                traits: [],
            };
            for (const priorTrait of priorRecord.traits) {
                const handler = this.handlersByName.get(priorTrait.handler.name);
                let trait = Trait.pending(handler, priorTrait.detected);
                if (priorTrait.state === TraitState.ANALYZED || priorTrait.state === TraitState.RESOLVED) {
                    trait = trait.toAnalyzed(priorTrait.analysis);
                    if (trait.handler.register !== undefined) {
                        trait.handler.register(record.node, trait.analysis);
                    }
                }
                else if (priorTrait.state === TraitState.SKIPPED) {
                    trait = trait.toSkipped();
                }
                else if (priorTrait.state === TraitState.ERRORED) {
                    trait = trait.toErrored(priorTrait.diagnostics);
                }
                record.traits.push(trait);
            }
            this.classes.set(record.node, record);
            const sf = record.node.getSourceFile();
            if (!this.fileToClasses.has(sf)) {
                this.fileToClasses.set(sf, new Set());
            }
            this.fileToClasses.get(sf).add(record.node);
        }
        scanClassForTraits(clazz) {
            if (!this.compileNonExportedClasses && !isExported(clazz)) {
                return null;
            }
            const decorators = this.reflector.getDecoratorsOfDeclaration(clazz);
            return this.detectTraits(clazz, decorators);
        }
        detectTraits(clazz, decorators) {
            let record = this.recordFor(clazz);
            let foundTraits = [];
            for (const handler of this.handlers) {
                const result = handler.detect(clazz, decorators);
                if (result === undefined) {
                    continue;
                }
                const isPrimaryHandler = handler.precedence === HandlerPrecedence.PRIMARY;
                const isWeakHandler = handler.precedence === HandlerPrecedence.WEAK;
                const trait = Trait.pending(handler, result);
                foundTraits.push(trait);
                if (record === null) {
                    // This is the first handler to match this class. This path is a fast path through which
                    // most classes will flow.
                    record = {
                        node: clazz,
                        traits: [trait],
                        metaDiagnostics: null,
                        hasPrimaryHandler: isPrimaryHandler,
                        hasWeakHandlers: isWeakHandler,
                    };
                    this.classes.set(clazz, record);
                    const sf = clazz.getSourceFile();
                    if (!this.fileToClasses.has(sf)) {
                        this.fileToClasses.set(sf, new Set());
                    }
                    this.fileToClasses.get(sf).add(clazz);
                }
                else {
                    // This is at least the second handler to match this class. This is a slower path that some
                    // classes will go through, which validates that the set of decorators applied to the class
                    // is valid.
                    // Validate according to rules as follows:
                    //
                    // * WEAK handlers are removed if a non-WEAK handler matches.
                    // * Only one PRIMARY handler can match at a time. Any other PRIMARY handler matching a
                    //   class with an existing PRIMARY handler is an error.
                    if (!isWeakHandler && record.hasWeakHandlers) {
                        // The current handler is not a WEAK handler, but the class has other WEAK handlers.
                        // Remove them.
                        record.traits =
                            record.traits.filter(field => field.handler.precedence !== HandlerPrecedence.WEAK);
                        record.hasWeakHandlers = false;
                    }
                    else if (isWeakHandler && !record.hasWeakHandlers) {
                        // The current handler is a WEAK handler, but the class has non-WEAK handlers already.
                        // Drop the current one.
                        continue;
                    }
                    if (isPrimaryHandler && record.hasPrimaryHandler) {
                        // The class already has a PRIMARY handler, and another one just matched.
                        record.metaDiagnostics = [{
                                category: ts.DiagnosticCategory.Error,
                                code: Number('-99' + ErrorCode.DECORATOR_COLLISION),
                                file: getSourceFile(clazz),
                                start: clazz.getStart(undefined, false),
                                length: clazz.getWidth(),
                                messageText: 'Two incompatible decorators on class',
                            }];
                        record.traits = foundTraits = [];
                        break;
                    }
                    // Otherwise, it's safe to accept the multiple decorators here. Update some of the metadata
                    // regarding this class.
                    record.traits.push(trait);
                    record.hasPrimaryHandler = record.hasPrimaryHandler || isPrimaryHandler;
                }
            }
            return foundTraits.length > 0 ? foundTraits : null;
        }
        analyzeClass(clazz, preanalyzeQueue) {
            const traits = this.scanClassForTraits(clazz);
            if (traits === null) {
                // There are no Ivy traits on the class, so it can safely be skipped.
                return;
            }
            for (const trait of traits) {
                const analyze = () => this.analyzeTrait(clazz, trait);
                let preanalysis = null;
                if (preanalyzeQueue !== null && trait.handler.preanalyze !== undefined) {
                    // Attempt to run preanalysis. This could fail with a `FatalDiagnosticError`; catch it if it
                    // does.
                    try {
                        preanalysis = trait.handler.preanalyze(clazz, trait.detected.metadata) || null;
                    }
                    catch (err) {
                        if (err instanceof FatalDiagnosticError) {
                            trait.toErrored([err.toDiagnostic()]);
                            return;
                        }
                        else {
                            throw err;
                        }
                    }
                }
                if (preanalysis !== null) {
                    preanalyzeQueue.push(preanalysis.then(analyze));
                }
                else {
                    analyze();
                }
            }
        }
        analyzeTrait(clazz, trait, flags) {
            if (trait.state !== TraitState.PENDING) {
                throw new Error(`Attempt to analyze trait of ${clazz.name.text} in state ${TraitState[trait.state]} (expected DETECTED)`);
            }
            // Attempt analysis. This could fail with a `FatalDiagnosticError`; catch it if it does.
            let result;
            try {
                result = trait.handler.analyze(clazz, trait.detected.metadata, flags);
            }
            catch (err) {
                if (err instanceof FatalDiagnosticError) {
                    trait = trait.toErrored([err.toDiagnostic()]);
                    return;
                }
                else {
                    throw err;
                }
            }
            if (result.diagnostics !== undefined) {
                trait = trait.toErrored(result.diagnostics);
            }
            else if (result.analysis !== undefined) {
                // Analysis was successful. Trigger registration.
                if (trait.handler.register !== undefined) {
                    trait.handler.register(clazz, result.analysis);
                }
                // Successfully analyzed and registered.
                trait = trait.toAnalyzed(result.analysis);
            }
            else {
                trait = trait.toSkipped();
            }
        }
        resolve() {
            const classes = Array.from(this.classes.keys());
            for (const clazz of classes) {
                const record = this.classes.get(clazz);
                for (let trait of record.traits) {
                    const handler = trait.handler;
                    switch (trait.state) {
                        case TraitState.SKIPPED:
                        case TraitState.ERRORED:
                            continue;
                        case TraitState.PENDING:
                            throw new Error(`Resolving a trait that hasn't been analyzed: ${clazz.name.text} / ${Object.getPrototypeOf(trait.handler).constructor.name}`);
                        case TraitState.RESOLVED:
                            throw new Error(`Resolving an already resolved trait`);
                    }
                    if (handler.resolve === undefined) {
                        // No resolution of this trait needed - it's considered successful by default.
                        trait = trait.toResolved(null);
                        continue;
                    }
                    let result;
                    try {
                        result = handler.resolve(clazz, trait.analysis);
                    }
                    catch (err) {
                        if (err instanceof FatalDiagnosticError) {
                            trait = trait.toErrored([err.toDiagnostic()]);
                            continue;
                        }
                        else {
                            throw err;
                        }
                    }
                    if (result.diagnostics !== undefined && result.diagnostics.length > 0) {
                        trait = trait.toErrored(result.diagnostics);
                    }
                    else {
                        if (result.data !== undefined) {
                            trait = trait.toResolved(result.data);
                        }
                        else {
                            trait = trait.toResolved(null);
                        }
                    }
                    if (result.reexports !== undefined) {
                        const fileName = clazz.getSourceFile().fileName;
                        if (!this.reexportMap.has(fileName)) {
                            this.reexportMap.set(fileName, new Map());
                        }
                        const fileReexports = this.reexportMap.get(fileName);
                        for (const reexport of result.reexports) {
                            fileReexports.set(reexport.asAlias, [reexport.fromModule, reexport.symbolName]);
                        }
                    }
                }
            }
        }
        /**
         * Generate type-checking code into the `TypeCheckContext` for any components within the given
         * `ts.SourceFile`.
         */
        typeCheck(sf, ctx) {
            if (!this.fileToClasses.has(sf)) {
                return;
            }
            for (const clazz of this.fileToClasses.get(sf)) {
                const record = this.classes.get(clazz);
                for (const trait of record.traits) {
                    if (trait.state !== TraitState.RESOLVED) {
                        continue;
                    }
                    else if (trait.handler.typeCheck === undefined) {
                        continue;
                    }
                    trait.handler.typeCheck(ctx, clazz, trait.analysis, trait.resolution);
                }
            }
        }
        index(ctx) {
            for (const clazz of this.classes.keys()) {
                const record = this.classes.get(clazz);
                for (const trait of record.traits) {
                    if (trait.state !== TraitState.RESOLVED) {
                        // Skip traits that haven't been resolved successfully.
                        continue;
                    }
                    else if (trait.handler.index === undefined) {
                        // Skip traits that don't affect indexing.
                        continue;
                    }
                    trait.handler.index(ctx, clazz, trait.analysis, trait.resolution);
                }
            }
        }
        compile(clazz, constantPool) {
            const original = ts.getOriginalNode(clazz);
            if (!this.reflector.isClass(clazz) || !this.reflector.isClass(original) ||
                !this.classes.has(original)) {
                return null;
            }
            const record = this.classes.get(original);
            let res = [];
            for (const trait of record.traits) {
                if (trait.state !== TraitState.RESOLVED) {
                    continue;
                }
                const compileSpan = this.perf.start('compileClass', original);
                const compileMatchRes = trait.handler.compile(clazz, trait.analysis, trait.resolution, constantPool);
                this.perf.stop(compileSpan);
                if (Array.isArray(compileMatchRes)) {
                    for (const result of compileMatchRes) {
                        if (!res.some(r => r.name === result.name)) {
                            res.push(result);
                        }
                    }
                }
                else if (!res.some(result => result.name === compileMatchRes.name)) {
                    res.push(compileMatchRes);
                }
            }
            // Look up the .d.ts transformer for the input file and record that at least one field was
            // generated, which will allow the .d.ts to be transformed later.
            this.dtsTransforms.getIvyDeclarationTransform(original.getSourceFile())
                .addFields(original, res);
            // Return the instruction to the transformer so the fields will be added.
            return res.length > 0 ? res : null;
        }
        decoratorsFor(node) {
            const original = ts.getOriginalNode(node);
            if (!this.reflector.isClass(original) || !this.classes.has(original)) {
                return [];
            }
            const record = this.classes.get(original);
            const decorators = [];
            for (const trait of record.traits) {
                if (trait.state !== TraitState.RESOLVED) {
                    continue;
                }
                if (trait.detected.trigger !== null && ts.isDecorator(trait.detected.trigger)) {
                    decorators.push(trait.detected.trigger);
                }
            }
            return decorators;
        }
        get diagnostics() {
            const diagnostics = [];
            for (const clazz of this.classes.keys()) {
                const record = this.classes.get(clazz);
                if (record.metaDiagnostics !== null) {
                    diagnostics.push(...record.metaDiagnostics);
                }
                for (const trait of record.traits) {
                    if (trait.state === TraitState.ERRORED) {
                        diagnostics.push(...trait.diagnostics);
                    }
                }
            }
            return diagnostics;
        }
        get exportStatements() {
            return this.reexportMap;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class Context {
        constructor(isStatement) {
            this.isStatement = isStatement;
        }
        get withExpressionMode() {
            return this.isStatement ? new Context(false) : this;
        }
        get withStatementMode() {
            return !this.isStatement ? new Context(true) : this;
        }
    }
    const BINARY_OPERATORS$1 = new Map([
        [BinaryOperator.And, ts.SyntaxKind.AmpersandAmpersandToken],
        [BinaryOperator.Bigger, ts.SyntaxKind.GreaterThanToken],
        [BinaryOperator.BiggerEquals, ts.SyntaxKind.GreaterThanEqualsToken],
        [BinaryOperator.BitwiseAnd, ts.SyntaxKind.AmpersandToken],
        [BinaryOperator.Divide, ts.SyntaxKind.SlashToken],
        [BinaryOperator.Equals, ts.SyntaxKind.EqualsEqualsToken],
        [BinaryOperator.Identical, ts.SyntaxKind.EqualsEqualsEqualsToken],
        [BinaryOperator.Lower, ts.SyntaxKind.LessThanToken],
        [BinaryOperator.LowerEquals, ts.SyntaxKind.LessThanEqualsToken],
        [BinaryOperator.Minus, ts.SyntaxKind.MinusToken],
        [BinaryOperator.Modulo, ts.SyntaxKind.PercentToken],
        [BinaryOperator.Multiply, ts.SyntaxKind.AsteriskToken],
        [BinaryOperator.NotEquals, ts.SyntaxKind.ExclamationEqualsToken],
        [BinaryOperator.NotIdentical, ts.SyntaxKind.ExclamationEqualsEqualsToken],
        [BinaryOperator.Or, ts.SyntaxKind.BarBarToken],
        [BinaryOperator.Plus, ts.SyntaxKind.PlusToken],
    ]);
    class ImportManager {
        constructor(rewriter = new NoopImportRewriter(), prefix = 'i') {
            this.rewriter = rewriter;
            this.prefix = prefix;
            this.specifierToIdentifier = new Map();
            this.nextIndex = 0;
        }
        generateNamedImport(moduleName, originalSymbol) {
            // First, rewrite the symbol name.
            const symbol = this.rewriter.rewriteSymbol(originalSymbol, moduleName);
            // Ask the rewriter if this symbol should be imported at all. If not, it can be referenced
            // directly (moduleImport: null).
            if (!this.rewriter.shouldImportSymbol(symbol, moduleName)) {
                // The symbol should be referenced directly.
                return { moduleImport: null, symbol };
            }
            // If not, this symbol will be imported. Allocate a prefix for the imported module if needed.
            if (!this.specifierToIdentifier.has(moduleName)) {
                this.specifierToIdentifier.set(moduleName, `${this.prefix}${this.nextIndex++}`);
            }
            const moduleImport = this.specifierToIdentifier.get(moduleName);
            return { moduleImport, symbol };
        }
        getAllImports(contextPath) {
            const imports = [];
            this.specifierToIdentifier.forEach((qualifier, specifier) => {
                specifier = this.rewriter.rewriteSpecifier(specifier, contextPath);
                imports.push({ specifier, qualifier });
            });
            return imports;
        }
    }
    function translateExpression(expression, imports, defaultImportRecorder, scriptTarget) {
        return expression.visitExpression(new ExpressionTranslatorVisitor(imports, defaultImportRecorder, scriptTarget), new Context(false));
    }
    function translateStatement(statement, imports, defaultImportRecorder, scriptTarget) {
        return statement.visitStatement(new ExpressionTranslatorVisitor(imports, defaultImportRecorder, scriptTarget), new Context(true));
    }
    function translateType(type, imports) {
        return type.visitType(new TypeTranslatorVisitor(imports), new Context(false));
    }
    class ExpressionTranslatorVisitor {
        constructor(imports, defaultImportRecorder, scriptTarget) {
            this.imports = imports;
            this.defaultImportRecorder = defaultImportRecorder;
            this.scriptTarget = scriptTarget;
            this.externalSourceFiles = new Map();
        }
        visitDeclareVarStmt(stmt, context) {
            const nodeFlags = ((this.scriptTarget >= ts.ScriptTarget.ES2015) && stmt.hasModifier(StmtModifier.Final)) ?
                ts.NodeFlags.Const :
                ts.NodeFlags.None;
            return ts.createVariableStatement(undefined, ts.createVariableDeclarationList([ts.createVariableDeclaration(stmt.name, undefined, stmt.value && stmt.value.visitExpression(this, context.withExpressionMode))], nodeFlags));
        }
        visitDeclareFunctionStmt(stmt, context) {
            return ts.createFunctionDeclaration(undefined, undefined, undefined, stmt.name, undefined, stmt.params.map(param => ts.createParameter(undefined, undefined, undefined, param.name)), undefined, ts.createBlock(stmt.statements.map(child => child.visitStatement(this, context.withStatementMode))));
        }
        visitExpressionStmt(stmt, context) {
            return ts.createStatement(stmt.expr.visitExpression(this, context.withStatementMode));
        }
        visitReturnStmt(stmt, context) {
            return ts.createReturn(stmt.value.visitExpression(this, context.withExpressionMode));
        }
        visitDeclareClassStmt(stmt, context) {
            if (this.scriptTarget < ts.ScriptTarget.ES2015) {
                throw new Error(`Unsupported mode: Visiting a "declare class" statement (class ${stmt.name}) while ` +
                    `targeting ${ts.ScriptTarget[this.scriptTarget]}.`);
            }
            throw new Error('Method not implemented.');
        }
        visitIfStmt(stmt, context) {
            return ts.createIf(stmt.condition.visitExpression(this, context), ts.createBlock(stmt.trueCase.map(child => child.visitStatement(this, context.withStatementMode))), stmt.falseCase.length > 0 ?
                ts.createBlock(stmt.falseCase.map(child => child.visitStatement(this, context.withStatementMode))) :
                undefined);
        }
        visitTryCatchStmt(stmt, context) {
            throw new Error('Method not implemented.');
        }
        visitThrowStmt(stmt, context) {
            return ts.createThrow(stmt.error.visitExpression(this, context.withExpressionMode));
        }
        visitCommentStmt(stmt, context) {
            const commentStmt = ts.createNotEmittedStatement(ts.createLiteral(''));
            ts.addSyntheticLeadingComment(commentStmt, stmt.multiline ? ts.SyntaxKind.MultiLineCommentTrivia :
                ts.SyntaxKind.SingleLineCommentTrivia, stmt.comment, /** hasTrailingNewLine */ false);
            return commentStmt;
        }
        visitJSDocCommentStmt(stmt, context) {
            const commentStmt = ts.createNotEmittedStatement(ts.createLiteral(''));
            const text = stmt.toString();
            const kind = ts.SyntaxKind.MultiLineCommentTrivia;
            ts.setSyntheticLeadingComments(commentStmt, [{ kind, text, pos: -1, end: -1 }]);
            return commentStmt;
        }
        visitReadVarExpr(ast, context) {
            const identifier = ts.createIdentifier(ast.name);
            this.setSourceMapRange(identifier, ast);
            return identifier;
        }
        visitWriteVarExpr(expr, context) {
            const result = ts.createBinary(ts.createIdentifier(expr.name), ts.SyntaxKind.EqualsToken, expr.value.visitExpression(this, context));
            return context.isStatement ? result : ts.createParen(result);
        }
        visitWriteKeyExpr(expr, context) {
            const exprContext = context.withExpressionMode;
            const lhs = ts.createElementAccess(expr.receiver.visitExpression(this, exprContext), expr.index.visitExpression(this, exprContext));
            const rhs = expr.value.visitExpression(this, exprContext);
            const result = ts.createBinary(lhs, ts.SyntaxKind.EqualsToken, rhs);
            return context.isStatement ? result : ts.createParen(result);
        }
        visitWritePropExpr(expr, context) {
            return ts.createBinary(ts.createPropertyAccess(expr.receiver.visitExpression(this, context), expr.name), ts.SyntaxKind.EqualsToken, expr.value.visitExpression(this, context));
        }
        visitInvokeMethodExpr(ast, context) {
            const target = ast.receiver.visitExpression(this, context);
            const call = ts.createCall(ast.name !== null ? ts.createPropertyAccess(target, ast.name) : target, undefined, ast.args.map(arg => arg.visitExpression(this, context)));
            this.setSourceMapRange(call, ast);
            return call;
        }
        visitInvokeFunctionExpr(ast, context) {
            const expr = ts.createCall(ast.fn.visitExpression(this, context), undefined, ast.args.map(arg => arg.visitExpression(this, context)));
            if (ast.pure) {
                ts.addSyntheticLeadingComment(expr, ts.SyntaxKind.MultiLineCommentTrivia, '@__PURE__', false);
            }
            this.setSourceMapRange(expr, ast);
            return expr;
        }
        visitInstantiateExpr(ast, context) {
            return ts.createNew(ast.classExpr.visitExpression(this, context), undefined, ast.args.map(arg => arg.visitExpression(this, context)));
        }
        visitLiteralExpr(ast, context) {
            let expr;
            if (ast.value === undefined) {
                expr = ts.createIdentifier('undefined');
            }
            else if (ast.value === null) {
                expr = ts.createNull();
            }
            else {
                expr = ts.createLiteral(ast.value);
            }
            this.setSourceMapRange(expr, ast);
            return expr;
        }
        visitLocalizedString(ast, context) {
            return this.scriptTarget >= ts.ScriptTarget.ES2015 ?
                createLocalizedStringTaggedTemplate(ast, context, this) :
                createLocalizedStringFunctionCall(ast, context, this, this.imports);
        }
        visitExternalExpr(ast, context) {
            if (ast.value.name === null) {
                throw new Error(`Import unknown module or symbol ${ast.value}`);
            }
            // If a moduleName is specified, this is a normal import. If there's no module name, it's a
            // reference to a global/ambient symbol.
            if (ast.value.moduleName !== null) {
                // This is a normal import. Find the imported module.
                const { moduleImport, symbol } = this.imports.generateNamedImport(ast.value.moduleName, ast.value.name);
                if (moduleImport === null) {
                    // The symbol was ambient after all.
                    return ts.createIdentifier(symbol);
                }
                else {
                    return ts.createPropertyAccess(ts.createIdentifier(moduleImport), ts.createIdentifier(symbol));
                }
            }
            else {
                // The symbol is ambient, so just reference it.
                return ts.createIdentifier(ast.value.name);
            }
        }
        visitConditionalExpr(ast, context) {
            let cond = ast.condition.visitExpression(this, context);
            // Ordinarily the ternary operator is right-associative. The following are equivalent:
            //   `a ? b : c ? d : e` => `a ? b : (c ? d : e)`
            //
            // However, occasionally Angular needs to produce a left-associative conditional, such as in
            // the case of a null-safe navigation production: `{{a?.b ? c : d}}`. This template produces
            // a ternary of the form:
            //   `a == null ? null : rest of expression`
            // If the rest of the expression is also a ternary though, this would produce the form:
            //   `a == null ? null : a.b ? c : d`
            // which, if left as right-associative, would be incorrectly associated as:
            //   `a == null ? null : (a.b ? c : d)`
            //
            // In such cases, the left-associativity needs to be enforced with parentheses:
            //   `(a == null ? null : a.b) ? c : d`
            //
            // Such parentheses could always be included in the condition (guaranteeing correct behavior) in
            // all cases, but this has a code size cost. Instead, parentheses are added only when a
            // conditional expression is directly used as the condition of another.
            //
            // TODO(alxhub): investigate better logic for precendence of conditional operators
            if (ast.condition instanceof ConditionalExpr) {
                // The condition of this ternary needs to be wrapped in parentheses to maintain
                // left-associativity.
                cond = ts.createParen(cond);
            }
            return ts.createConditional(cond, ast.trueCase.visitExpression(this, context), ast.falseCase.visitExpression(this, context));
        }
        visitNotExpr(ast, context) {
            return ts.createPrefix(ts.SyntaxKind.ExclamationToken, ast.condition.visitExpression(this, context));
        }
        visitAssertNotNullExpr(ast, context) {
            return ast.condition.visitExpression(this, context);
        }
        visitCastExpr(ast, context) {
            return ast.value.visitExpression(this, context);
        }
        visitFunctionExpr(ast, context) {
            return ts.createFunctionExpression(undefined, undefined, ast.name || undefined, undefined, ast.params.map(param => ts.createParameter(undefined, undefined, undefined, param.name, undefined, undefined, undefined)), undefined, ts.createBlock(ast.statements.map(stmt => stmt.visitStatement(this, context))));
        }
        visitBinaryOperatorExpr(ast, context) {
            if (!BINARY_OPERATORS$1.has(ast.operator)) {
                throw new Error(`Unknown binary operator: ${BinaryOperator[ast.operator]}`);
            }
            return ts.createBinary(ast.lhs.visitExpression(this, context), BINARY_OPERATORS$1.get(ast.operator), ast.rhs.visitExpression(this, context));
        }
        visitReadPropExpr(ast, context) {
            return ts.createPropertyAccess(ast.receiver.visitExpression(this, context), ast.name);
        }
        visitReadKeyExpr(ast, context) {
            return ts.createElementAccess(ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context));
        }
        visitLiteralArrayExpr(ast, context) {
            const expr = ts.createArrayLiteral(ast.entries.map(expr => expr.visitExpression(this, context)));
            this.setSourceMapRange(expr, ast);
            return expr;
        }
        visitLiteralMapExpr(ast, context) {
            const entries = ast.entries.map(entry => ts.createPropertyAssignment(entry.quoted ? ts.createLiteral(entry.key) : ts.createIdentifier(entry.key), entry.value.visitExpression(this, context)));
            const expr = ts.createObjectLiteral(entries);
            this.setSourceMapRange(expr, ast);
            return expr;
        }
        visitCommaExpr(ast, context) {
            throw new Error('Method not implemented.');
        }
        visitWrappedNodeExpr(ast, context) {
            if (ts.isIdentifier(ast.node)) {
                this.defaultImportRecorder.recordUsedIdentifier(ast.node);
            }
            return ast.node;
        }
        visitTypeofExpr(ast, context) {
            return ts.createTypeOf(ast.expr.visitExpression(this, context));
        }
        setSourceMapRange(expr, ast) {
            if (ast.sourceSpan) {
                const { start, end } = ast.sourceSpan;
                const { url, content } = start.file;
                if (url) {
                    if (!this.externalSourceFiles.has(url)) {
                        this.externalSourceFiles.set(url, ts.createSourceMapSource(url, content, pos => pos));
                    }
                    const source = this.externalSourceFiles.get(url);
                    ts.setSourceMapRange(expr, { pos: start.offset, end: end.offset, source });
                }
            }
        }
    }
    class TypeTranslatorVisitor {
        constructor(imports) {
            this.imports = imports;
        }
        visitBuiltinType(type, context) {
            switch (type.name) {
                case BuiltinTypeName.Bool:
                    return ts.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);
                case BuiltinTypeName.Dynamic:
                    return ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);
                case BuiltinTypeName.Int:
                case BuiltinTypeName.Number:
                    return ts.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);
                case BuiltinTypeName.String:
                    return ts.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);
                case BuiltinTypeName.None:
                    return ts.createKeywordTypeNode(ts.SyntaxKind.NeverKeyword);
                default:
                    throw new Error(`Unsupported builtin type: ${BuiltinTypeName[type.name]}`);
            }
        }
        visitExpressionType(type, context) {
            const typeNode = this.translateExpression(type.value, context);
            if (type.typeParams === null) {
                return typeNode;
            }
            if (!ts.isTypeReferenceNode(typeNode)) {
                throw new Error('An ExpressionType with type arguments must translate into a TypeReferenceNode');
            }
            else if (typeNode.typeArguments !== undefined) {
                throw new Error(`An ExpressionType with type arguments cannot have multiple levels of type arguments`);
            }
            const typeArgs = type.typeParams.map(param => this.translateType(param, context));
            return ts.createTypeReferenceNode(typeNode.typeName, typeArgs);
        }
        visitArrayType(type, context) {
            return ts.createArrayTypeNode(this.translateType(type.of, context));
        }
        visitMapType(type, context) {
            const parameter = ts.createParameter(undefined, undefined, undefined, 'key', undefined, ts.createKeywordTypeNode(ts.SyntaxKind.StringKeyword));
            const typeArgs = type.valueType !== null ?
                this.translateType(type.valueType, context) :
                ts.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);
            const indexSignature = ts.createIndexSignature(undefined, undefined, [parameter], typeArgs);
            return ts.createTypeLiteralNode([indexSignature]);
        }
        visitReadVarExpr(ast, context) {
            if (ast.name === null) {
                throw new Error(`ReadVarExpr with no variable name in type`);
            }
            return ts.createTypeQueryNode(ts.createIdentifier(ast.name));
        }
        visitWriteVarExpr(expr, context) {
            throw new Error('Method not implemented.');
        }
        visitWriteKeyExpr(expr, context) {
            throw new Error('Method not implemented.');
        }
        visitWritePropExpr(expr, context) {
            throw new Error('Method not implemented.');
        }
        visitInvokeMethodExpr(ast, context) {
            throw new Error('Method not implemented.');
        }
        visitInvokeFunctionExpr(ast, context) {
            throw new Error('Method not implemented.');
        }
        visitInstantiateExpr(ast, context) {
            throw new Error('Method not implemented.');
        }
        visitLiteralExpr(ast, context) {
            if (ast.value === null) {
                return ts.createKeywordTypeNode(ts.SyntaxKind.NullKeyword);
            }
            else if (ast.value === undefined) {
                return ts.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword);
            }
            else if (typeof ast.value === 'boolean') {
                return ts.createLiteralTypeNode(ts.createLiteral(ast.value));
            }
            else if (typeof ast.value === 'number') {
                return ts.createLiteralTypeNode(ts.createLiteral(ast.value));
            }
            else {
                return ts.createLiteralTypeNode(ts.createLiteral(ast.value));
            }
        }
        visitLocalizedString(ast, context) {
            throw new Error('Method not implemented.');
        }
        visitExternalExpr(ast, context) {
            if (ast.value.moduleName === null || ast.value.name === null) {
                throw new Error(`Import unknown module or symbol`);
            }
            const { moduleImport, symbol } = this.imports.generateNamedImport(ast.value.moduleName, ast.value.name);
            const symbolIdentifier = ts.createIdentifier(symbol);
            const typeName = moduleImport ?
                ts.createQualifiedName(ts.createIdentifier(moduleImport), symbolIdentifier) :
                symbolIdentifier;
            const typeArguments = ast.typeParams !== null ?
                ast.typeParams.map(type => this.translateType(type, context)) :
                undefined;
            return ts.createTypeReferenceNode(typeName, typeArguments);
        }
        visitConditionalExpr(ast, context) {
            throw new Error('Method not implemented.');
        }
        visitNotExpr(ast, context) {
            throw new Error('Method not implemented.');
        }
        visitAssertNotNullExpr(ast, context) {
            throw new Error('Method not implemented.');
        }
        visitCastExpr(ast, context) {
            throw new Error('Method not implemented.');
        }
        visitFunctionExpr(ast, context) {
            throw new Error('Method not implemented.');
        }
        visitBinaryOperatorExpr(ast, context) {
            throw new Error('Method not implemented.');
        }
        visitReadPropExpr(ast, context) {
            throw new Error('Method not implemented.');
        }
        visitReadKeyExpr(ast, context) {
            throw new Error('Method not implemented.');
        }
        visitLiteralArrayExpr(ast, context) {
            const values = ast.entries.map(expr => this.translateExpression(expr, context));
            return ts.createTupleTypeNode(values);
        }
        visitLiteralMapExpr(ast, context) {
            const entries = ast.entries.map(entry => {
                const { key, quoted } = entry;
                const type = this.translateExpression(entry.value, context);
                return ts.createPropertySignature(
                /* modifiers */ undefined, 
                /* name */ quoted ? ts.createStringLiteral(key) : key, 
                /* questionToken */ undefined, 
                /* type */ type, 
                /* initializer */ undefined);
            });
            return ts.createTypeLiteralNode(entries);
        }
        visitCommaExpr(ast, context) {
            throw new Error('Method not implemented.');
        }
        visitWrappedNodeExpr(ast, context) {
            const node = ast.node;
            if (ts.isEntityName(node)) {
                return ts.createTypeReferenceNode(node, /* typeArguments */ undefined);
            }
            else if (ts.isTypeNode(node)) {
                return node;
            }
            else if (ts.isLiteralExpression(node)) {
                return ts.createLiteralTypeNode(node);
            }
            else {
                throw new Error(`Unsupported WrappedNodeExpr in TypeTranslatorVisitor: ${ts.SyntaxKind[node.kind]}`);
            }
        }
        visitTypeofExpr(ast, context) {
            let expr = translateExpression(ast.expr, this.imports, NOOP_DEFAULT_IMPORT_RECORDER, ts.ScriptTarget.ES2015);
            return ts.createTypeQueryNode(expr);
        }
        translateType(type, context) {
            const typeNode = type.visitType(this, context);
            if (!ts.isTypeNode(typeNode)) {
                throw new Error(`A Type must translate to a TypeNode, but was ${ts.SyntaxKind[typeNode.kind]}`);
            }
            return typeNode;
        }
        translateExpression(expr, context) {
            const typeNode = expr.visitExpression(this, context);
            if (!ts.isTypeNode(typeNode)) {
                throw new Error(`An Expression must translate to a TypeNode, but was ${ts.SyntaxKind[typeNode.kind]}`);
            }
            return typeNode;
        }
    }
    /**
     * Translate the `LocalizedString` node into a `TaggedTemplateExpression` for ES2015 formatted
     * output.
     */
    function createLocalizedStringTaggedTemplate(ast, context, visitor) {
        let template;
        const length = ast.messageParts.length;
        const metaBlock = ast.serializeI18nHead();
        if (length === 1) {
            template = ts.createNoSubstitutionTemplateLiteral(metaBlock.cooked, metaBlock.raw);
        }
        else {
            // Create the head part
            const head = ts.createTemplateHead(metaBlock.cooked, metaBlock.raw);
            const spans = [];
            // Create the middle parts
            for (let i = 1; i < length - 1; i++) {
                const resolvedExpression = ast.expressions[i - 1].visitExpression(visitor, context);
                const templatePart = ast.serializeI18nTemplatePart(i);
                const templateMiddle = createTemplateMiddle(templatePart.cooked, templatePart.raw);
                spans.push(ts.createTemplateSpan(resolvedExpression, templateMiddle));
            }
            // Create the tail part
            const resolvedExpression = ast.expressions[length - 2].visitExpression(visitor, context);
            const templatePart = ast.serializeI18nTemplatePart(length - 1);
            const templateTail = createTemplateTail(templatePart.cooked, templatePart.raw);
            spans.push(ts.createTemplateSpan(resolvedExpression, templateTail));
            // Put it all together
            template = ts.createTemplateExpression(head, spans);
        }
        return ts.createTaggedTemplate(ts.createIdentifier('$localize'), template);
    }
    // HACK: Use this in place of `ts.createTemplateMiddle()`.
    // Revert once https://github.com/microsoft/TypeScript/issues/35374 is fixed
    function createTemplateMiddle(cooked, raw) {
        const node = ts.createTemplateHead(cooked, raw);
        node.kind = ts.SyntaxKind.TemplateMiddle;
        return node;
    }
    // HACK: Use this in place of `ts.createTemplateTail()`.
    // Revert once https://github.com/microsoft/TypeScript/issues/35374 is fixed
    function createTemplateTail(cooked, raw) {
        const node = ts.createTemplateHead(cooked, raw);
        node.kind = ts.SyntaxKind.TemplateTail;
        return node;
    }
    /**
     * Translate the `LocalizedString` node into a `$localize` call using the imported
     * `__makeTemplateObject` helper for ES5 formatted output.
     */
    function createLocalizedStringFunctionCall(ast, context, visitor, imports) {
        // A `$localize` message consists `messageParts` and `expressions`, which get interleaved
        // together. The interleaved pieces look like:
        // `[messagePart0, expression0, messagePart1, expression1, messagePart2]`
        //
        // Note that there is always a message part at the start and end, and so therefore
        // `messageParts.length === expressions.length + 1`.
        //
        // Each message part may be prefixed with "metadata", which is wrapped in colons (:) delimiters.
        // The metadata is attached to the first and subsequent message parts by calls to
        // `serializeI18nHead()` and `serializeI18nTemplatePart()` respectively.
        // The first message part (i.e. `ast.messageParts[0]`) is used to initialize `messageParts` array.
        const messageParts = [ast.serializeI18nHead()];
        const expressions = [];
        // The rest of the `ast.messageParts` and each of the expressions are `ast.expressions` pushed
        // into the arrays. Note that `ast.messagePart[i]` corresponds to `expressions[i-1]`
        for (let i = 1; i < ast.messageParts.length; i++) {
            expressions.push(ast.expressions[i - 1].visitExpression(visitor, context));
            messageParts.push(ast.serializeI18nTemplatePart(i));
        }
        // The resulting downlevelled tagged template string uses a call to the `__makeTemplateObject()`
        // helper, so we must ensure it has been imported.
        const { moduleImport, symbol } = imports.generateNamedImport('tslib', '__makeTemplateObject');
        const __makeTemplateObjectHelper = (moduleImport === null) ?
            ts.createIdentifier(symbol) :
            ts.createPropertyAccess(ts.createIdentifier(moduleImport), ts.createIdentifier(symbol));
        // Generate the call in the form:
        // `$localize(__makeTemplateObject(cookedMessageParts, rawMessageParts), ...expressions);`
        return ts.createCall(
        /* expression */ ts.createIdentifier('$localize'), 
        /* typeArguments */ undefined, 
        /* argumentsArray */ [
            ts.createCall(
            /* expression */ __makeTemplateObjectHelper, 
            /* typeArguments */ undefined, 
            /* argumentsArray */
            [
                ts.createArrayLiteral(messageParts.map(messagePart => ts.createStringLiteral(messagePart.cooked))),
                ts.createArrayLiteral(messageParts.map(messagePart => ts.createStringLiteral(messagePart.raw))),
            ]),
            ...expressions,
        ]);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Adds extra imports in the import manage for this source file, after the existing imports
     * and before the module body.
     * Can optionally add extra statements (e.g. new constants) before the body as well.
     */
    function addImports(importManager, sf, extraStatements = []) {
        // Generate the import statements to prepend.
        const addedImports = importManager.getAllImports(sf.fileName).map(i => {
            const qualifier = ts.createIdentifier(i.qualifier);
            const importClause = ts.createImportClause(
            /* name */ undefined, 
            /* namedBindings */ ts.createNamespaceImport(qualifier));
            return ts.createImportDeclaration(
            /* decorators */ undefined, 
            /* modifiers */ undefined, 
            /* importClause */ importClause, 
            /* moduleSpecifier */ ts.createLiteral(i.specifier));
        });
        // Filter out the existing imports and the source file body. All new statements
        // will be inserted between them.
        const existingImports = sf.statements.filter(stmt => isImportStatement(stmt));
        const body = sf.statements.filter(stmt => !isImportStatement(stmt));
        // Prepend imports if needed.
        if (addedImports.length > 0) {
            // If we prepend imports, we also prepend NotEmittedStatement to use it as an anchor
            // for @fileoverview Closure annotation. If there is no @fileoverview annotations, this
            // statement would be a noop.
            const fileoverviewAnchorStmt = ts.createNotEmittedStatement(sf);
            sf.statements = ts.createNodeArray([fileoverviewAnchorStmt, ...existingImports, ...addedImports, ...extraStatements, ...body]);
        }
        return sf;
    }
    function isImportStatement(stmt) {
        return ts.isImportDeclaration(stmt) || ts.isImportEqualsDeclaration(stmt) ||
            ts.isNamespaceImport(stmt);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Keeps track of `DtsTransform`s per source file, so that it is known which source files need to
     * have their declaration file transformed.
     */
    class DtsTransformRegistry {
        constructor() {
            this.ivyDeclarationTransforms = new Map();
            this.returnTypeTransforms = new Map();
        }
        getIvyDeclarationTransform(sf) {
            if (!this.ivyDeclarationTransforms.has(sf)) {
                this.ivyDeclarationTransforms.set(sf, new IvyDeclarationDtsTransform());
            }
            return this.ivyDeclarationTransforms.get(sf);
        }
        getReturnTypeTransform(sf) {
            if (!this.returnTypeTransforms.has(sf)) {
                this.returnTypeTransforms.set(sf, new ReturnTypeTransform());
            }
            return this.returnTypeTransforms.get(sf);
        }
        /**
         * Gets the dts transforms to be applied for the given source file, or `null` if no transform is
         * necessary.
         */
        getAllTransforms(sf) {
            // No need to transform if it's not a declarations file, or if no changes have been requested
            // to the input file. Due to the way TypeScript afterDeclarations transformers work, the
            // `ts.SourceFile` path is the same as the original .ts. The only way we know it's actually a
            // declaration file is via the `isDeclarationFile` property.
            if (!sf.isDeclarationFile) {
                return null;
            }
            const originalSf = ts.getOriginalNode(sf);
            let transforms = null;
            if (this.ivyDeclarationTransforms.has(originalSf)) {
                transforms = [];
                transforms.push(this.ivyDeclarationTransforms.get(originalSf));
            }
            if (this.returnTypeTransforms.has(originalSf)) {
                transforms = transforms || [];
                transforms.push(this.returnTypeTransforms.get(originalSf));
            }
            return transforms;
        }
    }
    function declarationTransformFactory(transformRegistry, importRewriter, importPrefix) {
        return (context) => {
            const transformer = new DtsTransformer(context, importRewriter, importPrefix);
            return (fileOrBundle) => {
                if (ts.isBundle(fileOrBundle)) {
                    // Only attempt to transform source files.
                    return fileOrBundle;
                }
                const transforms = transformRegistry.getAllTransforms(fileOrBundle);
                if (transforms === null) {
                    return fileOrBundle;
                }
                return transformer.transform(fileOrBundle, transforms);
            };
        };
    }
    /**
     * Processes .d.ts file text and adds static field declarations, with types.
     */
    class DtsTransformer {
        constructor(ctx, importRewriter, importPrefix) {
            this.ctx = ctx;
            this.importRewriter = importRewriter;
            this.importPrefix = importPrefix;
        }
        /**
         * Transform the declaration file and add any declarations which were recorded.
         */
        transform(sf, transforms) {
            const imports = new ImportManager(this.importRewriter, this.importPrefix);
            const visitor = (node) => {
                if (ts.isClassDeclaration(node)) {
                    return this.transformClassDeclaration(node, transforms, imports);
                }
                else if (ts.isFunctionDeclaration(node)) {
                    return this.transformFunctionDeclaration(node, transforms, imports);
                }
                else {
                    // Otherwise return node as is.
                    return ts.visitEachChild(node, visitor, this.ctx);
                }
            };
            // Recursively scan through the AST and process all nodes as desired.
            sf = ts.visitNode(sf, visitor);
            // Add new imports for this file.
            return addImports(imports, sf);
        }
        transformClassDeclaration(clazz, transforms, imports) {
            let elements = clazz.members;
            let elementsChanged = false;
            for (const transform of transforms) {
                if (transform.transformClassElement !== undefined) {
                    for (let i = 0; i < elements.length; i++) {
                        const res = transform.transformClassElement(elements[i], imports);
                        if (res !== elements[i]) {
                            if (!elementsChanged) {
                                elements = [...elements];
                                elementsChanged = true;
                            }
                            elements[i] = res;
                        }
                    }
                }
            }
            let newClazz = clazz;
            for (const transform of transforms) {
                if (transform.transformClass !== undefined) {
                    // If no DtsTransform has changed the class yet, then the (possibly mutated) elements have
                    // not yet been incorporated. Otherwise, `newClazz.members` holds the latest class members.
                    const inputMembers = (clazz === newClazz ? elements : newClazz.members);
                    newClazz = transform.transformClass(newClazz, inputMembers, imports);
                }
            }
            // If some elements have been transformed but the class itself has not been transformed, create
            // an updated class declaration with the updated elements.
            if (elementsChanged && clazz === newClazz) {
                newClazz = ts.updateClassDeclaration(
                /* node */ clazz, 
                /* decorators */ clazz.decorators, 
                /* modifiers */ clazz.modifiers, 
                /* name */ clazz.name, 
                /* typeParameters */ clazz.typeParameters, 
                /* heritageClauses */ clazz.heritageClauses, 
                /* members */ elements);
            }
            return newClazz;
        }
        transformFunctionDeclaration(declaration, transforms, imports) {
            let newDecl = declaration;
            for (const transform of transforms) {
                if (transform.transformFunctionDeclaration !== undefined) {
                    newDecl = transform.transformFunctionDeclaration(newDecl, imports);
                }
            }
            return newDecl;
        }
    }
    class IvyDeclarationDtsTransform {
        constructor() {
            this.declarationFields = new Map();
        }
        addFields(decl, fields) {
            this.declarationFields.set(decl, fields);
        }
        transformClass(clazz, members, imports) {
            const original = ts.getOriginalNode(clazz);
            if (!this.declarationFields.has(original)) {
                return clazz;
            }
            const fields = this.declarationFields.get(original);
            const newMembers = fields.map(decl => {
                const modifiers = [ts.createModifier(ts.SyntaxKind.StaticKeyword)];
                const typeRef = translateType(decl.type, imports);
                markForEmitAsSingleLine(typeRef);
                return ts.createProperty(
                /* decorators */ undefined, 
                /* modifiers */ modifiers, 
                /* name */ decl.name, 
                /* questionOrExclamationToken */ undefined, 
                /* type */ typeRef, 
                /* initializer */ undefined);
            });
            return ts.updateClassDeclaration(
            /* node */ clazz, 
            /* decorators */ clazz.decorators, 
            /* modifiers */ clazz.modifiers, 
            /* name */ clazz.name, 
            /* typeParameters */ clazz.typeParameters, 
            /* heritageClauses */ clazz.heritageClauses, 
            /* members */ [...members, ...newMembers]);
        }
    }
    function markForEmitAsSingleLine(node) {
        ts.setEmitFlags(node, ts.EmitFlags.SingleLine);
        ts.forEachChild(node, markForEmitAsSingleLine);
    }
    class ReturnTypeTransform {
        constructor() {
            this.typeReplacements = new Map();
        }
        addTypeReplacement(declaration, type) {
            this.typeReplacements.set(declaration, type);
        }
        transformClassElement(element, imports) {
            if (!ts.isMethodSignature(element)) {
                return element;
            }
            const original = ts.getOriginalNode(element);
            if (!this.typeReplacements.has(original)) {
                return element;
            }
            const returnType = this.typeReplacements.get(original);
            const tsReturnType = translateType(returnType, imports);
            const methodSignature = ts.updateMethodSignature(
            /* node */ element, 
            /* typeParameters */ element.typeParameters, 
            /* parameters */ element.parameters, 
            /* type */ tsReturnType, 
            /* name */ element.name, 
            /* questionToken */ element.questionToken);
            // Copy over any modifiers, these cannot be set during the `ts.updateMethodSignature` call.
            methodSignature.modifiers = element.modifiers;
            // A bug in the TypeScript declaration causes `ts.MethodSignature` not to be assignable to
            // `ts.ClassElement`. Since `element` was a `ts.MethodSignature` already, transforming it into
            // this type is actually correct.
            return methodSignature;
        }
        transformFunctionDeclaration(element, imports) {
            const original = ts.getOriginalNode(element);
            if (!this.typeReplacements.has(original)) {
                return element;
            }
            const returnType = this.typeReplacements.get(original);
            const tsReturnType = translateType(returnType, imports);
            return ts.updateFunctionDeclaration(
            /* node */ element, 
            /* decorators */ element.decorators, 
            /* modifiers */ element.modifiers, 
            /* asteriskToken */ element.asteriskToken, 
            /* name */ element.name, 
            /* typeParameters */ element.typeParameters, 
            /* parameters */ element.parameters, 
            /* type */ tsReturnType, 
            /* body */ element.body);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Visit a node with the given visitor and return a transformed copy.
     */
    function visit(node, visitor, context) {
        return visitor._visit(node, context);
    }
    /**
     * Abstract base class for visitors, which processes certain nodes specially to allow insertion
     * of other nodes before them.
     */
    class Visitor {
        constructor() {
            /**
             * Maps statements to an array of statements that should be inserted before them.
             */
            this._before = new Map();
            /**
             * Maps statements to an array of statements that should be inserted after them.
             */
            this._after = new Map();
        }
        /**
         * Visit a class declaration, returning at least the transformed declaration and optionally other
         * nodes to insert before the declaration.
         */
        visitClassDeclaration(node) {
            return { node };
        }
        _visitListEntryNode(node, visitor) {
            const result = visitor(node);
            if (result.before !== undefined) {
                // Record that some nodes should be inserted before the given declaration. The declaration's
                // parent's _visit call is responsible for performing this insertion.
                this._before.set(result.node, result.before);
            }
            if (result.after !== undefined) {
                // Same with nodes that should be inserted after.
                this._after.set(result.node, result.after);
            }
            return result.node;
        }
        /**
         * Visit types of nodes which don't have their own explicit visitor.
         */
        visitOtherNode(node) {
            return node;
        }
        /**
         * @internal
         */
        _visit(node, context) {
            // First, visit the node. visitedNode starts off as `null` but should be set after visiting
            // is completed.
            let visitedNode = null;
            node = ts.visitEachChild(node, child => this._visit(child, context), context);
            if (ts.isClassDeclaration(node)) {
                visitedNode =
                    this._visitListEntryNode(node, (node) => this.visitClassDeclaration(node));
            }
            else {
                visitedNode = this.visitOtherNode(node);
            }
            // If the visited node has a `statements` array then process them, maybe replacing the visited
            // node and adding additional statements.
            if (hasStatements(visitedNode)) {
                visitedNode = this._maybeProcessStatements(visitedNode);
            }
            return visitedNode;
        }
        _maybeProcessStatements(node) {
            // Shortcut - if every statement doesn't require nodes to be prepended or appended,
            // this is a no-op.
            if (node.statements.every(stmt => !this._before.has(stmt) && !this._after.has(stmt))) {
                return node;
            }
            // There are statements to prepend, so clone the original node.
            const clone = ts.getMutableClone(node);
            // Build a new list of statements and patch it onto the clone.
            const newStatements = [];
            clone.statements.forEach(stmt => {
                if (this._before.has(stmt)) {
                    newStatements.push(...this._before.get(stmt));
                    this._before.delete(stmt);
                }
                newStatements.push(stmt);
                if (this._after.has(stmt)) {
                    newStatements.push(...this._after.get(stmt));
                    this._after.delete(stmt);
                }
            });
            clone.statements = ts.createNodeArray(newStatements, node.statements.hasTrailingComma);
            return clone;
        }
    }
    function hasStatements(node) {
        const block = node;
        return block.statements !== undefined && Array.isArray(block.statements);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const NO_DECORATORS = new Set();
    const CLOSURE_FILE_OVERVIEW_REGEXP = /\s+@fileoverview\s+/i;
    function ivyTransformFactory(compilation, reflector, importRewriter, defaultImportRecorder, isCore, isClosureCompilerEnabled) {
        return (context) => {
            return (file) => {
                return transformIvySourceFile(compilation, context, reflector, importRewriter, file, isCore, isClosureCompilerEnabled, defaultImportRecorder);
            };
        };
    }
    /**
     * Visits all classes, performs Ivy compilation where Angular decorators are present and collects
     * result in a Map that associates a ts.ClassDeclaration with Ivy compilation results. This visitor
     * does NOT perform any TS transformations.
     */
    class IvyCompilationVisitor extends Visitor {
        constructor(compilation, constantPool) {
            super();
            this.compilation = compilation;
            this.constantPool = constantPool;
            this.classCompilationMap = new Map();
        }
        visitClassDeclaration(node) {
            // Determine if this class has an Ivy field that needs to be added, and compile the field
            // to an expression if so.
            const result = this.compilation.compile(node, this.constantPool);
            if (result !== null) {
                this.classCompilationMap.set(node, result);
            }
            return { node };
        }
    }
    /**
     * Visits all classes and performs transformation of corresponding TS nodes based on the Ivy
     * compilation results (provided as an argument).
     */
    class IvyTransformationVisitor extends Visitor {
        constructor(compilation, classCompilationMap, reflector, importManager, defaultImportRecorder, isClosureCompilerEnabled, isCore) {
            super();
            this.compilation = compilation;
            this.classCompilationMap = classCompilationMap;
            this.reflector = reflector;
            this.importManager = importManager;
            this.defaultImportRecorder = defaultImportRecorder;
            this.isClosureCompilerEnabled = isClosureCompilerEnabled;
            this.isCore = isCore;
        }
        visitClassDeclaration(node) {
            // If this class is not registered in the map, it means that it doesn't have Angular decorators,
            // thus no further processing is required.
            if (!this.classCompilationMap.has(node)) {
                return { node };
            }
            // There is at least one field to add.
            const statements = [];
            const members = [...node.members];
            for (const field of this.classCompilationMap.get(node)) {
                // Translate the initializer for the field into TS nodes.
                const exprNode = translateExpression(field.initializer, this.importManager, this.defaultImportRecorder, ts.ScriptTarget.ES2015);
                // Create a static property declaration for the new field.
                const property = ts.createProperty(undefined, [ts.createToken(ts.SyntaxKind.StaticKeyword)], field.name, undefined, undefined, exprNode);
                if (this.isClosureCompilerEnabled) {
                    // Closure compiler transforms the form `Service.prov = X` into `Service$prov = X`. To
                    // prevent this transformation, such assignments need to be annotated with @nocollapse.
                    // Note that tsickle is typically responsible for adding such annotations, however it
                    // doesn't yet handle synthetic fields added during other transformations.
                    ts.addSyntheticLeadingComment(property, ts.SyntaxKind.MultiLineCommentTrivia, '* @nocollapse ', 
                    /* hasTrailingNewLine */ false);
                }
                field.statements
                    .map(stmt => translateStatement(stmt, this.importManager, this.defaultImportRecorder, ts.ScriptTarget.ES2015))
                    .forEach(stmt => statements.push(stmt));
                members.push(property);
            }
            // Replace the class declaration with an updated version.
            node = ts.updateClassDeclaration(node, 
            // Remove the decorator which triggered this compilation, leaving the others alone.
            maybeFilterDecorator(node.decorators, this.compilation.decoratorsFor(node)), node.modifiers, node.name, node.typeParameters, node.heritageClauses || [], 
            // Map over the class members and remove any Angular decorators from them.
            members.map(member => this._stripAngularDecorators(member)));
            return { node, after: statements };
        }
        /**
         * Return all decorators on a `Declaration` which are from @angular/core, or an empty set if none
         * are.
         */
        _angularCoreDecorators(decl) {
            const decorators = this.reflector.getDecoratorsOfDeclaration(decl);
            if (decorators === null) {
                return NO_DECORATORS;
            }
            const coreDecorators = decorators.filter(dec => this.isCore || isFromAngularCore(dec))
                .map(dec => dec.node);
            if (coreDecorators.length > 0) {
                return new Set(coreDecorators);
            }
            else {
                return NO_DECORATORS;
            }
        }
        /**
         * Given a `ts.Node`, filter the decorators array and return a version containing only non-Angular
         * decorators.
         *
         * If all decorators are removed (or none existed in the first place), this method returns
         * `undefined`.
         */
        _nonCoreDecoratorsOnly(node) {
            // Shortcut if the node has no decorators.
            if (node.decorators === undefined) {
                return undefined;
            }
            // Build a Set of the decorators on this node from @angular/core.
            const coreDecorators = this._angularCoreDecorators(node);
            if (coreDecorators.size === node.decorators.length) {
                // If all decorators are to be removed, return `undefined`.
                return undefined;
            }
            else if (coreDecorators.size === 0) {
                // If no decorators need to be removed, return the original decorators array.
                return node.decorators;
            }
            // Filter out the core decorators.
            const filtered = node.decorators.filter(dec => !coreDecorators.has(dec));
            // If no decorators survive, return `undefined`. This can only happen if a core decorator is
            // repeated on the node.
            if (filtered.length === 0) {
                return undefined;
            }
            // Create a new `NodeArray` with the filtered decorators that sourcemaps back to the original.
            const array = ts.createNodeArray(filtered);
            array.pos = node.decorators.pos;
            array.end = node.decorators.end;
            return array;
        }
        /**
         * Remove Angular decorators from a `ts.Node` in a shallow manner.
         *
         * This will remove decorators from class elements (getters, setters, properties, methods) as well
         * as parameters of constructors.
         */
        _stripAngularDecorators(node) {
            if (ts.isParameter(node)) {
                // Strip decorators from parameters (probably of the constructor).
                node = ts.updateParameter(node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.dotDotDotToken, node.name, node.questionToken, node.type, node.initializer);
            }
            else if (ts.isMethodDeclaration(node) && node.decorators !== undefined) {
                // Strip decorators of methods.
                node = ts.updateMethod(node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.asteriskToken, node.name, node.questionToken, node.typeParameters, node.parameters, node.type, node.body);
            }
            else if (ts.isPropertyDeclaration(node) && node.decorators !== undefined) {
                // Strip decorators of properties.
                node = ts.updateProperty(node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.name, node.questionToken, node.type, node.initializer);
            }
            else if (ts.isGetAccessor(node)) {
                // Strip decorators of getters.
                node = ts.updateGetAccessor(node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.name, node.parameters, node.type, node.body);
            }
            else if (ts.isSetAccessor(node)) {
                // Strip decorators of setters.
                node = ts.updateSetAccessor(node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.name, node.parameters, node.body);
            }
            else if (ts.isConstructorDeclaration(node)) {
                // For constructors, strip decorators of the parameters.
                const parameters = node.parameters.map(param => this._stripAngularDecorators(param));
                node =
                    ts.updateConstructor(node, node.decorators, node.modifiers, parameters, node.body);
            }
            return node;
        }
    }
    /**
     * A transformer which operates on ts.SourceFiles and applies changes from an `IvyCompilation`.
     */
    function transformIvySourceFile(compilation, context, reflector, importRewriter, file, isCore, isClosureCompilerEnabled, defaultImportRecorder) {
        const constantPool = new ConstantPool(isClosureCompilerEnabled);
        const importManager = new ImportManager(importRewriter);
        // The transformation process consists of 2 steps:
        //
        //  1. Visit all classes, perform compilation and collect the results.
        //  2. Perform actual transformation of required TS nodes using compilation results from the first
        //     step.
        //
        // This is needed to have all `o.Expression`s generated before any TS transforms happen. This
        // allows `ConstantPool` to properly identify expressions that can be shared across multiple
        // components declared in the same file.
        // Step 1. Go though all classes in AST, perform compilation and collect the results.
        const compilationVisitor = new IvyCompilationVisitor(compilation, constantPool);
        visit(file, compilationVisitor, context);
        // Step 2. Scan through the AST again and perform transformations based on Ivy compilation
        // results obtained at Step 1.
        const transformationVisitor = new IvyTransformationVisitor(compilation, compilationVisitor.classCompilationMap, reflector, importManager, defaultImportRecorder, isClosureCompilerEnabled, isCore);
        let sf = visit(file, transformationVisitor, context);
        // Generate the constant statements first, as they may involve adding additional imports
        // to the ImportManager.
        const constants = constantPool.statements.map(stmt => translateStatement(stmt, importManager, defaultImportRecorder, getLocalizeCompileTarget(context)));
        // Preserve @fileoverview comments required by Closure, since the location might change as a
        // result of adding extra imports and constant pool statements.
        const fileOverviewMeta = isClosureCompilerEnabled ? getFileOverviewComment(sf.statements) : null;
        // Add new imports for this file.
        sf = addImports(importManager, sf, constants);
        if (fileOverviewMeta !== null) {
            setFileOverviewComment(sf, fileOverviewMeta);
        }
        return sf;
    }
    /**
     * Compute the correct target output for `$localize` messages generated by Angular
     *
     * In some versions of TypeScript, the transformation of synthetic `$localize` tagged template
     * literals is broken. See https://github.com/microsoft/TypeScript/issues/38485
     *
     * Here we compute what the expected final output target of the compilation will
     * be so that we can generate ES5 compliant `$localize` calls instead of relying upon TS to do the
     * downleveling for us.
     */
    function getLocalizeCompileTarget(context) {
        const target = context.getCompilerOptions().target || ts.ScriptTarget.ES2015;
        return target !== ts.ScriptTarget.JSON ? target : ts.ScriptTarget.ES2015;
    }
    function getFileOverviewComment(statements) {
        if (statements.length > 0) {
            const host = statements[0];
            let trailing = false;
            let comments = ts.getSyntheticLeadingComments(host);
            // If @fileoverview tag is not found in source file, tsickle produces fake node with trailing
            // comment and inject it at the very beginning of the generated file. So we need to check for
            // leading as well as trailing comments.
            if (!comments || comments.length === 0) {
                trailing = true;
                comments = ts.getSyntheticTrailingComments(host);
            }
            if (comments && comments.length > 0 && CLOSURE_FILE_OVERVIEW_REGEXP.test(comments[0].text)) {
                return { comments, host, trailing };
            }
        }
        return null;
    }
    function setFileOverviewComment(sf, fileoverview) {
        const { comments, host, trailing } = fileoverview;
        // If host statement is no longer the first one, it means that extra statements were added at the
        // very beginning, so we need to relocate @fileoverview comment and cleanup the original statement
        // that hosted it.
        if (sf.statements.length > 0 && host !== sf.statements[0]) {
            if (trailing) {
                ts.setSyntheticTrailingComments(host, undefined);
            }
            else {
                ts.setSyntheticLeadingComments(host, undefined);
            }
            ts.setSyntheticLeadingComments(sf.statements[0], comments);
        }
    }
    function maybeFilterDecorator(decorators, toRemove) {
        if (decorators === undefined) {
            return undefined;
        }
        const filtered = decorators.filter(dec => toRemove.find(decToRemove => ts.getOriginalNode(dec) === decToRemove) === undefined);
        if (filtered.length === 0) {
            return undefined;
        }
        return ts.createNodeArray(filtered);
    }
    function isFromAngularCore(decorator) {
        return decorator.import !== null && decorator.import.from === '@angular/core';
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    let _tsSourceMapBug29300Fixed;
    /**
     * Test the current version of TypeScript to see if it has fixed the external SourceMap
     * file bug: https://github.com/Microsoft/TypeScript/issues/29300.
     *
     * The bug is fixed in TS 3.3+ but this check avoid us having to rely upon the version number,
     * and allows us to gracefully fail if the TS version still has the bug.
     *
     * We check for the bug by compiling a very small program `a;` and transforming it to `b;`,
     * where we map the new `b` identifier to an external source file, which has different lines to
     * the original source file.  If the bug is fixed then the output SourceMap should contain
     * mappings that correspond ot the correct line/col pairs for this transformed node.
     *
     * @returns true if the bug is fixed.
     */
    function tsSourceMapBug29300Fixed() {
        if (_tsSourceMapBug29300Fixed === undefined) {
            let writtenFiles = {};
            const sourceFile = ts.createSourceFile('test.ts', 'a;', ts.ScriptTarget.ES2015, true, ts.ScriptKind.TS);
            const host = {
                getSourceFile() {
                    return sourceFile;
                },
                fileExists() {
                    return true;
                },
                readFile() {
                    return '';
                },
                writeFile(fileName, data) {
                    writtenFiles[fileName] = data;
                },
                getDefaultLibFileName() {
                    return '';
                },
                getCurrentDirectory() {
                    return '';
                },
                getDirectories() {
                    return [];
                },
                getCanonicalFileName() {
                    return '';
                },
                useCaseSensitiveFileNames() {
                    return true;
                },
                getNewLine() {
                    return '\n';
                },
            };
            const transform = (context) => {
                return (node) => ts.visitNode(node, visitor);
                function visitor(node) {
                    if (ts.isIdentifier(node) && node.text === 'a') {
                        const newNode = ts.createIdentifier('b');
                        ts.setSourceMapRange(newNode, {
                            pos: 16,
                            end: 16,
                            source: ts.createSourceMapSource('test.html', 'abc\ndef\nghi\njkl\nmno\npqr')
                        });
                        return newNode;
                    }
                    return ts.visitEachChild(node, visitor, context);
                }
            };
            const program = ts.createProgram(['test.ts'], { sourceMap: true }, host);
            program.emit(sourceFile, undefined, undefined, undefined, { after: [transform] });
            // The first two mappings in the source map should look like:
            // [0,1,4,0] col 0 => source file 1, row 4, column 0)
            // [1,0,0,0] col 1 => source file 1, row 4, column 0)
            _tsSourceMapBug29300Fixed = /ACIA,CAAA/.test(writtenFiles['test.js.map']);
        }
        return _tsSourceMapBug29300Fixed;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function getConstructorDependencies(clazz, reflector, defaultImportRecorder, isCore) {
        const deps = [];
        const errors = [];
        let ctorParams = reflector.getConstructorParameters(clazz);
        if (ctorParams === null) {
            if (reflector.hasBaseClass(clazz)) {
                return null;
            }
            else {
                ctorParams = [];
            }
        }
        ctorParams.forEach((param, idx) => {
            let token = valueReferenceToExpression(param.typeValueReference, defaultImportRecorder);
            let attribute = null;
            let optional = false, self = false, skipSelf = false, host = false;
            let resolved = R3ResolvedDependencyType.Token;
            (param.decorators || []).filter(dec => isCore || isAngularCore(dec)).forEach(dec => {
                const name = isCore || dec.import === null ? dec.name : dec.import.name;
                if (name === 'Inject') {
                    if (dec.args === null || dec.args.length !== 1) {
                        throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(dec), `Unexpected number of arguments to @Inject().`);
                    }
                    token = new WrappedNodeExpr(dec.args[0]);
                }
                else if (name === 'Optional') {
                    optional = true;
                }
                else if (name === 'SkipSelf') {
                    skipSelf = true;
                }
                else if (name === 'Self') {
                    self = true;
                }
                else if (name === 'Host') {
                    host = true;
                }
                else if (name === 'Attribute') {
                    if (dec.args === null || dec.args.length !== 1) {
                        throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(dec), `Unexpected number of arguments to @Attribute().`);
                    }
                    const attributeName = dec.args[0];
                    token = new WrappedNodeExpr(attributeName);
                    if (ts.isStringLiteralLike(attributeName)) {
                        attribute = new LiteralExpr(attributeName.text);
                    }
                    else {
                        attribute = new WrappedNodeExpr(ts.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword));
                    }
                    resolved = R3ResolvedDependencyType.Attribute;
                }
                else {
                    throw new FatalDiagnosticError(ErrorCode.DECORATOR_UNEXPECTED, Decorator.nodeForError(dec), `Unexpected decorator ${name} on parameter.`);
                }
            });
            if (token instanceof ExternalExpr && token.value.name === 'ChangeDetectorRef' &&
                token.value.moduleName === '@angular/core') {
                resolved = R3ResolvedDependencyType.ChangeDetectorRef;
            }
            if (token === null) {
                if (param.typeValueReference.kind !== 2 /* UNAVAILABLE */) {
                    throw new Error('Illegal state: expected value reference to be unavailable if no token is present');
                }
                errors.push({
                    index: idx,
                    param,
                    reason: param.typeValueReference.reason,
                });
            }
            else {
                deps.push({ token, attribute, optional, self, skipSelf, host, resolved });
            }
        });
        if (errors.length === 0) {
            return { deps };
        }
        else {
            return { deps: null, errors };
        }
    }
    function valueReferenceToExpression(valueRef, defaultImportRecorder) {
        if (valueRef.kind === 2 /* UNAVAILABLE */) {
            return null;
        }
        else if (valueRef.kind === 0 /* LOCAL */) {
            if (defaultImportRecorder !== null && valueRef.defaultImportStatement !== null &&
                ts.isIdentifier(valueRef.expression)) {
                defaultImportRecorder.recordImportedIdentifier(valueRef.expression, valueRef.defaultImportStatement);
            }
            return new WrappedNodeExpr(valueRef.expression);
        }
        else {
            let importExpr = new ExternalExpr({ moduleName: valueRef.moduleName, name: valueRef.importedName });
            if (valueRef.nestedPath !== null) {
                for (const property of valueRef.nestedPath) {
                    importExpr = new ReadPropExpr(importExpr, property);
                }
            }
            return importExpr;
        }
    }
    /**
     * Convert `ConstructorDeps` into the `R3DependencyMetadata` array for those deps if they're valid,
     * or into an `'invalid'` signal if they're not.
     *
     * This is a companion function to `validateConstructorDependencies` which accepts invalid deps.
     */
    function unwrapConstructorDependencies(deps) {
        if (deps === null) {
            return null;
        }
        else if (deps.deps !== null) {
            // These constructor dependencies are valid.
            return deps.deps;
        }
        else {
            // These deps are invalid.
            return 'invalid';
        }
    }
    function getValidConstructorDependencies(clazz, reflector, defaultImportRecorder, isCore) {
        return validateConstructorDependencies(clazz, getConstructorDependencies(clazz, reflector, defaultImportRecorder, isCore));
    }
    /**
     * Validate that `ConstructorDeps` does not have any invalid dependencies and convert them into the
     * `R3DependencyMetadata` array if so, or raise a diagnostic if some deps are invalid.
     *
     * This is a companion function to `unwrapConstructorDependencies` which does not accept invalid
     * deps.
     */
    function validateConstructorDependencies(clazz, deps) {
        if (deps === null) {
            return null;
        }
        else if (deps.deps !== null) {
            return deps.deps;
        }
        else {
            // TODO(alxhub): this cast is necessary because the g3 typescript version doesn't narrow here.
            // There is at least one error.
            const error = deps.errors[0];
            throw createUnsuitableInjectionTokenError(clazz, error);
        }
    }
    /**
     * Creates a fatal error with diagnostic for an invalid injection token.
     * @param clazz The class for which the injection token was unavailable.
     * @param error The reason why no valid injection token is available.
     */
    function createUnsuitableInjectionTokenError(clazz, error) {
        const { param, index, reason } = error;
        let chainMessage = undefined;
        let hints = undefined;
        switch (reason.kind) {
            case 5 /* UNSUPPORTED */:
                chainMessage = 'Consider using the @Inject decorator to specify an injection token.';
                hints = [
                    makeRelatedInformation(reason.typeNode, 'This type is not supported as injection token.'),
                ];
                break;
            case 1 /* NO_VALUE_DECLARATION */:
                chainMessage = 'Consider using the @Inject decorator to specify an injection token.';
                hints = [
                    makeRelatedInformation(reason.typeNode, 'This type does not have a value, so it cannot be used as injection token.'),
                    makeRelatedInformation(reason.decl, 'The type is declared here.'),
                ];
                break;
            case 2 /* TYPE_ONLY_IMPORT */:
                chainMessage =
                    'Consider changing the type-only import to a regular import, or use the @Inject decorator to specify an injection token.';
                hints = [
                    makeRelatedInformation(reason.typeNode, 'This type is imported using a type-only import, which prevents it from being usable as an injection token.'),
                    makeRelatedInformation(reason.importClause, 'The type-only import occurs here.'),
                ];
                break;
            case 4 /* NAMESPACE */:
                chainMessage = 'Consider using the @Inject decorator to specify an injection token.';
                hints = [
                    makeRelatedInformation(reason.typeNode, 'This type corresponds with a namespace, which cannot be used as injection token.'),
                    makeRelatedInformation(reason.importClause, 'The namespace import occurs here.'),
                ];
                break;
            case 3 /* UNKNOWN_REFERENCE */:
                chainMessage = 'The type should reference a known declaration.';
                hints = [makeRelatedInformation(reason.typeNode, 'This type could not be resolved.')];
                break;
            case 0 /* MISSING_TYPE */:
                chainMessage =
                    'Consider adding a type to the parameter or use the @Inject decorator to specify an injection token.';
                break;
        }
        const chain = {
            messageText: `No suitable injection token for parameter '${param.name || index}' of class '${clazz.name.text}'.`,
            category: ts.DiagnosticCategory.Error,
            code: 0,
            next: [{
                    messageText: chainMessage,
                    category: ts.DiagnosticCategory.Message,
                    code: 0,
                }],
        };
        return new FatalDiagnosticError(ErrorCode.PARAM_MISSING_TOKEN, param.nameNode, chain, hints);
    }
    function toR3Reference(valueRef, typeRef, valueContext, typeContext, refEmitter) {
        const value = refEmitter.emit(valueRef, valueContext);
        const type = refEmitter.emit(typeRef, typeContext, ImportFlags.ForceNewImport | ImportFlags.AllowTypeImports);
        if (value === null || type === null) {
            throw new Error(`Could not refer to ${ts.SyntaxKind[valueRef.node.kind]}`);
        }
        return { value, type };
    }
    function isAngularCore(decorator) {
        return decorator.import !== null && decorator.import.from === '@angular/core';
    }
    function isAngularCoreReference(reference, symbolName) {
        return reference.ownedByModuleGuess === '@angular/core' && reference.debugName === symbolName;
    }
    function findAngularDecorator(decorators, name, isCore) {
        return decorators.find(decorator => isAngularDecorator(decorator, name, isCore));
    }
    function isAngularDecorator(decorator, name, isCore) {
        if (isCore) {
            return decorator.name === name;
        }
        else if (isAngularCore(decorator)) {
            return decorator.import.name === name;
        }
        return false;
    }
    /**
     * Unwrap a `ts.Expression`, removing outer type-casts or parentheses until the expression is in its
     * lowest level form.
     *
     * For example, the expression "(foo as Type)" unwraps to "foo".
     */
    function unwrapExpression(node) {
        while (ts.isAsExpression(node) || ts.isParenthesizedExpression(node)) {
            node = node.expression;
        }
        return node;
    }
    function expandForwardRef(arg) {
        arg = unwrapExpression(arg);
        if (!ts.isArrowFunction(arg) && !ts.isFunctionExpression(arg)) {
            return null;
        }
        const body = arg.body;
        // Either the body is a ts.Expression directly, or a block with a single return statement.
        if (ts.isBlock(body)) {
            // Block body - look for a single return statement.
            if (body.statements.length !== 1) {
                return null;
            }
            const stmt = body.statements[0];
            if (!ts.isReturnStatement(stmt) || stmt.expression === undefined) {
                return null;
            }
            return stmt.expression;
        }
        else {
            // Shorthand body - return as an expression.
            return body;
        }
    }
    /**
     * Possibly resolve a forwardRef() expression into the inner value.
     *
     * @param node the forwardRef() expression to resolve
     * @param reflector a ReflectionHost
     * @returns the resolved expression, if the original expression was a forwardRef(), or the original
     * expression otherwise
     */
    function unwrapForwardRef(node, reflector) {
        node = unwrapExpression(node);
        if (!ts.isCallExpression(node) || node.arguments.length !== 1) {
            return node;
        }
        const fn = ts.isPropertyAccessExpression(node.expression) ? node.expression.name : node.expression;
        if (!ts.isIdentifier(fn)) {
            return node;
        }
        const expr = expandForwardRef(node.arguments[0]);
        if (expr === null) {
            return node;
        }
        const imp = reflector.getImportOfIdentifier(fn);
        if (imp === null || imp.from !== '@angular/core' || imp.name !== 'forwardRef') {
            return node;
        }
        else {
            return expr;
        }
    }
    /**
     * A foreign function resolver for `staticallyResolve` which unwraps forwardRef() expressions.
     *
     * @param ref a Reference to the declaration of the function being called (which might be
     * forwardRef)
     * @param args the arguments to the invocation of the forwardRef expression
     * @returns an unwrapped argument if `ref` pointed to forwardRef, or null otherwise
     */
    function forwardRefResolver(ref, args) {
        if (!isAngularCoreReference(ref, 'forwardRef') || args.length !== 1) {
            return null;
        }
        return expandForwardRef(args[0]);
    }
    /**
     * Combines an array of resolver functions into a one.
     * @param resolvers Resolvers to be combined.
     */
    function combineResolvers(resolvers) {
        return (ref, args) => {
            for (const resolver of resolvers) {
                const resolved = resolver(ref, args);
                if (resolved !== null) {
                    return resolved;
                }
            }
            return null;
        };
    }
    function isExpressionForwardReference(expr, context, contextSource) {
        if (isWrappedTsNodeExpr(expr)) {
            const node = ts.getOriginalNode(expr.node);
            return node.getSourceFile() === contextSource && context.pos < node.pos;
        }
        else {
            return false;
        }
    }
    function isWrappedTsNodeExpr(expr) {
        return expr instanceof WrappedNodeExpr;
    }
    function readBaseClass$1(node, reflector, evaluator) {
        const baseExpression = reflector.getBaseClassExpression(node);
        if (baseExpression !== null) {
            const baseClass = evaluator.evaluate(baseExpression);
            if (baseClass instanceof Reference$1 && reflector.isClass(baseClass.node)) {
                return baseClass;
            }
            else {
                return 'dynamic';
            }
        }
        return null;
    }
    const parensWrapperTransformerFactory = (context) => {
        const visitor = (node) => {
            const visited = ts.visitEachChild(node, visitor, context);
            if (ts.isArrowFunction(visited) || ts.isFunctionExpression(visited)) {
                return ts.createParen(visited);
            }
            return visited;
        };
        return (node) => ts.visitEachChild(node, visitor, context);
    };
    /**
     * Wraps all functions in a given expression in parentheses. This is needed to avoid problems
     * where Tsickle annotations added between analyse and transform phases in Angular may trigger
     * automatic semicolon insertion, e.g. if a function is the expression in a `return` statement.
     * More
     * info can be found in Tsickle source code here:
     * https://github.com/angular/tsickle/blob/d7974262571c8a17d684e5ba07680e1b1993afdd/src/jsdoc_transformer.ts#L1021
     *
     * @param expression Expression where functions should be wrapped in parentheses
     */
    function wrapFunctionExpressionsInParens(expression) {
        return ts.transform(expression, [parensWrapperTransformerFactory]).transformed[0];
    }
    /**
     * Create a `ts.Diagnostic` which indicates the given class is part of the declarations of two or
     * more NgModules.
     *
     * The resulting `ts.Diagnostic` will have a context entry for each NgModule showing the point where
     * the directive/pipe exists in its `declarations` (if possible).
     */
    function makeDuplicateDeclarationError(node, data, kind) {
        const context = [];
        for (const decl of data) {
            if (decl.rawDeclarations === null) {
                continue;
            }
            // Try to find the reference to the declaration within the declarations array, to hang the
            // error there. If it can't be found, fall back on using the NgModule's name.
            const contextNode = decl.ref.getOriginForDiagnostics(decl.rawDeclarations, decl.ngModule.name);
            context.push(makeRelatedInformation(contextNode, `'${node.name.text}' is listed in the declarations of the NgModule '${decl.ngModule.name.text}'.`));
        }
        // Finally, produce the diagnostic.
        return makeDiagnostic(ErrorCode.NGMODULE_DECLARATION_NOT_UNIQUE, node.name, `The ${kind} '${node.name.text}' is declared by more than one NgModule.`, context);
    }
    /**
     * Resolves the given `rawProviders` into `ClassDeclarations` and returns
     * a set containing those that are known to require a factory definition.
     * @param rawProviders Expression that declared the providers array in the source.
     */
    function resolveProvidersRequiringFactory(rawProviders, reflector, evaluator) {
        const providers = new Set();
        const resolvedProviders = evaluator.evaluate(rawProviders);
        if (!Array.isArray(resolvedProviders)) {
            return providers;
        }
        resolvedProviders.forEach(function processProviders(provider) {
            let tokenClass = null;
            if (Array.isArray(provider)) {
                // If we ran into an array, recurse into it until we've resolve all the classes.
                provider.forEach(processProviders);
            }
            else if (provider instanceof Reference$1) {
                tokenClass = provider;
            }
            else if (provider instanceof Map && provider.has('useClass') && !provider.has('deps')) {
                const useExisting = provider.get('useClass');
                if (useExisting instanceof Reference$1) {
                    tokenClass = useExisting;
                }
            }
            if (tokenClass !== null && reflector.isClass(tokenClass.node)) {
                const constructorParameters = reflector.getConstructorParameters(tokenClass.node);
                // Note that we only want to capture providers with a non-trivial constructor,
                // because they're the ones that might be using DI and need to be decorated.
                if (constructorParameters !== null && constructorParameters.length > 0) {
                    providers.add(tokenClass);
                }
            }
        });
        return providers;
    }
    /**
     * Create an R3Reference for a class.
     *
     * The `value` is the exported declaration of the class from its source file.
     * The `type` is an expression that would be used by ngcc in the typings (.d.ts) files.
     */
    function wrapTypeReference(reflector, clazz) {
        const dtsClass = reflector.getDtsDeclaration(clazz);
        const value = new WrappedNodeExpr(clazz.name);
        const type = dtsClass !== null && isNamedClassDeclaration(dtsClass) ?
            new WrappedNodeExpr(dtsClass.name) :
            value;
        return { value, type };
    }
    /** Creates a ParseSourceSpan for a TypeScript node. */
    function createSourceSpan(node) {
        const sf = node.getSourceFile();
        const [startOffset, endOffset] = [node.getStart(), node.getEnd()];
        const { line: startLine, character: startCol } = sf.getLineAndCharacterOfPosition(startOffset);
        const { line: endLine, character: endCol } = sf.getLineAndCharacterOfPosition(endOffset);
        const parseSf = new ParseSourceFile(sf.getFullText(), sf.fileName);
        // +1 because values are zero-indexed.
        return new ParseSourceSpan(new ParseLocation(parseSf, startOffset, startLine + 1, startCol + 1), new ParseLocation(parseSf, endOffset, endLine + 1, endCol + 1));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Gets the diagnostics for a set of provider classes.
     * @param providerClasses Classes that should be checked.
     * @param providersDeclaration Node that declares the providers array.
     * @param registry Registry that keeps track of the registered injectable classes.
     */
    function getProviderDiagnostics(providerClasses, providersDeclaration, registry) {
        const diagnostics = [];
        for (const provider of providerClasses) {
            if (registry.isInjectable(provider.node)) {
                continue;
            }
            const contextNode = provider.getOriginForDiagnostics(providersDeclaration);
            diagnostics.push(makeDiagnostic(ErrorCode.UNDECORATED_PROVIDER, contextNode, `The class '${provider.node.name
            .text}' cannot be created via dependency injection, as it does not have an Angular decorator. This will result in an error at runtime.

Either add the @Injectable() decorator to '${provider.node.name
            .text}', or configure a different provider (such as a provider with 'useFactory').
`, [makeRelatedInformation(provider.node, `'${provider.node.name.text}' is declared here.`)]));
        }
        return diagnostics;
    }
    function getDirectiveDiagnostics(node, reader, evaluator, reflector, scopeRegistry, kind) {
        let diagnostics = [];
        const addDiagnostics = (more) => {
            if (more === null) {
                return;
            }
            else if (diagnostics === null) {
                diagnostics = Array.isArray(more) ? more : [more];
            }
            else if (Array.isArray(more)) {
                diagnostics.push(...more);
            }
            else {
                diagnostics.push(more);
            }
        };
        const duplicateDeclarations = scopeRegistry.getDuplicateDeclarations(node);
        if (duplicateDeclarations !== null) {
            addDiagnostics(makeDuplicateDeclarationError(node, duplicateDeclarations, kind));
        }
        addDiagnostics(checkInheritanceOfDirective(node, reader, reflector, evaluator));
        return diagnostics;
    }
    function getUndecoratedClassWithAngularFeaturesDiagnostic(node) {
        return makeDiagnostic(ErrorCode.UNDECORATED_CLASS_USING_ANGULAR_FEATURES, node.name, `Class is using Angular features but is not decorated. Please add an explicit ` +
            `Angular decorator.`);
    }
    function checkInheritanceOfDirective(node, reader, reflector, evaluator) {
        if (!reflector.isClass(node) || reflector.getConstructorParameters(node) !== null) {
            // We should skip nodes that aren't classes. If a constructor exists, then no base class
            // definition is required on the runtime side - it's legal to inherit from any class.
            return null;
        }
        // The extends clause is an expression which can be as dynamic as the user wants. Try to
        // evaluate it, but fall back on ignoring the clause if it can't be understood. This is a View
        // Engine compatibility hack: View Engine ignores 'extends' expressions that it cannot understand.
        let baseClass = readBaseClass$1(node, reflector, evaluator);
        while (baseClass !== null) {
            if (baseClass === 'dynamic') {
                return null;
            }
            // We can skip the base class if it has metadata.
            const baseClassMeta = reader.getDirectiveMetadata(baseClass);
            if (baseClassMeta !== null) {
                return null;
            }
            // If the base class has a blank constructor we can skip it since it can't be using DI.
            const baseClassConstructorParams = reflector.getConstructorParameters(baseClass.node);
            const newParentClass = readBaseClass$1(baseClass.node, reflector, evaluator);
            if (baseClassConstructorParams !== null && baseClassConstructorParams.length > 0) {
                // This class has a non-trivial constructor, that's an error!
                return getInheritedUndecoratedCtorDiagnostic(node, baseClass, reader);
            }
            else if (baseClassConstructorParams !== null || newParentClass === null) {
                // This class has a trivial constructor, or no constructor + is the
                // top of the inheritance chain, so it's okay.
                return null;
            }
            // Go up the chain and continue
            baseClass = newParentClass;
        }
        return null;
    }
    function getInheritedUndecoratedCtorDiagnostic(node, baseClass, reader) {
        const subclassMeta = reader.getDirectiveMetadata(new Reference$1(node));
        const dirOrComp = subclassMeta.isComponent ? 'Component' : 'Directive';
        const baseClassName = baseClass.debugName;
        return makeDiagnostic(ErrorCode.DIRECTIVE_INHERITS_UNDECORATED_CTOR, node.name, `The ${dirOrComp.toLowerCase()} ${node.name.text} inherits its constructor from ${baseClassName}, ` +
            `but the latter does not have an Angular decorator of its own. Dependency injection will not be able to ` +
            `resolve the parameters of ${baseClassName}'s constructor. Either add a @Directive decorator ` +
            `to ${baseClassName}, or add an explicit constructor to ${node.name.text}.`);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function compileNgFactoryDefField(metadata) {
        const res = compileFactoryFunction(metadata);
        return { name: 'fac', initializer: res.factory, statements: res.statements, type: res.type };
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Given a class declaration, generate a call to `setClassMetadata` with the Angular metadata
     * present on the class or its member fields.
     *
     * If no such metadata is present, this function returns `null`. Otherwise, the call is returned
     * as a `Statement` for inclusion along with the class.
     */
    function generateSetClassMetadataCall(clazz, reflection, defaultImportRecorder, isCore, annotateForClosureCompiler) {
        if (!reflection.isClass(clazz)) {
            return null;
        }
        const id = ts.updateIdentifier(reflection.getAdjacentNameOfClass(clazz));
        // Reflect over the class decorators. If none are present, or those that are aren't from
        // Angular, then return null. Otherwise, turn them into metadata.
        const classDecorators = reflection.getDecoratorsOfDeclaration(clazz);
        if (classDecorators === null) {
            return null;
        }
        const ngClassDecorators = classDecorators.filter(dec => isAngularDecorator$1(dec, isCore))
            .map((decorator) => decoratorToMetadata(decorator, annotateForClosureCompiler));
        if (ngClassDecorators.length === 0) {
            return null;
        }
        const metaDecorators = ts.createArrayLiteral(ngClassDecorators);
        // Convert the constructor parameters to metadata, passing null if none are present.
        let metaCtorParameters = new LiteralExpr(null);
        const classCtorParameters = reflection.getConstructorParameters(clazz);
        if (classCtorParameters !== null) {
            const ctorParameters = classCtorParameters.map(param => ctorParameterToMetadata(param, defaultImportRecorder, isCore));
            metaCtorParameters = new FunctionExpr([], [
                new ReturnStatement(new LiteralArrayExpr(ctorParameters)),
            ]);
        }
        // Do the same for property decorators.
        let metaPropDecorators = ts.createNull();
        const classMembers = reflection.getMembersOfClass(clazz).filter(member => !member.isStatic && member.decorators !== null && member.decorators.length > 0);
        const duplicateDecoratedMemberNames = classMembers.map(member => member.name).filter((name, i, arr) => arr.indexOf(name) < i);
        if (duplicateDecoratedMemberNames.length > 0) {
            // This should theoretically never happen, because the only way to have duplicate instance
            // member names is getter/setter pairs and decorators cannot appear in both a getter and the
            // corresponding setter.
            throw new Error(`Duplicate decorated properties found on class '${clazz.name.text}': ` +
                duplicateDecoratedMemberNames.join(', '));
        }
        const decoratedMembers = classMembers.map(member => { var _a; return classMemberToMetadata((_a = member.nameNode) !== null && _a !== void 0 ? _a : member.name, member.decorators, isCore); });
        if (decoratedMembers.length > 0) {
            metaPropDecorators = ts.createObjectLiteral(decoratedMembers);
        }
        // Generate a pure call to setClassMetadata with the class identifier and its metadata.
        const setClassMetadata = new ExternalExpr(Identifiers.setClassMetadata);
        const fnCall = new InvokeFunctionExpr(
        /* fn */ setClassMetadata, 
        /* args */
        [
            new WrappedNodeExpr(id),
            new WrappedNodeExpr(metaDecorators),
            metaCtorParameters,
            new WrappedNodeExpr(metaPropDecorators),
        ]);
        const iifeFn = new FunctionExpr([], [fnCall.toStmt()], NONE_TYPE);
        const iife = new InvokeFunctionExpr(
        /* fn */ iifeFn, 
        /* args */ [], 
        /* type */ undefined, 
        /* sourceSpan */ undefined, 
        /* pure */ true);
        return iife.toStmt();
    }
    /**
     * Convert a reflected constructor parameter to metadata.
     */
    function ctorParameterToMetadata(param, defaultImportRecorder, isCore) {
        // Parameters sometimes have a type that can be referenced. If so, then use it, otherwise
        // its type is undefined.
        const type = param.typeValueReference.kind !== 2 /* UNAVAILABLE */ ?
            valueReferenceToExpression(param.typeValueReference, defaultImportRecorder) :
            new LiteralExpr(undefined);
        const mapEntries = [
            { key: 'type', value: type, quoted: false },
        ];
        // If the parameter has decorators, include the ones from Angular.
        if (param.decorators !== null) {
            const ngDecorators = param.decorators.filter(dec => isAngularDecorator$1(dec, isCore))
                .map((decorator) => decoratorToMetadata(decorator));
            const value = new WrappedNodeExpr(ts.createArrayLiteral(ngDecorators));
            mapEntries.push({ key: 'decorators', value, quoted: false });
        }
        return literalMap(mapEntries);
    }
    /**
     * Convert a reflected class member to metadata.
     */
    function classMemberToMetadata(name, decorators, isCore) {
        const ngDecorators = decorators.filter(dec => isAngularDecorator$1(dec, isCore))
            .map((decorator) => decoratorToMetadata(decorator));
        const decoratorMeta = ts.createArrayLiteral(ngDecorators);
        return ts.createPropertyAssignment(name, decoratorMeta);
    }
    /**
     * Convert a reflected decorator to metadata.
     */
    function decoratorToMetadata(decorator, wrapFunctionsInParens) {
        if (decorator.identifier === null) {
            throw new Error('Illegal state: synthesized decorator cannot be emitted in class metadata.');
        }
        // Decorators have a type.
        const properties = [
            ts.createPropertyAssignment('type', ts.getMutableClone(decorator.identifier)),
        ];
        // Sometimes they have arguments.
        if (decorator.args !== null && decorator.args.length > 0) {
            const args = decorator.args.map(arg => {
                const expr = ts.getMutableClone(arg);
                return wrapFunctionsInParens ? wrapFunctionExpressionsInParens(expr) : expr;
            });
            properties.push(ts.createPropertyAssignment('args', ts.createArrayLiteral(args)));
        }
        return ts.createObjectLiteral(properties, true);
    }
    /**
     * Whether a given decorator should be treated as an Angular decorator.
     *
     * Either it's used in @angular/core, or it's imported from there.
     */
    function isAngularDecorator$1(decorator, isCore) {
        return isCore || (decorator.import !== null && decorator.import.from === '@angular/core');
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const EMPTY_OBJECT = {};
    const FIELD_DECORATORS = [
        'Input', 'Output', 'ViewChild', 'ViewChildren', 'ContentChild', 'ContentChildren', 'HostBinding',
        'HostListener'
    ];
    const LIFECYCLE_HOOKS = new Set([
        'ngOnChanges', 'ngOnInit', 'ngOnDestroy', 'ngDoCheck', 'ngAfterViewInit', 'ngAfterViewChecked',
        'ngAfterContentInit', 'ngAfterContentChecked'
    ]);
    class DirectiveDecoratorHandler {
        constructor(reflector, evaluator, metaRegistry, scopeRegistry, metaReader, defaultImportRecorder, injectableRegistry, isCore, annotateForClosureCompiler, compileUndecoratedClassesWithAngularFeatures) {
            this.reflector = reflector;
            this.evaluator = evaluator;
            this.metaRegistry = metaRegistry;
            this.scopeRegistry = scopeRegistry;
            this.metaReader = metaReader;
            this.defaultImportRecorder = defaultImportRecorder;
            this.injectableRegistry = injectableRegistry;
            this.isCore = isCore;
            this.annotateForClosureCompiler = annotateForClosureCompiler;
            this.compileUndecoratedClassesWithAngularFeatures = compileUndecoratedClassesWithAngularFeatures;
            this.precedence = HandlerPrecedence.PRIMARY;
            this.name = DirectiveDecoratorHandler.name;
        }
        detect(node, decorators) {
            // If a class is undecorated but uses Angular features, we detect it as an
            // abstract directive. This is an unsupported pattern as of v10, but we want
            // to still detect these patterns so that we can report diagnostics, or compile
            // them for backwards compatibility in ngcc.
            if (!decorators) {
                const angularField = this.findClassFieldWithAngularFeatures(node);
                return angularField ? { trigger: angularField.node, decorator: null, metadata: null } :
                    undefined;
            }
            else {
                const decorator = findAngularDecorator(decorators, 'Directive', this.isCore);
                return decorator ? { trigger: decorator.node, decorator, metadata: decorator } : undefined;
            }
        }
        analyze(node, decorator, flags = HandlerFlags.NONE) {
            // Skip processing of the class declaration if compilation of undecorated classes
            // with Angular features is disabled. Previously in ngtsc, such classes have always
            // been processed, but we want to enforce a consistent decorator mental model.
            // See: https://v9.angular.io/guide/migration-undecorated-classes.
            if (this.compileUndecoratedClassesWithAngularFeatures === false && decorator === null) {
                return { diagnostics: [getUndecoratedClassWithAngularFeaturesDiagnostic(node)] };
            }
            const directiveResult = extractDirectiveMetadata(node, decorator, this.reflector, this.evaluator, this.defaultImportRecorder, this.isCore, flags, this.annotateForClosureCompiler);
            const analysis = directiveResult && directiveResult.metadata;
            if (analysis === undefined) {
                return {};
            }
            let providersRequiringFactory = null;
            if (directiveResult !== undefined && directiveResult.decorator.has('providers')) {
                providersRequiringFactory = resolveProvidersRequiringFactory(directiveResult.decorator.get('providers'), this.reflector, this.evaluator);
            }
            return {
                analysis: {
                    meta: analysis,
                    metadataStmt: generateSetClassMetadataCall(node, this.reflector, this.defaultImportRecorder, this.isCore, this.annotateForClosureCompiler),
                    baseClass: readBaseClass$1(node, this.reflector, this.evaluator),
                    guards: extractDirectiveGuards(node, this.reflector),
                    providersRequiringFactory
                }
            };
        }
        register(node, analysis) {
            // Register this directive's information with the `MetadataRegistry`. This ensures that
            // the information about the directive is available during the compile() phase.
            const ref = new Reference$1(node);
            this.metaRegistry.registerDirectiveMetadata(Object.assign({ ref, name: node.name.text, selector: analysis.meta.selector, exportAs: analysis.meta.exportAs, inputs: analysis.meta.inputs, outputs: analysis.meta.outputs, queries: analysis.meta.queries.map(query => query.propertyName), isComponent: false, baseClass: analysis.baseClass }, analysis.guards));
            this.injectableRegistry.registerInjectable(node);
        }
        resolve(node, analysis) {
            const diagnostics = [];
            if (analysis.providersRequiringFactory !== null &&
                analysis.meta.providers instanceof WrappedNodeExpr) {
                const providerDiagnostics = getProviderDiagnostics(analysis.providersRequiringFactory, analysis.meta.providers.node, this.injectableRegistry);
                diagnostics.push(...providerDiagnostics);
            }
            const directiveDiagnostics = getDirectiveDiagnostics(node, this.metaReader, this.evaluator, this.reflector, this.scopeRegistry, 'Directive');
            if (directiveDiagnostics !== null) {
                diagnostics.push(...directiveDiagnostics);
            }
            return { diagnostics: diagnostics.length > 0 ? diagnostics : undefined };
        }
        compile(node, analysis, resolution, pool) {
            const meta = analysis.meta;
            const res = compileDirectiveFromMetadata(meta, pool, makeBindingParser());
            const factoryRes = compileNgFactoryDefField(Object.assign(Object.assign({}, meta), { injectFn: Identifiers.directiveInject, target: R3FactoryTarget.Directive }));
            if (analysis.metadataStmt !== null) {
                factoryRes.statements.push(analysis.metadataStmt);
            }
            return [
                factoryRes, {
                    name: 'dir',
                    initializer: res.expression,
                    statements: [],
                    type: res.type,
                }
            ];
        }
        /**
         * Checks if a given class uses Angular features and returns the TypeScript node
         * that indicated the usage. Classes are considered using Angular features if they
         * contain class members that are either decorated with a known Angular decorator,
         * or if they correspond to a known Angular lifecycle hook.
         */
        findClassFieldWithAngularFeatures(node) {
            return this.reflector.getMembersOfClass(node).find(member => {
                if (!member.isStatic && member.kind === ClassMemberKind.Method &&
                    LIFECYCLE_HOOKS.has(member.name)) {
                    return true;
                }
                if (member.decorators) {
                    return member.decorators.some(decorator => FIELD_DECORATORS.some(decoratorName => isAngularDecorator(decorator, decoratorName, this.isCore)));
                }
                return false;
            });
        }
    }
    /**
     * Helper function to extract metadata from a `Directive` or `Component`. `Directive`s without a
     * selector are allowed to be used for abstract base classes. These abstract directives should not
     * appear in the declarations of an `NgModule` and additional verification is done when processing
     * the module.
     */
    function extractDirectiveMetadata(clazz, decorator, reflector, evaluator, defaultImportRecorder, isCore, flags, annotateForClosureCompiler, defaultSelector = null) {
        let directive;
        if (decorator === null || decorator.args === null || decorator.args.length === 0) {
            directive = new Map();
        }
        else if (decorator.args.length !== 1) {
            throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(decorator), `Incorrect number of arguments to @${decorator.name} decorator`);
        }
        else {
            const meta = unwrapExpression(decorator.args[0]);
            if (!ts.isObjectLiteralExpression(meta)) {
                throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, `@${decorator.name} argument must be an object literal`);
            }
            directive = reflectObjectLiteral(meta);
        }
        if (directive.has('jit')) {
            // The only allowed value is true, so there's no need to expand further.
            return undefined;
        }
        const members = reflector.getMembersOfClass(clazz);
        // Precompute a list of ts.ClassElements that have decorators. This includes things like @Input,
        // @Output, @HostBinding, etc.
        const decoratedElements = members.filter(member => !member.isStatic && member.decorators !== null);
        const coreModule = isCore ? undefined : '@angular/core';
        // Construct the map of inputs both from the @Directive/@Component
        // decorator, and the decorated
        // fields.
        const inputsFromMeta = parseFieldToPropertyMapping(directive, 'inputs', evaluator);
        const inputsFromFields = parseDecoratedFields(filterToMembersWithDecorator(decoratedElements, 'Input', coreModule), evaluator, resolveInput);
        // And outputs.
        const outputsFromMeta = parseFieldToPropertyMapping(directive, 'outputs', evaluator);
        const outputsFromFields = parseDecoratedFields(filterToMembersWithDecorator(decoratedElements, 'Output', coreModule), evaluator, resolveOutput);
        // Construct the list of queries.
        const contentChildFromFields = queriesFromFields(filterToMembersWithDecorator(decoratedElements, 'ContentChild', coreModule), reflector, evaluator);
        const contentChildrenFromFields = queriesFromFields(filterToMembersWithDecorator(decoratedElements, 'ContentChildren', coreModule), reflector, evaluator);
        const queries = [...contentChildFromFields, ...contentChildrenFromFields];
        // Construct the list of view queries.
        const viewChildFromFields = queriesFromFields(filterToMembersWithDecorator(decoratedElements, 'ViewChild', coreModule), reflector, evaluator);
        const viewChildrenFromFields = queriesFromFields(filterToMembersWithDecorator(decoratedElements, 'ViewChildren', coreModule), reflector, evaluator);
        const viewQueries = [...viewChildFromFields, ...viewChildrenFromFields];
        if (directive.has('queries')) {
            const queriesFromDecorator = extractQueriesFromDecorator(directive.get('queries'), reflector, evaluator, isCore);
            queries.push(...queriesFromDecorator.content);
            viewQueries.push(...queriesFromDecorator.view);
        }
        // Parse the selector.
        let selector = defaultSelector;
        if (directive.has('selector')) {
            const expr = directive.get('selector');
            const resolved = evaluator.evaluate(expr);
            if (typeof resolved !== 'string') {
                throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, expr, `selector must be a string`);
            }
            // use default selector in case selector is an empty string
            selector = resolved === '' ? defaultSelector : resolved;
            if (!selector) {
                throw new FatalDiagnosticError(ErrorCode.DIRECTIVE_MISSING_SELECTOR, expr, `Directive ${clazz.name.text} has no selector, please add it!`);
            }
        }
        const host = extractHostBindings$1(decoratedElements, evaluator, coreModule, directive);
        const providers = directive.has('providers') ?
            new WrappedNodeExpr(annotateForClosureCompiler ?
                wrapFunctionExpressionsInParens(directive.get('providers')) :
                directive.get('providers')) :
            null;
        // Determine if `ngOnChanges` is a lifecycle hook defined on the component.
        const usesOnChanges = members.some(member => !member.isStatic && member.kind === ClassMemberKind.Method &&
            member.name === 'ngOnChanges');
        // Parse exportAs.
        let exportAs = null;
        if (directive.has('exportAs')) {
            const expr = directive.get('exportAs');
            const resolved = evaluator.evaluate(expr);
            if (typeof resolved !== 'string') {
                throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, expr, `exportAs must be a string`);
            }
            exportAs = resolved.split(',').map(part => part.trim());
        }
        const rawCtorDeps = getConstructorDependencies(clazz, reflector, defaultImportRecorder, isCore);
        let ctorDeps;
        // Non-abstract directives (those with a selector) require valid constructor dependencies, whereas
        // abstract directives are allowed to have invalid dependencies, given that a subclass may call
        // the constructor explicitly.
        if (selector !== null) {
            ctorDeps = validateConstructorDependencies(clazz, rawCtorDeps);
        }
        else {
            ctorDeps = unwrapConstructorDependencies(rawCtorDeps);
        }
        // Detect if the component inherits from another class
        const usesInheritance = reflector.hasBaseClass(clazz);
        const type = wrapTypeReference(reflector, clazz);
        const internalType = new WrappedNodeExpr(reflector.getInternalNameOfClass(clazz));
        const metadata = {
            name: clazz.name.text,
            deps: ctorDeps,
            host,
            lifecycle: {
                usesOnChanges,
            },
            inputs: Object.assign(Object.assign({}, inputsFromMeta), inputsFromFields),
            outputs: Object.assign(Object.assign({}, outputsFromMeta), outputsFromFields),
            queries,
            viewQueries,
            selector,
            fullInheritance: !!(flags & HandlerFlags.FULL_INHERITANCE),
            type,
            internalType,
            typeArgumentCount: reflector.getGenericArityOfClass(clazz) || 0,
            typeSourceSpan: createSourceSpan(clazz.name),
            usesInheritance,
            exportAs,
            providers
        };
        return { decorator: directive, metadata };
    }
    function extractQueryMetadata(exprNode, name, args, propertyName, reflector, evaluator) {
        if (args.length === 0) {
            throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, exprNode, `@${name} must have arguments`);
        }
        const first = name === 'ViewChild' || name === 'ContentChild';
        const node = unwrapForwardRef(args[0], reflector);
        const arg = evaluator.evaluate(node);
        /** Whether or not this query should collect only static results (see view/api.ts)  */
        let isStatic = false;
        // Extract the predicate
        let predicate = null;
        if (arg instanceof Reference$1 || arg instanceof DynamicValue) {
            // References and predicates that could not be evaluated statically are emitted as is.
            predicate = new WrappedNodeExpr(node);
        }
        else if (typeof arg === 'string') {
            predicate = [arg];
        }
        else if (isStringArrayOrDie(arg, `@${name} predicate`, node)) {
            predicate = arg;
        }
        else {
            throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, node, `@${name} predicate cannot be interpreted`);
        }
        // Extract the read and descendants options.
        let read = null;
        // The default value for descendants is true for every decorator except @ContentChildren.
        let descendants = name !== 'ContentChildren';
        if (args.length === 2) {
            const optionsExpr = unwrapExpression(args[1]);
            if (!ts.isObjectLiteralExpression(optionsExpr)) {
                throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, optionsExpr, `@${name} options must be an object literal`);
            }
            const options = reflectObjectLiteral(optionsExpr);
            if (options.has('read')) {
                read = new WrappedNodeExpr(options.get('read'));
            }
            if (options.has('descendants')) {
                const descendantsExpr = options.get('descendants');
                const descendantsValue = evaluator.evaluate(descendantsExpr);
                if (typeof descendantsValue !== 'boolean') {
                    throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, descendantsExpr, `@${name} options.descendants must be a boolean`);
                }
                descendants = descendantsValue;
            }
            if (options.has('static')) {
                const staticValue = evaluator.evaluate(options.get('static'));
                if (typeof staticValue !== 'boolean') {
                    throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, node, `@${name} options.static must be a boolean`);
                }
                isStatic = staticValue;
            }
        }
        else if (args.length > 2) {
            // Too many arguments.
            throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, node, `@${name} has too many arguments`);
        }
        return {
            propertyName,
            predicate,
            first,
            descendants,
            read,
            static: isStatic,
        };
    }
    function extractQueriesFromDecorator(queryData, reflector, evaluator, isCore) {
        const content = [], view = [];
        if (!ts.isObjectLiteralExpression(queryData)) {
            throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, queryData, 'Decorator queries metadata must be an object literal');
        }
        reflectObjectLiteral(queryData).forEach((queryExpr, propertyName) => {
            queryExpr = unwrapExpression(queryExpr);
            if (!ts.isNewExpression(queryExpr) || !ts.isIdentifier(queryExpr.expression)) {
                throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, queryData, 'Decorator query metadata must be an instance of a query type');
            }
            const type = reflector.getImportOfIdentifier(queryExpr.expression);
            if (type === null || (!isCore && type.from !== '@angular/core') ||
                !QUERY_TYPES.has(type.name)) {
                throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, queryData, 'Decorator query metadata must be an instance of a query type');
            }
            const query = extractQueryMetadata(queryExpr, type.name, queryExpr.arguments || [], propertyName, reflector, evaluator);
            if (type.name.startsWith('Content')) {
                content.push(query);
            }
            else {
                view.push(query);
            }
        });
        return { content, view };
    }
    function isStringArrayOrDie(value, name, node) {
        if (!Array.isArray(value)) {
            return false;
        }
        for (let i = 0; i < value.length; i++) {
            if (typeof value[i] !== 'string') {
                throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, node, `Failed to resolve ${name} at position ${i} to a string`);
            }
        }
        return true;
    }
    function parseFieldArrayValue(directive, field, evaluator) {
        if (!directive.has(field)) {
            return null;
        }
        // Resolve the field of interest from the directive metadata to a string[].
        const expression = directive.get(field);
        const value = evaluator.evaluate(expression);
        if (!isStringArrayOrDie(value, field, expression)) {
            throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, expression, `Failed to resolve @Directive.${field} to a string array`);
        }
        return value;
    }
    /**
     * Interpret property mapping fields on the decorator (e.g. inputs or outputs) and return the
     * correctly shaped metadata object.
     */
    function parseFieldToPropertyMapping(directive, field, evaluator) {
        const metaValues = parseFieldArrayValue(directive, field, evaluator);
        if (!metaValues) {
            return EMPTY_OBJECT;
        }
        return metaValues.reduce((results, value) => {
            // Either the value is 'field' or 'field: property'. In the first case, `property` will
            // be undefined, in which case the field name should also be used as the property name.
            const [field, property] = value.split(':', 2).map(str => str.trim());
            results[field] = property || field;
            return results;
        }, {});
    }
    /**
     * Parse property decorators (e.g. `Input` or `Output`) and return the correctly shaped metadata
     * object.
     */
    function parseDecoratedFields(fields, evaluator, mapValueResolver) {
        return fields.reduce((results, field) => {
            const fieldName = field.member.name;
            field.decorators.forEach(decorator => {
                // The decorator either doesn't have an argument (@Input()) in which case the property
                // name is used, or it has one argument (@Output('named')).
                if (decorator.args == null || decorator.args.length === 0) {
                    results[fieldName] = fieldName;
                }
                else if (decorator.args.length === 1) {
                    const property = evaluator.evaluate(decorator.args[0]);
                    if (typeof property !== 'string') {
                        throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, Decorator.nodeForError(decorator), `@${decorator.name} decorator argument must resolve to a string`);
                    }
                    results[fieldName] = mapValueResolver(property, fieldName);
                }
                else {
                    // Too many arguments.
                    throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(decorator), `@${decorator.name} can have at most one argument, got ${decorator.args.length} argument(s)`);
                }
            });
            return results;
        }, {});
    }
    function resolveInput(publicName, internalName) {
        return [publicName, internalName];
    }
    function resolveOutput(publicName, internalName) {
        return publicName;
    }
    function queriesFromFields(fields, reflector, evaluator) {
        return fields.map(({ member, decorators }) => {
            const decorator = decorators[0];
            const node = member.node || Decorator.nodeForError(decorator);
            // Throw in case of `@Input() @ContentChild('foo') foo: any`, which is not supported in Ivy
            if (member.decorators.some(v => v.name === 'Input')) {
                throw new FatalDiagnosticError(ErrorCode.DECORATOR_COLLISION, node, 'Cannot combine @Input decorators with query decorators');
            }
            if (decorators.length !== 1) {
                throw new FatalDiagnosticError(ErrorCode.DECORATOR_COLLISION, node, 'Cannot have multiple query decorators on the same class member');
            }
            else if (!isPropertyTypeMember(member)) {
                throw new FatalDiagnosticError(ErrorCode.DECORATOR_UNEXPECTED, node, 'Query decorator must go on a property-type member');
            }
            return extractQueryMetadata(node, decorator.name, decorator.args || [], member.name, reflector, evaluator);
        });
    }
    function isPropertyTypeMember(member) {
        return member.kind === ClassMemberKind.Getter || member.kind === ClassMemberKind.Setter ||
            member.kind === ClassMemberKind.Property;
    }
    function evaluateHostExpressionBindings(hostExpr, evaluator) {
        const hostMetaMap = evaluator.evaluate(hostExpr);
        if (!(hostMetaMap instanceof Map)) {
            throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, hostExpr, `Decorator host metadata must be an object`);
        }
        const hostMetadata = {};
        hostMetaMap.forEach((value, key) => {
            // Resolve Enum references to their declared value.
            if (value instanceof EnumValue) {
                value = value.resolved;
            }
            if (typeof key !== 'string') {
                throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, hostExpr, `Decorator host metadata must be a string -> string object, but found unparseable key`);
            }
            if (typeof value == 'string') {
                hostMetadata[key] = value;
            }
            else if (value instanceof DynamicValue) {
                hostMetadata[key] = new WrappedNodeExpr(value.node);
            }
            else {
                throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, hostExpr, `Decorator host metadata must be a string -> string object, but found unparseable value`);
            }
        });
        const bindings = parseHostBindings(hostMetadata);
        const errors = verifyHostBindings(bindings, createSourceSpan(hostExpr));
        if (errors.length > 0) {
            throw new FatalDiagnosticError(
            // TODO: provide more granular diagnostic and output specific host expression that
            // triggered an error instead of the whole host object.
            ErrorCode.HOST_BINDING_PARSE_ERROR, hostExpr, errors.map((error) => error.msg).join('\n'));
        }
        return bindings;
    }
    function extractHostBindings$1(members, evaluator, coreModule, metadata) {
        let bindings;
        if (metadata && metadata.has('host')) {
            bindings = evaluateHostExpressionBindings(metadata.get('host'), evaluator);
        }
        else {
            bindings = parseHostBindings({});
        }
        filterToMembersWithDecorator(members, 'HostBinding', coreModule)
            .forEach(({ member, decorators }) => {
            decorators.forEach(decorator => {
                let hostPropertyName = member.name;
                if (decorator.args !== null && decorator.args.length > 0) {
                    if (decorator.args.length !== 1) {
                        throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(decorator), `@HostBinding can have at most one argument, got ${decorator.args.length} argument(s)`);
                    }
                    const resolved = evaluator.evaluate(decorator.args[0]);
                    if (typeof resolved !== 'string') {
                        throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, Decorator.nodeForError(decorator), `@HostBinding's argument must be a string`);
                    }
                    hostPropertyName = resolved;
                }
                bindings.properties[hostPropertyName] = member.name;
            });
        });
        filterToMembersWithDecorator(members, 'HostListener', coreModule)
            .forEach(({ member, decorators }) => {
            decorators.forEach(decorator => {
                let eventName = member.name;
                let args = [];
                if (decorator.args !== null && decorator.args.length > 0) {
                    if (decorator.args.length > 2) {
                        throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, decorator.args[2], `@HostListener can have at most two arguments`);
                    }
                    const resolved = evaluator.evaluate(decorator.args[0]);
                    if (typeof resolved !== 'string') {
                        throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, decorator.args[0], `@HostListener's event name argument must be a string`);
                    }
                    eventName = resolved;
                    if (decorator.args.length === 2) {
                        const expression = decorator.args[1];
                        const resolvedArgs = evaluator.evaluate(decorator.args[1]);
                        if (!isStringArrayOrDie(resolvedArgs, '@HostListener.args', expression)) {
                            throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, decorator.args[1], `@HostListener's second argument must be a string array`);
                        }
                        args = resolvedArgs;
                    }
                }
                bindings.listeners[eventName] = `${member.name}(${args.join(',')})`;
            });
        });
        return bindings;
    }
    const QUERY_TYPES = new Set([
        'ContentChild',
        'ContentChildren',
        'ViewChild',
        'ViewChildren',
    ]);

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const EMPTY_MAP = new Map();
    const EMPTY_ARRAY = [];
    /**
     * `DecoratorHandler` which handles the `@Component` annotation.
     */
    class ComponentDecoratorHandler {
        constructor(reflector, evaluator, metaRegistry, metaReader, scopeReader, scopeRegistry, isCore, resourceLoader, rootDirs, defaultPreserveWhitespaces, i18nUseExternalIds, enableI18nLegacyMessageIdFormat, i18nNormalizeLineEndingsInICUs, moduleResolver, cycleAnalyzer, refEmitter, defaultImportRecorder, depTracker, injectableRegistry, annotateForClosureCompiler) {
            this.reflector = reflector;
            this.evaluator = evaluator;
            this.metaRegistry = metaRegistry;
            this.metaReader = metaReader;
            this.scopeReader = scopeReader;
            this.scopeRegistry = scopeRegistry;
            this.isCore = isCore;
            this.resourceLoader = resourceLoader;
            this.rootDirs = rootDirs;
            this.defaultPreserveWhitespaces = defaultPreserveWhitespaces;
            this.i18nUseExternalIds = i18nUseExternalIds;
            this.enableI18nLegacyMessageIdFormat = enableI18nLegacyMessageIdFormat;
            this.i18nNormalizeLineEndingsInICUs = i18nNormalizeLineEndingsInICUs;
            this.moduleResolver = moduleResolver;
            this.cycleAnalyzer = cycleAnalyzer;
            this.refEmitter = refEmitter;
            this.defaultImportRecorder = defaultImportRecorder;
            this.depTracker = depTracker;
            this.injectableRegistry = injectableRegistry;
            this.annotateForClosureCompiler = annotateForClosureCompiler;
            this.literalCache = new Map();
            this.elementSchemaRegistry = new DomElementSchemaRegistry();
            /**
             * During the asynchronous preanalyze phase, it's necessary to parse the template to extract
             * any potential <link> tags which might need to be loaded. This cache ensures that work is not
             * thrown away, and the parsed template is reused during the analyze phase.
             */
            this.preanalyzeTemplateCache = new Map();
            this.precedence = HandlerPrecedence.PRIMARY;
            this.name = ComponentDecoratorHandler.name;
        }
        detect(node, decorators) {
            if (!decorators) {
                return undefined;
            }
            const decorator = findAngularDecorator(decorators, 'Component', this.isCore);
            if (decorator !== undefined) {
                return {
                    trigger: decorator.node,
                    decorator,
                    metadata: decorator,
                };
            }
            else {
                return undefined;
            }
        }
        preanalyze(node, decorator) {
            // In preanalyze, resource URLs associated with the component are asynchronously preloaded via
            // the resourceLoader. This is the only time async operations are allowed for a component.
            // These resources are:
            //
            // - the templateUrl, if there is one
            // - any styleUrls if present
            // - any stylesheets referenced from <link> tags in the template itself
            //
            // As a result of the last one, the template must be parsed as part of preanalysis to extract
            // <link> tags, which may involve waiting for the templateUrl to be resolved first.
            // If preloading isn't possible, then skip this step.
            if (!this.resourceLoader.canPreload) {
                return undefined;
            }
            const meta = this._resolveLiteral(decorator);
            const component = reflectObjectLiteral(meta);
            const containingFile = node.getSourceFile().fileName;
            // Convert a styleUrl string into a Promise to preload it.
            const resolveStyleUrl = (styleUrl) => {
                const resourceUrl = this.resourceLoader.resolve(styleUrl, containingFile);
                const promise = this.resourceLoader.preload(resourceUrl);
                return promise || Promise.resolve();
            };
            // A Promise that waits for the template and all <link>ed styles within it to be preloaded.
            const templateAndTemplateStyleResources = this._preloadAndParseTemplate(node, decorator, component, containingFile).then(template => {
                if (template === null) {
                    return undefined;
                }
                else {
                    return Promise.all(template.styleUrls.map(resolveStyleUrl)).then(() => undefined);
                }
            });
            // Extract all the styleUrls in the decorator.
            const styleUrls = this._extractStyleUrls(component, []);
            if (styleUrls === null) {
                // A fast path exists if there are no styleUrls, to just wait for
                // templateAndTemplateStyleResources.
                return templateAndTemplateStyleResources;
            }
            else {
                // Wait for both the template and all styleUrl resources to resolve.
                return Promise.all([templateAndTemplateStyleResources, ...styleUrls.map(resolveStyleUrl)])
                    .then(() => undefined);
            }
        }
        analyze(node, decorator, flags = HandlerFlags.NONE) {
            const containingFile = node.getSourceFile().fileName;
            this.literalCache.delete(decorator);
            // @Component inherits @Directive, so begin by extracting the @Directive metadata and building
            // on it.
            const directiveResult = extractDirectiveMetadata(node, decorator, this.reflector, this.evaluator, this.defaultImportRecorder, this.isCore, flags, this.annotateForClosureCompiler, this.elementSchemaRegistry.getDefaultComponentElementName());
            if (directiveResult === undefined) {
                // `extractDirectiveMetadata` returns undefined when the @Directive has `jit: true`. In this
                // case, compilation of the decorator is skipped. Returning an empty object signifies
                // that no analysis was produced.
                return {};
            }
            // Next, read the `@Component`-specific fields.
            const { decorator: component, metadata } = directiveResult;
            // Go through the root directories for this project, and select the one with the smallest
            // relative path representation.
            const relativeContextFilePath = this.rootDirs.reduce((previous, rootDir) => {
                const candidate = relative(absoluteFrom(rootDir), absoluteFrom(containingFile));
                if (previous === undefined || candidate.length < previous.length) {
                    return candidate;
                }
                else {
                    return previous;
                }
            }, undefined);
            // Note that we could technically combine the `viewProvidersRequiringFactory` and
            // `providersRequiringFactory` into a single set, but we keep the separate so that
            // we can distinguish where an error is coming from when logging the diagnostics in `resolve`.
            let viewProvidersRequiringFactory = null;
            let providersRequiringFactory = null;
            let wrappedViewProviders = null;
            if (component.has('viewProviders')) {
                const viewProviders = component.get('viewProviders');
                viewProvidersRequiringFactory =
                    resolveProvidersRequiringFactory(viewProviders, this.reflector, this.evaluator);
                wrappedViewProviders = new WrappedNodeExpr(this.annotateForClosureCompiler ? wrapFunctionExpressionsInParens(viewProviders) :
                    viewProviders);
            }
            if (component.has('providers')) {
                providersRequiringFactory = resolveProvidersRequiringFactory(component.get('providers'), this.reflector, this.evaluator);
            }
            // Parse the template.
            // If a preanalyze phase was executed, the template may already exist in parsed form, so check
            // the preanalyzeTemplateCache.
            // Extract a closure of the template parsing code so that it can be reparsed with different
            // options if needed, like in the indexing pipeline.
            let template;
            if (this.preanalyzeTemplateCache.has(node)) {
                // The template was parsed in preanalyze. Use it and delete it to save memory.
                const preanalyzed = this.preanalyzeTemplateCache.get(node);
                this.preanalyzeTemplateCache.delete(node);
                template = preanalyzed;
            }
            else {
                // The template was not already parsed. Either there's a templateUrl, or an inline template.
                if (component.has('templateUrl')) {
                    const templateUrlExpr = component.get('templateUrl');
                    const templateUrl = this.evaluator.evaluate(templateUrlExpr);
                    if (typeof templateUrl !== 'string') {
                        throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, templateUrlExpr, 'templateUrl must be a string');
                    }
                    const resourceUrl = this.resourceLoader.resolve(templateUrl, containingFile);
                    template = this._extractExternalTemplate(node, component, templateUrlExpr, resourceUrl);
                }
                else {
                    // Expect an inline template to be present.
                    template = this._extractInlineTemplate(node, decorator, component, containingFile);
                }
            }
            if (template.errors !== undefined) {
                throw new Error(`Errors parsing template: ${template.errors.map(e => e.toString()).join(', ')}`);
            }
            // Figure out the set of styles. The ordering here is important: external resources (styleUrls)
            // precede inline styles, and styles defined in the template override styles defined in the
            // component.
            let styles = null;
            const styleUrls = this._extractStyleUrls(component, template.styleUrls);
            if (styleUrls !== null) {
                if (styles === null) {
                    styles = [];
                }
                for (const styleUrl of styleUrls) {
                    const resourceUrl = this.resourceLoader.resolve(styleUrl, containingFile);
                    const resourceStr = this.resourceLoader.load(resourceUrl);
                    styles.push(resourceStr);
                    if (this.depTracker !== null) {
                        this.depTracker.addResourceDependency(node.getSourceFile(), absoluteFrom(resourceUrl));
                    }
                }
            }
            if (component.has('styles')) {
                const litStyles = parseFieldArrayValue(component, 'styles', this.evaluator);
                if (litStyles !== null) {
                    if (styles === null) {
                        styles = litStyles;
                    }
                    else {
                        styles.push(...litStyles);
                    }
                }
            }
            if (template.styles.length > 0) {
                if (styles === null) {
                    styles = template.styles;
                }
                else {
                    styles.push(...template.styles);
                }
            }
            const encapsulation = this._resolveEnumValue(component, 'encapsulation', 'ViewEncapsulation') || 0;
            const changeDetection = this._resolveEnumValue(component, 'changeDetection', 'ChangeDetectionStrategy');
            let animations = null;
            if (component.has('animations')) {
                animations = new WrappedNodeExpr(component.get('animations'));
            }
            const output = {
                analysis: {
                    baseClass: readBaseClass$1(node, this.reflector, this.evaluator),
                    meta: Object.assign(Object.assign({}, metadata), { template: {
                            nodes: template.emitNodes,
                            ngContentSelectors: template.ngContentSelectors,
                        }, encapsulation, interpolation: template.interpolation, styles: styles || [], 
                        // These will be replaced during the compilation step, after all `NgModule`s have been
                        // analyzed and the full compilation scope for the component can be realized.
                        animations, viewProviders: wrappedViewProviders, i18nUseExternalIds: this.i18nUseExternalIds, relativeContextFilePath }),
                    guards: extractDirectiveGuards(node, this.reflector),
                    metadataStmt: generateSetClassMetadataCall(node, this.reflector, this.defaultImportRecorder, this.isCore, this.annotateForClosureCompiler),
                    template,
                    providersRequiringFactory,
                    viewProvidersRequiringFactory,
                },
            };
            if (changeDetection !== null) {
                output.analysis.meta.changeDetection = changeDetection;
            }
            return output;
        }
        register(node, analysis) {
            // Register this component's information with the `MetadataRegistry`. This ensures that
            // the information about the component is available during the compile() phase.
            const ref = new Reference$1(node);
            this.metaRegistry.registerDirectiveMetadata(Object.assign({ ref, name: node.name.text, selector: analysis.meta.selector, exportAs: analysis.meta.exportAs, inputs: analysis.meta.inputs, outputs: analysis.meta.outputs, queries: analysis.meta.queries.map(query => query.propertyName), isComponent: true, baseClass: analysis.baseClass }, analysis.guards));
            this.injectableRegistry.registerInjectable(node);
        }
        index(context, node, analysis) {
            const scope = this.scopeReader.getScopeForComponent(node);
            const selector = analysis.meta.selector;
            const matcher = new SelectorMatcher();
            if (scope === 'error') {
                // Don't bother indexing components which had erroneous scopes.
                return null;
            }
            if (scope !== null) {
                for (const directive of scope.compilation.directives) {
                    if (directive.selector !== null) {
                        matcher.addSelectables(CssSelector.parse(directive.selector), directive);
                    }
                }
            }
            const binder = new R3TargetBinder(matcher);
            const boundTemplate = binder.bind({ template: analysis.template.diagNodes });
            context.addComponent({
                declaration: node,
                selector,
                boundTemplate,
                templateMeta: {
                    isInline: analysis.template.isInline,
                    file: analysis.template.file,
                },
            });
        }
        typeCheck(ctx, node, meta) {
            if (!ts.isClassDeclaration(node)) {
                return;
            }
            const matcher = new SelectorMatcher();
            const pipes = new Map();
            let schemas = [];
            const scope = this.scopeReader.getScopeForComponent(node);
            if (scope === 'error') {
                // Don't type-check components that had errors in their scopes.
                return;
            }
            if (scope !== null) {
                for (const meta of scope.compilation.directives) {
                    if (meta.selector !== null) {
                        const extMeta = flattenInheritedDirectiveMetadata(this.metaReader, meta.ref);
                        matcher.addSelectables(CssSelector.parse(meta.selector), extMeta);
                    }
                }
                for (const { name, ref } of scope.compilation.pipes) {
                    if (!ts.isClassDeclaration(ref.node)) {
                        throw new Error(`Unexpected non-class declaration ${ts.SyntaxKind[ref.node.kind]} for pipe ${ref.debugName}`);
                    }
                    pipes.set(name, ref);
                }
                schemas = scope.schemas;
            }
            const binder = new R3TargetBinder(matcher);
            ctx.addTemplate(new Reference$1(node), binder, meta.template.diagNodes, pipes, schemas, meta.template.sourceMapping, meta.template.file);
        }
        resolve(node, analysis) {
            const context = node.getSourceFile();
            // Check whether this component was registered with an NgModule. If so, it should be compiled
            // under that module's compilation scope.
            const scope = this.scopeReader.getScopeForComponent(node);
            let metadata = analysis.meta;
            const data = {
                directives: EMPTY_ARRAY,
                pipes: EMPTY_MAP,
                wrapDirectivesAndPipesInClosure: false,
            };
            if (scope !== null && scope !== 'error') {
                // Replace the empty components and directives from the analyze() step with a fully expanded
                // scope. This is possible now because during resolve() the whole compilation unit has been
                // fully analyzed.
                //
                // First it needs to be determined if actually importing the directives/pipes used in the
                // template would create a cycle. Currently ngtsc refuses to generate cycles, so an option
                // known as "remote scoping" is used if a cycle would be created. In remote scoping, the
                // module file sets the directives/pipes on the cmp of the component, without
                // requiring new imports (but also in a way that breaks tree shaking).
                //
                // Determining this is challenging, because the TemplateDefinitionBuilder is responsible for
                // matching directives and pipes in the template; however, that doesn't run until the actual
                // compile() step. It's not possible to run template compilation sooner as it requires the
                // ConstantPool for the overall file being compiled (which isn't available until the transform
                // step).
                //
                // Instead, directives/pipes are matched independently here, using the R3TargetBinder. This is
                // an alternative implementation of template matching which is used for template type-checking
                // and will eventually replace matching in the TemplateDefinitionBuilder.
                // Set up the R3TargetBinder, as well as a 'directives' array and a 'pipes' map that are later
                // fed to the TemplateDefinitionBuilder. First, a SelectorMatcher is constructed to match
                // directives that are in scope.
                const matcher = new SelectorMatcher();
                const directives = [];
                for (const dir of scope.compilation.directives) {
                    const { ref, selector } = dir;
                    if (selector !== null) {
                        const expression = this.refEmitter.emit(ref, context);
                        directives.push({ selector, expression });
                        matcher.addSelectables(CssSelector.parse(selector), Object.assign(Object.assign({}, dir), { expression }));
                    }
                }
                const pipes = new Map();
                for (const pipe of scope.compilation.pipes) {
                    pipes.set(pipe.name, this.refEmitter.emit(pipe.ref, context));
                }
                // Next, the component template AST is bound using the R3TargetBinder. This produces an
                // BoundTarget, which is similar to a ts.TypeChecker.
                const binder = new R3TargetBinder(matcher);
                const bound = binder.bind({ template: metadata.template.nodes });
                // The BoundTarget knows which directives and pipes matched the template.
                const usedDirectives = bound.getUsedDirectives();
                const usedPipes = bound.getUsedPipes().map(name => pipes.get(name));
                // Scan through the directives/pipes actually used in the template and check whether any
                // import which needs to be generated would create a cycle.
                const cycleDetected = usedDirectives.some(dir => this._isCyclicImport(dir.expression, context)) ||
                    usedPipes.some(pipe => this._isCyclicImport(pipe, context));
                if (!cycleDetected) {
                    // No cycle was detected. Record the imports that need to be created in the cycle detector
                    // so that future cyclic import checks consider their production.
                    for (const { expression } of usedDirectives) {
                        this._recordSyntheticImport(expression, context);
                    }
                    for (const pipe of usedPipes) {
                        this._recordSyntheticImport(pipe, context);
                    }
                    // Check whether the directive/pipe arrays in cmp need to be wrapped in closures.
                    // This is required if any directive/pipe reference is to a declaration in the same file but
                    // declared after this component.
                    const wrapDirectivesAndPipesInClosure = usedDirectives.some(dir => isExpressionForwardReference(dir.expression, node.name, context)) ||
                        usedPipes.some(pipe => isExpressionForwardReference(pipe, node.name, context));
                    // Actual compilation still uses the full scope, not the narrowed scope determined by
                    // R3TargetBinder. This is a hedge against potential issues with the R3TargetBinder - right
                    // now the TemplateDefinitionBuilder is the "source of truth" for which directives/pipes are
                    // actually used (though the two should agree perfectly).
                    //
                    // TODO(alxhub): switch TemplateDefinitionBuilder over to using R3TargetBinder directly.
                    data.directives = directives;
                    data.pipes = pipes;
                    data.wrapDirectivesAndPipesInClosure = wrapDirectivesAndPipesInClosure;
                }
                else {
                    // Declaring the directiveDefs/pipeDefs arrays directly would require imports that would
                    // create a cycle. Instead, mark this component as requiring remote scoping, so that the
                    // NgModule file will take care of setting the directives for the component.
                    this.scopeRegistry.setComponentAsRequiringRemoteScoping(node);
                }
            }
            const diagnostics = [];
            if (analysis.providersRequiringFactory !== null &&
                analysis.meta.providers instanceof WrappedNodeExpr) {
                const providerDiagnostics = getProviderDiagnostics(analysis.providersRequiringFactory, analysis.meta.providers.node, this.injectableRegistry);
                diagnostics.push(...providerDiagnostics);
            }
            if (analysis.viewProvidersRequiringFactory !== null &&
                analysis.meta.viewProviders instanceof WrappedNodeExpr) {
                const viewProviderDiagnostics = getProviderDiagnostics(analysis.viewProvidersRequiringFactory, analysis.meta.viewProviders.node, this.injectableRegistry);
                diagnostics.push(...viewProviderDiagnostics);
            }
            const directiveDiagnostics = getDirectiveDiagnostics(node, this.metaReader, this.evaluator, this.reflector, this.scopeRegistry, 'Component');
            if (directiveDiagnostics !== null) {
                diagnostics.push(...directiveDiagnostics);
            }
            if (diagnostics.length > 0) {
                return { diagnostics };
            }
            return { data };
        }
        compile(node, analysis, resolution, pool) {
            const meta = Object.assign(Object.assign({}, analysis.meta), resolution);
            const res = compileComponentFromMetadata(meta, pool, makeBindingParser());
            const factoryRes = compileNgFactoryDefField(Object.assign(Object.assign({}, meta), { injectFn: Identifiers.directiveInject, target: R3FactoryTarget.Component }));
            if (analysis.metadataStmt !== null) {
                factoryRes.statements.push(analysis.metadataStmt);
            }
            return [
                factoryRes, {
                    name: 'cmp',
                    initializer: res.expression,
                    statements: [],
                    type: res.type,
                }
            ];
        }
        _resolveLiteral(decorator) {
            if (this.literalCache.has(decorator)) {
                return this.literalCache.get(decorator);
            }
            if (decorator.args === null || decorator.args.length !== 1) {
                throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(decorator), `Incorrect number of arguments to @Component decorator`);
            }
            const meta = unwrapExpression(decorator.args[0]);
            if (!ts.isObjectLiteralExpression(meta)) {
                throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, `Decorator argument must be literal.`);
            }
            this.literalCache.set(decorator, meta);
            return meta;
        }
        _resolveEnumValue(component, field, enumSymbolName) {
            let resolved = null;
            if (component.has(field)) {
                const expr = component.get(field);
                const value = this.evaluator.evaluate(expr);
                if (value instanceof EnumValue && isAngularCoreReference(value.enumRef, enumSymbolName)) {
                    resolved = value.resolved;
                }
                else {
                    throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, expr, `${field} must be a member of ${enumSymbolName} enum from @angular/core`);
                }
            }
            return resolved;
        }
        _extractStyleUrls(component, extraUrls) {
            if (!component.has('styleUrls')) {
                return extraUrls.length > 0 ? extraUrls : null;
            }
            const styleUrlsExpr = component.get('styleUrls');
            const styleUrls = this.evaluator.evaluate(styleUrlsExpr);
            if (!Array.isArray(styleUrls) || !styleUrls.every(url => typeof url === 'string')) {
                throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, styleUrlsExpr, 'styleUrls must be an array of strings');
            }
            styleUrls.push(...extraUrls);
            return styleUrls;
        }
        _preloadAndParseTemplate(node, decorator, component, containingFile) {
            if (component.has('templateUrl')) {
                // Extract the templateUrl and preload it.
                const templateUrlExpr = component.get('templateUrl');
                const templateUrl = this.evaluator.evaluate(templateUrlExpr);
                if (typeof templateUrl !== 'string') {
                    throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, templateUrlExpr, 'templateUrl must be a string');
                }
                const resourceUrl = this.resourceLoader.resolve(templateUrl, containingFile);
                const templatePromise = this.resourceLoader.preload(resourceUrl);
                // If the preload worked, then actually load and parse the template, and wait for any style
                // URLs to resolve.
                if (templatePromise !== undefined) {
                    return templatePromise.then(() => {
                        const template = this._extractExternalTemplate(node, component, templateUrlExpr, resourceUrl);
                        this.preanalyzeTemplateCache.set(node, template);
                        return template;
                    });
                }
                else {
                    return Promise.resolve(null);
                }
            }
            else {
                const template = this._extractInlineTemplate(node, decorator, component, containingFile);
                this.preanalyzeTemplateCache.set(node, template);
                return Promise.resolve(template);
            }
        }
        _extractExternalTemplate(node, component, templateUrlExpr, resourceUrl) {
            const templateStr = this.resourceLoader.load(resourceUrl);
            if (this.depTracker !== null) {
                this.depTracker.addResourceDependency(node.getSourceFile(), absoluteFrom(resourceUrl));
            }
            const template = this._parseTemplate(component, templateStr, sourceMapUrl(resourceUrl), /* templateRange */ undefined, 
            /* escapedString */ false);
            return Object.assign(Object.assign({}, template), { sourceMapping: {
                    type: 'external',
                    componentClass: node,
                    node: templateUrlExpr,
                    template: templateStr,
                    templateUrl: resourceUrl,
                } });
        }
        _extractInlineTemplate(node, decorator, component, containingFile) {
            if (!component.has('template')) {
                throw new FatalDiagnosticError(ErrorCode.COMPONENT_MISSING_TEMPLATE, Decorator.nodeForError(decorator), 'component is missing a template');
            }
            const templateExpr = component.get('template');
            let templateStr;
            let templateUrl = '';
            let templateRange = undefined;
            let sourceMapping;
            let escapedString = false;
            // We only support SourceMaps for inline templates that are simple string literals.
            if (ts.isStringLiteral(templateExpr) || ts.isNoSubstitutionTemplateLiteral(templateExpr)) {
                // the start and end of the `templateExpr` node includes the quotation marks, which we
                // must
                // strip
                templateRange = getTemplateRange(templateExpr);
                templateStr = templateExpr.getSourceFile().text;
                templateUrl = containingFile;
                escapedString = true;
                sourceMapping = {
                    type: 'direct',
                    node: templateExpr,
                };
            }
            else {
                const resolvedTemplate = this.evaluator.evaluate(templateExpr);
                if (typeof resolvedTemplate !== 'string') {
                    throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, templateExpr, 'template must be a string');
                }
                templateStr = resolvedTemplate;
                sourceMapping = {
                    type: 'indirect',
                    node: templateExpr,
                    componentClass: node,
                    template: templateStr,
                };
            }
            const template = this._parseTemplate(component, templateStr, templateUrl, templateRange, escapedString);
            return Object.assign(Object.assign({}, template), { sourceMapping });
        }
        _parseTemplate(component, templateStr, templateUrl, templateRange, escapedString) {
            let preserveWhitespaces = this.defaultPreserveWhitespaces;
            if (component.has('preserveWhitespaces')) {
                const expr = component.get('preserveWhitespaces');
                const value = this.evaluator.evaluate(expr);
                if (typeof value !== 'boolean') {
                    throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, expr, 'preserveWhitespaces must be a boolean');
                }
                preserveWhitespaces = value;
            }
            let interpolation = DEFAULT_INTERPOLATION_CONFIG;
            if (component.has('interpolation')) {
                const expr = component.get('interpolation');
                const value = this.evaluator.evaluate(expr);
                if (!Array.isArray(value) || value.length !== 2 ||
                    !value.every(element => typeof element === 'string')) {
                    throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, expr, 'interpolation must be an array with 2 elements of string type');
                }
                interpolation = InterpolationConfig.fromArray(value);
            }
            const { errors, nodes: emitNodes, styleUrls, styles, ngContentSelectors } = parseTemplate(templateStr, templateUrl, {
                preserveWhitespaces,
                interpolationConfig: interpolation,
                range: templateRange,
                escapedString,
                enableI18nLegacyMessageIdFormat: this.enableI18nLegacyMessageIdFormat,
                i18nNormalizeLineEndingsInICUs: this.i18nNormalizeLineEndingsInICUs,
            });
            // Unfortunately, the primary parse of the template above may not contain accurate source map
            // information. If used directly, it would result in incorrect code locations in template
            // errors, etc. There are two main problems:
            //
            // 1. `preserveWhitespaces: false` annihilates the correctness of template source mapping, as
            //    the whitespace transformation changes the contents of HTML text nodes before they're
            //    parsed into Angular expressions.
            // 2. By default, the template parser strips leading trivia characters (like spaces, tabs, and
            //    newlines). This also destroys source mapping information.
            //
            // In order to guarantee the correctness of diagnostics, templates are parsed a second time with
            // the above options set to preserve source mappings.
            const { nodes: diagNodes } = parseTemplate(templateStr, templateUrl, {
                preserveWhitespaces: true,
                interpolationConfig: interpolation,
                range: templateRange,
                escapedString,
                enableI18nLegacyMessageIdFormat: this.enableI18nLegacyMessageIdFormat,
                i18nNormalizeLineEndingsInICUs: this.i18nNormalizeLineEndingsInICUs,
                leadingTriviaChars: [],
            });
            return {
                interpolation,
                emitNodes,
                diagNodes,
                styleUrls,
                styles,
                ngContentSelectors,
                errors,
                template: templateStr,
                templateUrl,
                isInline: component.has('template'),
                file: new ParseSourceFile(templateStr, templateUrl),
            };
        }
        _expressionToImportedFile(expr, origin) {
            if (!(expr instanceof ExternalExpr)) {
                return null;
            }
            // Figure out what file is being imported.
            return this.moduleResolver.resolveModule(expr.value.moduleName, origin.fileName);
        }
        _isCyclicImport(expr, origin) {
            const imported = this._expressionToImportedFile(expr, origin);
            if (imported === null) {
                return false;
            }
            // Check whether the import is legal.
            return this.cycleAnalyzer.wouldCreateCycle(origin, imported);
        }
        _recordSyntheticImport(expr, origin) {
            const imported = this._expressionToImportedFile(expr, origin);
            if (imported === null) {
                return;
            }
            this.cycleAnalyzer.recordSyntheticImport(origin, imported);
        }
    }
    function getTemplateRange(templateExpr) {
        const startPos = templateExpr.getStart() + 1;
        const { line, character } = ts.getLineAndCharacterOfPosition(templateExpr.getSourceFile(), startPos);
        return {
            startPos,
            startLine: line,
            startCol: character,
            endPos: templateExpr.getEnd() - 1,
        };
    }
    function sourceMapUrl(resourceUrl) {
        if (!tsSourceMapBug29300Fixed()) {
            // By removing the template URL we are telling the translator not to try to
            // map the external source file to the generated code, since the version
            // of TS that is running does not support it.
            return '';
        }
        else {
            return resourceUrl;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Adapts the `compileIvyInjectable` compiler for `@Injectable` decorators to the Ivy compiler.
     */
    class InjectableDecoratorHandler {
        constructor(reflector, defaultImportRecorder, isCore, strictCtorDeps, injectableRegistry, 
        /**
         * What to do if the injectable already contains a prov property.
         *
         * If true then an error diagnostic is reported.
         * If false then there is no error and a new prov property is not added.
         */
        errorOnDuplicateProv = true) {
            this.reflector = reflector;
            this.defaultImportRecorder = defaultImportRecorder;
            this.isCore = isCore;
            this.strictCtorDeps = strictCtorDeps;
            this.injectableRegistry = injectableRegistry;
            this.errorOnDuplicateProv = errorOnDuplicateProv;
            this.precedence = HandlerPrecedence.SHARED;
            this.name = InjectableDecoratorHandler.name;
        }
        detect(node, decorators) {
            if (!decorators) {
                return undefined;
            }
            const decorator = findAngularDecorator(decorators, 'Injectable', this.isCore);
            if (decorator !== undefined) {
                return {
                    trigger: decorator.node,
                    decorator: decorator,
                    metadata: decorator,
                };
            }
            else {
                return undefined;
            }
        }
        analyze(node, decorator) {
            const meta = extractInjectableMetadata(node, decorator, this.reflector);
            const decorators = this.reflector.getDecoratorsOfDeclaration(node);
            return {
                analysis: {
                    meta,
                    ctorDeps: extractInjectableCtorDeps(node, meta, decorator, this.reflector, this.defaultImportRecorder, this.isCore, this.strictCtorDeps),
                    metadataStmt: generateSetClassMetadataCall(node, this.reflector, this.defaultImportRecorder, this.isCore),
                    // Avoid generating multiple factories if a class has
                    // more Angular decorators, apart from Injectable.
                    needsFactory: !decorators ||
                        decorators.every(current => !isAngularCore(current) || current.name === 'Injectable')
                },
            };
        }
        register(node) {
            this.injectableRegistry.registerInjectable(node);
        }
        compile(node, analysis) {
            const res = compileInjectable(analysis.meta);
            const statements = res.statements;
            const results = [];
            if (analysis.needsFactory) {
                const meta = analysis.meta;
                const factoryRes = compileNgFactoryDefField({
                    name: meta.name,
                    type: meta.type,
                    internalType: meta.internalType,
                    typeArgumentCount: meta.typeArgumentCount,
                    deps: analysis.ctorDeps,
                    injectFn: Identifiers.inject,
                    target: R3FactoryTarget.Injectable,
                });
                if (analysis.metadataStmt !== null) {
                    factoryRes.statements.push(analysis.metadataStmt);
                }
                results.push(factoryRes);
            }
            const prov = this.reflector.getMembersOfClass(node).find(member => member.name === 'prov');
            if (prov !== undefined && this.errorOnDuplicateProv) {
                throw new FatalDiagnosticError(ErrorCode.INJECTABLE_DUPLICATE_PROV, prov.nameNode || prov.node || node, 'Injectables cannot contain a static prov property, because the compiler is going to generate one.');
            }
            if (prov === undefined) {
                // Only add a new prov if there is not one already
                results.push({ name: 'prov', initializer: res.expression, statements, type: res.type });
            }
            return results;
        }
    }
    /**
     * Read metadata from the `@Injectable` decorator and produce the `IvyInjectableMetadata`, the
     * input metadata needed to run `compileIvyInjectable`.
     *
     * A `null` return value indicates this is @Injectable has invalid data.
     */
    function extractInjectableMetadata(clazz, decorator, reflector) {
        const name = clazz.name.text;
        const type = wrapTypeReference(reflector, clazz);
        const internalType = new WrappedNodeExpr(reflector.getInternalNameOfClass(clazz));
        const typeArgumentCount = reflector.getGenericArityOfClass(clazz) || 0;
        if (decorator.args === null) {
            throw new FatalDiagnosticError(ErrorCode.DECORATOR_NOT_CALLED, Decorator.nodeForError(decorator), '@Injectable must be called');
        }
        if (decorator.args.length === 0) {
            return {
                name,
                type,
                typeArgumentCount,
                internalType,
                providedIn: new LiteralExpr(null),
            };
        }
        else if (decorator.args.length === 1) {
            const metaNode = decorator.args[0];
            // Firstly make sure the decorator argument is an inline literal - if not, it's illegal to
            // transport references from one location to another. This is the problem that lowering
            // used to solve - if this restriction proves too undesirable we can re-implement lowering.
            if (!ts.isObjectLiteralExpression(metaNode)) {
                throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, metaNode, `@Injectable argument must be an object literal`);
            }
            // Resolve the fields of the literal into a map of field name to expression.
            const meta = reflectObjectLiteral(metaNode);
            let providedIn = new LiteralExpr(null);
            if (meta.has('providedIn')) {
                providedIn = new WrappedNodeExpr(meta.get('providedIn'));
            }
            let userDeps = undefined;
            if ((meta.has('useClass') || meta.has('useFactory')) && meta.has('deps')) {
                const depsExpr = meta.get('deps');
                if (!ts.isArrayLiteralExpression(depsExpr)) {
                    throw new FatalDiagnosticError(ErrorCode.VALUE_NOT_LITERAL, depsExpr, `@Injectable deps metadata must be an inline array`);
                }
                userDeps = depsExpr.elements.map(dep => getDep(dep, reflector));
            }
            if (meta.has('useValue')) {
                return {
                    name,
                    type,
                    typeArgumentCount,
                    internalType,
                    providedIn,
                    useValue: new WrappedNodeExpr(unwrapForwardRef(meta.get('useValue'), reflector)),
                };
            }
            else if (meta.has('useExisting')) {
                return {
                    name,
                    type,
                    typeArgumentCount,
                    internalType,
                    providedIn,
                    useExisting: new WrappedNodeExpr(unwrapForwardRef(meta.get('useExisting'), reflector)),
                };
            }
            else if (meta.has('useClass')) {
                return {
                    name,
                    type,
                    typeArgumentCount,
                    internalType,
                    providedIn,
                    useClass: new WrappedNodeExpr(unwrapForwardRef(meta.get('useClass'), reflector)),
                    userDeps,
                };
            }
            else if (meta.has('useFactory')) {
                // useFactory is special - the 'deps' property must be analyzed.
                const factory = new WrappedNodeExpr(meta.get('useFactory'));
                return {
                    name,
                    type,
                    typeArgumentCount,
                    internalType,
                    providedIn,
                    useFactory: factory,
                    userDeps,
                };
            }
            else {
                return { name, type, typeArgumentCount, internalType, providedIn };
            }
        }
        else {
            throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, decorator.args[2], 'Too many arguments to @Injectable');
        }
    }
    function extractInjectableCtorDeps(clazz, meta, decorator, reflector, defaultImportRecorder, isCore, strictCtorDeps) {
        if (decorator.args === null) {
            throw new FatalDiagnosticError(ErrorCode.DECORATOR_NOT_CALLED, Decorator.nodeForError(decorator), '@Injectable must be called');
        }
        let ctorDeps = null;
        if (decorator.args.length === 0) {
            // Ideally, using @Injectable() would have the same effect as using @Injectable({...}), and be
            // subject to the same validation. However, existing Angular code abuses @Injectable, applying
            // it to things like abstract classes with constructors that were never meant for use with
            // Angular's DI.
            //
            // To deal with this, @Injectable() without an argument is more lenient, and if the
            // constructor signature does not work for DI then a factory definition (fac) that throws is
            // generated.
            if (strictCtorDeps) {
                ctorDeps = getValidConstructorDependencies(clazz, reflector, defaultImportRecorder, isCore);
            }
            else {
                ctorDeps = unwrapConstructorDependencies(getConstructorDependencies(clazz, reflector, defaultImportRecorder, isCore));
            }
            return ctorDeps;
        }
        else if (decorator.args.length === 1) {
            const rawCtorDeps = getConstructorDependencies(clazz, reflector, defaultImportRecorder, isCore);
            if (strictCtorDeps && meta.useValue === undefined && meta.useExisting === undefined &&
                meta.useClass === undefined && meta.useFactory === undefined) {
                // Since use* was not provided, validate the deps according to strictCtorDeps.
                ctorDeps = validateConstructorDependencies(clazz, rawCtorDeps);
            }
            else {
                ctorDeps = unwrapConstructorDependencies(rawCtorDeps);
            }
        }
        return ctorDeps;
    }
    function getDep(dep, reflector) {
        const meta = {
            token: new WrappedNodeExpr(dep),
            attribute: null,
            host: false,
            resolved: R3ResolvedDependencyType.Token,
            optional: false,
            self: false,
            skipSelf: false,
        };
        function maybeUpdateDecorator(dec, reflector, token) {
            const source = reflector.getImportOfIdentifier(dec);
            if (source === null || source.from !== '@angular/core') {
                return;
            }
            switch (source.name) {
                case 'Inject':
                    if (token !== undefined) {
                        meta.token = new WrappedNodeExpr(token);
                    }
                    break;
                case 'Optional':
                    meta.optional = true;
                    break;
                case 'SkipSelf':
                    meta.skipSelf = true;
                    break;
                case 'Self':
                    meta.self = true;
                    break;
            }
        }
        if (ts.isArrayLiteralExpression(dep)) {
            dep.elements.forEach(el => {
                if (ts.isIdentifier(el)) {
                    maybeUpdateDecorator(el, reflector);
                }
                else if (ts.isNewExpression(el) && ts.isIdentifier(el.expression)) {
                    const token = el.arguments && el.arguments.length > 0 && el.arguments[0] || undefined;
                    maybeUpdateDecorator(el.expression, reflector, token);
                }
            });
        }
        return meta;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Compiles @NgModule annotations to ngModuleDef fields.
     *
     * TODO(alxhub): handle injector side of things as well.
     */
    class NgModuleDecoratorHandler {
        constructor(reflector, evaluator, metaReader, metaRegistry, scopeRegistry, referencesRegistry, isCore, routeAnalyzer, refEmitter, factoryTracker, defaultImportRecorder, annotateForClosureCompiler, injectableRegistry, localeId) {
            this.reflector = reflector;
            this.evaluator = evaluator;
            this.metaReader = metaReader;
            this.metaRegistry = metaRegistry;
            this.scopeRegistry = scopeRegistry;
            this.referencesRegistry = referencesRegistry;
            this.isCore = isCore;
            this.routeAnalyzer = routeAnalyzer;
            this.refEmitter = refEmitter;
            this.factoryTracker = factoryTracker;
            this.defaultImportRecorder = defaultImportRecorder;
            this.annotateForClosureCompiler = annotateForClosureCompiler;
            this.injectableRegistry = injectableRegistry;
            this.localeId = localeId;
            this.precedence = HandlerPrecedence.PRIMARY;
            this.name = NgModuleDecoratorHandler.name;
        }
        detect(node, decorators) {
            if (!decorators) {
                return undefined;
            }
            const decorator = findAngularDecorator(decorators, 'NgModule', this.isCore);
            if (decorator !== undefined) {
                return {
                    trigger: decorator.node,
                    decorator: decorator,
                    metadata: decorator,
                };
            }
            else {
                return undefined;
            }
        }
        analyze(node, decorator) {
            const name = node.name.text;
            if (decorator.args === null || decorator.args.length > 1) {
                throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(decorator), `Incorrect number of arguments to @NgModule decorator`);
            }
            // @NgModule can be invoked without arguments. In case it is, pretend as if a blank object
            // literal was specified. This simplifies the code below.
            const meta = decorator.args.length === 1 ? unwrapExpression(decorator.args[0]) :
                ts.createObjectLiteral([]);
            if (!ts.isObjectLiteralExpression(meta)) {
                throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, '@NgModule argument must be an object literal');
            }
            const ngModule = reflectObjectLiteral(meta);
            if (ngModule.has('jit')) {
                // The only allowed value is true, so there's no need to expand further.
                return {};
            }
            const moduleResolvers = combineResolvers([
                ref => this._extractModuleFromModuleWithProvidersFn(ref.node),
                forwardRefResolver,
            ]);
            const diagnostics = [];
            // Extract the module declarations, imports, and exports.
            let declarationRefs = [];
            let rawDeclarations = null;
            if (ngModule.has('declarations')) {
                rawDeclarations = ngModule.get('declarations');
                const declarationMeta = this.evaluator.evaluate(rawDeclarations, forwardRefResolver);
                declarationRefs =
                    this.resolveTypeList(rawDeclarations, declarationMeta, name, 'declarations');
                // Look through the declarations to make sure they're all a part of the current compilation.
                for (const ref of declarationRefs) {
                    if (ref.node.getSourceFile().isDeclarationFile) {
                        const errorNode = ref.getOriginForDiagnostics(rawDeclarations);
                        diagnostics.push(makeDiagnostic(ErrorCode.NGMODULE_INVALID_DECLARATION, errorNode, `Cannot declare '${ref.node.name
                        .text}' in an NgModule as it's not a part of the current compilation.`, [makeRelatedInformation(ref.node.name, `'${ref.node.name.text}' is declared here.`)]));
                    }
                }
            }
            if (diagnostics.length > 0) {
                return { diagnostics };
            }
            let importRefs = [];
            let rawImports = null;
            if (ngModule.has('imports')) {
                rawImports = ngModule.get('imports');
                const importsMeta = this.evaluator.evaluate(rawImports, moduleResolvers);
                importRefs = this.resolveTypeList(rawImports, importsMeta, name, 'imports');
            }
            let exportRefs = [];
            let rawExports = null;
            if (ngModule.has('exports')) {
                rawExports = ngModule.get('exports');
                const exportsMeta = this.evaluator.evaluate(rawExports, moduleResolvers);
                exportRefs = this.resolveTypeList(rawExports, exportsMeta, name, 'exports');
                this.referencesRegistry.add(node, ...exportRefs);
            }
            let bootstrapRefs = [];
            if (ngModule.has('bootstrap')) {
                const expr = ngModule.get('bootstrap');
                const bootstrapMeta = this.evaluator.evaluate(expr, forwardRefResolver);
                bootstrapRefs = this.resolveTypeList(expr, bootstrapMeta, name, 'bootstrap');
            }
            const schemas = [];
            if (ngModule.has('schemas')) {
                const rawExpr = ngModule.get('schemas');
                const result = this.evaluator.evaluate(rawExpr);
                if (!Array.isArray(result)) {
                    throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, rawExpr, `NgModule.schemas must be an array`);
                }
                for (const schemaRef of result) {
                    if (!(schemaRef instanceof Reference$1)) {
                        throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, rawExpr, 'NgModule.schemas must be an array of schemas');
                    }
                    const id = schemaRef.getIdentityIn(schemaRef.node.getSourceFile());
                    if (id === null || schemaRef.ownedByModuleGuess !== '@angular/core') {
                        throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, rawExpr, 'NgModule.schemas must be an array of schemas');
                    }
                    // Since `id` is the `ts.Identifer` within the schema ref's declaration file, it's safe to
                    // use `id.text` here to figure out which schema is in use. Even if the actual reference was
                    // renamed when the user imported it, these names will match.
                    switch (id.text) {
                        case 'CUSTOM_ELEMENTS_SCHEMA':
                            schemas.push(CUSTOM_ELEMENTS_SCHEMA);
                            break;
                        case 'NO_ERRORS_SCHEMA':
                            schemas.push(NO_ERRORS_SCHEMA);
                            break;
                        default:
                            throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, rawExpr, `'${schemaRef.debugName}' is not a valid NgModule schema`);
                    }
                }
            }
            const id = ngModule.has('id') ? new WrappedNodeExpr(ngModule.get('id')) : null;
            const valueContext = node.getSourceFile();
            let typeContext = valueContext;
            const typeNode = this.reflector.getDtsDeclaration(node);
            if (typeNode !== null) {
                typeContext = typeNode.getSourceFile();
            }
            const bootstrap = bootstrapRefs.map(bootstrap => this._toR3Reference(bootstrap, valueContext, typeContext));
            const declarations = declarationRefs.map(decl => this._toR3Reference(decl, valueContext, typeContext));
            const imports = importRefs.map(imp => this._toR3Reference(imp, valueContext, typeContext));
            const exports = exportRefs.map(exp => this._toR3Reference(exp, valueContext, typeContext));
            const isForwardReference = (ref) => isExpressionForwardReference(ref.value, node.name, valueContext);
            const containsForwardDecls = bootstrap.some(isForwardReference) ||
                declarations.some(isForwardReference) || imports.some(isForwardReference) ||
                exports.some(isForwardReference);
            const type = wrapTypeReference(this.reflector, node);
            const internalType = new WrappedNodeExpr(this.reflector.getInternalNameOfClass(node));
            const adjacentType = new WrappedNodeExpr(this.reflector.getAdjacentNameOfClass(node));
            const ngModuleDef = {
                type,
                internalType,
                adjacentType,
                bootstrap,
                declarations,
                exports,
                imports,
                containsForwardDecls,
                id,
                emitInline: false,
                // TODO: to be implemented as a part of FW-1004.
                schemas: [],
            };
            const rawProviders = ngModule.has('providers') ? ngModule.get('providers') : null;
            const wrapperProviders = rawProviders !== null ?
                new WrappedNodeExpr(this.annotateForClosureCompiler ? wrapFunctionExpressionsInParens(rawProviders) :
                    rawProviders) :
                null;
            // At this point, only add the module's imports as the injectors' imports. Any exported modules
            // are added during `resolve`, as we need scope information to be able to filter out directives
            // and pipes from the module exports.
            const injectorImports = [];
            if (ngModule.has('imports')) {
                injectorImports.push(new WrappedNodeExpr(ngModule.get('imports')));
            }
            if (this.routeAnalyzer !== null) {
                this.routeAnalyzer.add(node.getSourceFile(), name, rawImports, rawExports, rawProviders);
            }
            const ngInjectorDef = {
                name,
                type,
                internalType,
                deps: getValidConstructorDependencies(node, this.reflector, this.defaultImportRecorder, this.isCore),
                providers: wrapperProviders,
                imports: injectorImports,
            };
            return {
                analysis: {
                    id,
                    schemas: schemas,
                    mod: ngModuleDef,
                    inj: ngInjectorDef,
                    declarations: declarationRefs,
                    rawDeclarations,
                    imports: importRefs,
                    exports: exportRefs,
                    providers: rawProviders,
                    providersRequiringFactory: rawProviders ?
                        resolveProvidersRequiringFactory(rawProviders, this.reflector, this.evaluator) :
                        null,
                    metadataStmt: generateSetClassMetadataCall(node, this.reflector, this.defaultImportRecorder, this.isCore, this.annotateForClosureCompiler),
                    factorySymbolName: node.name.text,
                },
            };
        }
        register(node, analysis) {
            // Register this module's information with the LocalModuleScopeRegistry. This ensures that
            // during the compile() phase, the module's metadata is available for selector scope
            // computation.
            this.metaRegistry.registerNgModuleMetadata({
                ref: new Reference$1(node),
                schemas: analysis.schemas,
                declarations: analysis.declarations,
                imports: analysis.imports,
                exports: analysis.exports,
                rawDeclarations: analysis.rawDeclarations,
            });
            if (this.factoryTracker !== null) {
                this.factoryTracker.track(node.getSourceFile(), {
                    name: analysis.factorySymbolName,
                    hasId: analysis.id !== null,
                });
            }
            this.injectableRegistry.registerInjectable(node);
        }
        resolve(node, analysis) {
            const scope = this.scopeRegistry.getScopeOfModule(node);
            const diagnostics = [];
            const scopeDiagnostics = this.scopeRegistry.getDiagnosticsOfModule(node);
            if (scopeDiagnostics !== null) {
                diagnostics.push(...scopeDiagnostics);
            }
            if (analysis.providersRequiringFactory !== null) {
                const providerDiagnostics = getProviderDiagnostics(analysis.providersRequiringFactory, analysis.providers, this.injectableRegistry);
                diagnostics.push(...providerDiagnostics);
            }
            const data = {
                injectorImports: [],
            };
            if (scope !== null && scope !== 'error') {
                // Using the scope information, extend the injector's imports using the modules that are
                // specified as module exports.
                const context = getSourceFile(node);
                for (const exportRef of analysis.exports) {
                    if (isNgModule(exportRef.node, scope.compilation)) {
                        data.injectorImports.push(this.refEmitter.emit(exportRef, context));
                    }
                }
                for (const decl of analysis.declarations) {
                    const metadata = this.metaReader.getDirectiveMetadata(decl);
                    if (metadata !== null && metadata.selector === null) {
                        throw new FatalDiagnosticError(ErrorCode.DIRECTIVE_MISSING_SELECTOR, decl.node, `Directive ${decl.node.name.text} has no selector, please add it!`);
                    }
                }
            }
            if (diagnostics.length > 0) {
                return { diagnostics };
            }
            if (scope === null || scope === 'error' || scope.reexports === null) {
                return { data };
            }
            else {
                return {
                    data,
                    reexports: scope.reexports,
                };
            }
        }
        compile(node, analysis, resolution) {
            //  Merge the injector imports (which are 'exports' that were later found to be NgModules)
            //  computed during resolution with the ones from analysis.
            const ngInjectorDef = compileInjector(Object.assign(Object.assign({}, analysis.inj), { imports: [...analysis.inj.imports, ...resolution.injectorImports] }));
            const ngModuleDef = compileNgModule(analysis.mod);
            const ngModuleStatements = ngModuleDef.additionalStatements;
            if (analysis.metadataStmt !== null) {
                ngModuleStatements.push(analysis.metadataStmt);
            }
            const context = getSourceFile(node);
            for (const decl of analysis.declarations) {
                if (this.scopeRegistry.getRequiresRemoteScope(decl.node)) {
                    const scope = this.scopeRegistry.getScopeOfModule(ts.getOriginalNode(node));
                    if (scope === null || scope === 'error') {
                        continue;
                    }
                    const directives = scope.compilation.directives.map(directive => this.refEmitter.emit(directive.ref, context));
                    const pipes = scope.compilation.pipes.map(pipe => this.refEmitter.emit(pipe.ref, context));
                    const directiveArray = new LiteralArrayExpr(directives);
                    const pipesArray = new LiteralArrayExpr(pipes);
                    const declExpr = this.refEmitter.emit(decl, context);
                    const setComponentScope = new ExternalExpr(Identifiers$1.setComponentScope);
                    const callExpr = new InvokeFunctionExpr(setComponentScope, [declExpr, directiveArray, pipesArray]);
                    ngModuleStatements.push(callExpr.toStmt());
                }
            }
            const res = [
                {
                    name: 'mod',
                    initializer: ngModuleDef.expression,
                    statements: ngModuleStatements,
                    type: ngModuleDef.type,
                },
                {
                    name: 'inj',
                    initializer: ngInjectorDef.expression,
                    statements: ngInjectorDef.statements,
                    type: ngInjectorDef.type,
                }
            ];
            if (this.localeId) {
                res.push({
                    name: 'loc',
                    initializer: new LiteralExpr(this.localeId),
                    statements: [],
                    type: STRING_TYPE
                });
            }
            return res;
        }
        _toR3Reference(valueRef, valueContext, typeContext) {
            if (valueRef.hasOwningModuleGuess) {
                return toR3Reference(valueRef, valueRef, valueContext, valueContext, this.refEmitter);
            }
            else {
                let typeRef = valueRef;
                let typeNode = this.reflector.getDtsDeclaration(typeRef.node);
                if (typeNode !== null && ts.isClassDeclaration(typeNode)) {
                    typeRef = new Reference$1(typeNode);
                }
                return toR3Reference(valueRef, typeRef, valueContext, typeContext, this.refEmitter);
            }
        }
        /**
         * Given a `FunctionDeclaration`, `MethodDeclaration` or `FunctionExpression`, check if it is
         * typed as a `ModuleWithProviders` and return an expression referencing the module if available.
         */
        _extractModuleFromModuleWithProvidersFn(node) {
            const type = node.type || null;
            return type &&
                (this._reflectModuleFromTypeParam(type, node) || this._reflectModuleFromLiteralType(type));
        }
        /**
         * Retrieve an `NgModule` identifier (T) from the specified `type`, if it is of the form:
         * `ModuleWithProviders<T>`
         * @param type The type to reflect on.
         * @returns the identifier of the NgModule type if found, or null otherwise.
         */
        _reflectModuleFromTypeParam(type, node) {
            // Examine the type of the function to see if it's a ModuleWithProviders reference.
            if (!ts.isTypeReferenceNode(type)) {
                return null;
            }
            const typeName = type &&
                (ts.isIdentifier(type.typeName) && type.typeName ||
                    ts.isQualifiedName(type.typeName) && type.typeName.right) ||
                null;
            if (typeName === null) {
                return null;
            }
            // Look at the type itself to see where it comes from.
            const id = this.reflector.getImportOfIdentifier(typeName);
            // If it's not named ModuleWithProviders, bail.
            if (id === null || id.name !== 'ModuleWithProviders') {
                return null;
            }
            // If it's not from @angular/core, bail.
            if (!this.isCore && id.from !== '@angular/core') {
                return null;
            }
            // If there's no type parameter specified, bail.
            if (type.typeArguments === undefined || type.typeArguments.length !== 1) {
                const parent = ts.isMethodDeclaration(node) && ts.isClassDeclaration(node.parent) ? node.parent : null;
                const symbolName = (parent && parent.name ? parent.name.getText() + '.' : '') +
                    (node.name ? node.name.getText() : 'anonymous');
                throw new FatalDiagnosticError(ErrorCode.NGMODULE_MODULE_WITH_PROVIDERS_MISSING_GENERIC, type, `${symbolName} returns a ModuleWithProviders type without a generic type argument. ` +
                    `Please add a generic type argument to the ModuleWithProviders type. If this ` +
                    `occurrence is in library code you don't control, please contact the library authors.`);
            }
            const arg = type.typeArguments[0];
            return typeNodeToValueExpr(arg);
        }
        /**
         * Retrieve an `NgModule` identifier (T) from the specified `type`, if it is of the form:
         * `A|B|{ngModule: T}|C`.
         * @param type The type to reflect on.
         * @returns the identifier of the NgModule type if found, or null otherwise.
         */
        _reflectModuleFromLiteralType(type) {
            if (!ts.isIntersectionTypeNode(type)) {
                return null;
            }
            for (const t of type.types) {
                if (ts.isTypeLiteralNode(t)) {
                    for (const m of t.members) {
                        const ngModuleType = ts.isPropertySignature(m) && ts.isIdentifier(m.name) &&
                            m.name.text === 'ngModule' && m.type ||
                            null;
                        const ngModuleExpression = ngModuleType && typeNodeToValueExpr(ngModuleType);
                        if (ngModuleExpression) {
                            return ngModuleExpression;
                        }
                    }
                }
            }
            return null;
        }
        // Verify that a `ts.Declaration` reference is a `ClassDeclaration` reference.
        isClassDeclarationReference(ref) {
            return this.reflector.isClass(ref.node);
        }
        /**
         * Compute a list of `Reference`s from a resolved metadata value.
         */
        resolveTypeList(expr, resolvedList, className, arrayName) {
            const refList = [];
            if (!Array.isArray(resolvedList)) {
                throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, expr, `Expected array when reading the NgModule.${arrayName} of ${className}`);
            }
            resolvedList.forEach((entry, idx) => {
                // Unwrap ModuleWithProviders for modules that are locally declared (and thus static
                // resolution was able to descend into the function and return an object literal, a Map).
                if (entry instanceof Map && entry.has('ngModule')) {
                    entry = entry.get('ngModule');
                }
                if (Array.isArray(entry)) {
                    // Recurse into nested arrays.
                    refList.push(...this.resolveTypeList(expr, entry, className, arrayName));
                }
                else if (isDeclarationReference(entry)) {
                    if (!this.isClassDeclarationReference(entry)) {
                        throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, entry.node, `Value at position ${idx} in the NgModule.${arrayName} of ${className} is not a class`);
                    }
                    refList.push(entry);
                }
                else {
                    // TODO(alxhub): Produce a better diagnostic here - the array index may be an inner array.
                    throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, expr, `Value at position ${idx} in the NgModule.${arrayName} of ${className} is not a reference: ${entry}`);
                }
            });
            return refList;
        }
    }
    function isNgModule(node, compilation) {
        return !compilation.directives.some(directive => directive.ref.node === node) &&
            !compilation.pipes.some(pipe => pipe.ref.node === node);
    }
    function isDeclarationReference(ref) {
        return ref instanceof Reference$1 &&
            (ts.isClassDeclaration(ref.node) || ts.isFunctionDeclaration(ref.node) ||
                ts.isVariableDeclaration(ref.node));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class PipeDecoratorHandler {
        constructor(reflector, evaluator, metaRegistry, scopeRegistry, defaultImportRecorder, injectableRegistry, isCore) {
            this.reflector = reflector;
            this.evaluator = evaluator;
            this.metaRegistry = metaRegistry;
            this.scopeRegistry = scopeRegistry;
            this.defaultImportRecorder = defaultImportRecorder;
            this.injectableRegistry = injectableRegistry;
            this.isCore = isCore;
            this.precedence = HandlerPrecedence.PRIMARY;
            this.name = PipeDecoratorHandler.name;
        }
        detect(node, decorators) {
            if (!decorators) {
                return undefined;
            }
            const decorator = findAngularDecorator(decorators, 'Pipe', this.isCore);
            if (decorator !== undefined) {
                return {
                    trigger: decorator.node,
                    decorator: decorator,
                    metadata: decorator,
                };
            }
            else {
                return undefined;
            }
        }
        analyze(clazz, decorator) {
            const name = clazz.name.text;
            const type = wrapTypeReference(this.reflector, clazz);
            const internalType = new WrappedNodeExpr(this.reflector.getInternalNameOfClass(clazz));
            if (decorator.args === null) {
                throw new FatalDiagnosticError(ErrorCode.DECORATOR_NOT_CALLED, Decorator.nodeForError(decorator), `@Pipe must be called`);
            }
            if (decorator.args.length !== 1) {
                throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(decorator), '@Pipe must have exactly one argument');
            }
            const meta = unwrapExpression(decorator.args[0]);
            if (!ts.isObjectLiteralExpression(meta)) {
                throw new FatalDiagnosticError(ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, '@Pipe must have a literal argument');
            }
            const pipe = reflectObjectLiteral(meta);
            if (!pipe.has('name')) {
                throw new FatalDiagnosticError(ErrorCode.PIPE_MISSING_NAME, meta, `@Pipe decorator is missing name field`);
            }
            const pipeNameExpr = pipe.get('name');
            const pipeName = this.evaluator.evaluate(pipeNameExpr);
            if (typeof pipeName !== 'string') {
                throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, pipeNameExpr, `@Pipe.name must be a string`);
            }
            let pure = true;
            if (pipe.has('pure')) {
                const expr = pipe.get('pure');
                const pureValue = this.evaluator.evaluate(expr);
                if (typeof pureValue !== 'boolean') {
                    throw new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, expr, `@Pipe.pure must be a boolean`);
                }
                pure = pureValue;
            }
            return {
                analysis: {
                    meta: {
                        name,
                        type,
                        internalType,
                        typeArgumentCount: this.reflector.getGenericArityOfClass(clazz) || 0,
                        pipeName,
                        deps: getValidConstructorDependencies(clazz, this.reflector, this.defaultImportRecorder, this.isCore),
                        pure,
                    },
                    metadataStmt: generateSetClassMetadataCall(clazz, this.reflector, this.defaultImportRecorder, this.isCore),
                },
            };
        }
        register(node, analysis) {
            const ref = new Reference$1(node);
            this.metaRegistry.registerPipeMetadata({ ref, name: analysis.meta.pipeName });
            this.injectableRegistry.registerInjectable(node);
        }
        resolve(node) {
            const duplicateDeclData = this.scopeRegistry.getDuplicateDeclarations(node);
            if (duplicateDeclData !== null) {
                // This pipe was declared twice (or more).
                return {
                    diagnostics: [makeDuplicateDeclarationError(node, duplicateDeclData, 'Pipe')],
                };
            }
            return {};
        }
        compile(node, analysis) {
            const meta = analysis.meta;
            const res = compilePipeFromMetadata(meta);
            const factoryRes = compileNgFactoryDefField(Object.assign(Object.assign({}, meta), { injectFn: Identifiers.directiveInject, target: R3FactoryTarget.Pipe }));
            if (analysis.metadataStmt !== null) {
                factoryRes.statements.push(analysis.metadataStmt);
            }
            return [
                factoryRes, {
                    name: 'pipe',
                    initializer: res.expression,
                    statements: [],
                    type: res.type,
                }
            ];
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * This registry does nothing, since ngtsc does not currently need
     * this functionality.
     * The ngcc tool implements a working version for its purposes.
     */
    class NoopReferencesRegistry {
        add(source, ...references) { }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Analyzes a `ts.Program` for cycles.
     */
    class CycleAnalyzer {
        constructor(importGraph) {
            this.importGraph = importGraph;
        }
        /**
         * Check whether adding an import from `from` to `to` would create a cycle in the `ts.Program`.
         */
        wouldCreateCycle(from, to) {
            // Import of 'from' -> 'to' is illegal if an edge 'to' -> 'from' already exists.
            return this.importGraph.transitiveImportsOf(to).has(from);
        }
        /**
         * Record a synthetic import from `from` to `to`.
         *
         * This is an import that doesn't exist in the `ts.Program` but will be considered as part of the
         * import graph for cycle creation.
         */
        recordSyntheticImport(from, to) {
            this.importGraph.addSyntheticImport(from, to);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A cached graph of imports in the `ts.Program`.
     *
     * The `ImportGraph` keeps track of dependencies (imports) of individual `ts.SourceFile`s. Only
     * dependencies within the same program are tracked; imports into packages on NPM are not.
     */
    class ImportGraph {
        constructor(resolver) {
            this.resolver = resolver;
            this.map = new Map();
        }
        /**
         * List the direct (not transitive) imports of a given `ts.SourceFile`.
         *
         * This operation is cached.
         */
        importsOf(sf) {
            if (!this.map.has(sf)) {
                this.map.set(sf, this.scanImports(sf));
            }
            return this.map.get(sf);
        }
        /**
         * Lists the transitive imports of a given `ts.SourceFile`.
         */
        transitiveImportsOf(sf) {
            const imports = new Set();
            this.transitiveImportsOfHelper(sf, imports);
            return imports;
        }
        transitiveImportsOfHelper(sf, results) {
            if (results.has(sf)) {
                return;
            }
            results.add(sf);
            this.importsOf(sf).forEach(imported => {
                this.transitiveImportsOfHelper(imported, results);
            });
        }
        /**
         * Add a record of an import from `sf` to `imported`, that's not present in the original
         * `ts.Program` but will be remembered by the `ImportGraph`.
         */
        addSyntheticImport(sf, imported) {
            if (isLocalFile(imported)) {
                this.importsOf(sf).add(imported);
            }
        }
        scanImports(sf) {
            const imports = new Set();
            // Look through the source file for import statements.
            sf.statements.forEach(stmt => {
                if ((ts.isImportDeclaration(stmt) || ts.isExportDeclaration(stmt)) &&
                    stmt.moduleSpecifier !== undefined && ts.isStringLiteral(stmt.moduleSpecifier)) {
                    // Resolve the module to a file, and check whether that file is in the ts.Program.
                    const moduleName = stmt.moduleSpecifier.text;
                    const moduleFile = this.resolver.resolveModule(moduleName, sf.fileName);
                    if (moduleFile !== null && isLocalFile(moduleFile)) {
                        // Record this local import.
                        imports.add(moduleFile);
                    }
                }
            });
            return imports;
        }
    }
    function isLocalFile(sf) {
        return !sf.fileName.endsWith('.d.ts');
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Produce `ts.Diagnostic`s for classes that are visible from exported types (e.g. directives
     * exposed by exported `NgModule`s) that are not themselves exported.
     *
     * This function reconciles two concepts:
     *
     * A class is Exported if it's exported from the main library `entryPoint` file.
     * A class is Visible if, via Angular semantics, a downstream consumer can import an Exported class
     * and be affected by the class in question. For example, an Exported NgModule may expose a
     * directive class to its consumers. Consumers that import the NgModule may have the directive
     * applied to elements in their templates. In this case, the directive is considered Visible.
     *
     * `checkForPrivateExports` attempts to verify that all Visible classes are Exported, and report
     * `ts.Diagnostic`s for those that aren't.
     *
     * @param entryPoint `ts.SourceFile` of the library's entrypoint, which should export the library's
     * public API.
     * @param checker `ts.TypeChecker` for the current program.
     * @param refGraph `ReferenceGraph` tracking the visibility of Angular types.
     * @returns an array of `ts.Diagnostic`s representing errors when visible classes are not exported
     * properly.
     */
    function checkForPrivateExports(entryPoint, checker, refGraph) {
        const diagnostics = [];
        // Firstly, compute the exports of the entry point. These are all the Exported classes.
        const topLevelExports = new Set();
        // Do this via `ts.TypeChecker.getExportsOfModule`.
        const moduleSymbol = checker.getSymbolAtLocation(entryPoint);
        if (moduleSymbol === undefined) {
            throw new Error(`Internal error: failed to get symbol for entrypoint`);
        }
        const exportedSymbols = checker.getExportsOfModule(moduleSymbol);
        // Loop through the exported symbols, de-alias if needed, and add them to `topLevelExports`.
        // TODO(alxhub): use proper iteration when build.sh is removed. (#27762)
        exportedSymbols.forEach(symbol => {
            if (symbol.flags & ts.SymbolFlags.Alias) {
                symbol = checker.getAliasedSymbol(symbol);
            }
            const decl = symbol.valueDeclaration;
            if (decl !== undefined) {
                topLevelExports.add(decl);
            }
        });
        // Next, go through each exported class and expand it to the set of classes it makes Visible,
        // using the `ReferenceGraph`. For each Visible class, verify that it's also Exported, and queue
        // an error if it isn't. `checkedSet` ensures only one error is queued per class.
        const checkedSet = new Set();
        // Loop through each Exported class.
        // TODO(alxhub): use proper iteration when the legacy build is removed. (#27762)
        topLevelExports.forEach(mainExport => {
            // Loop through each class made Visible by the Exported class.
            refGraph.transitiveReferencesOf(mainExport).forEach(transitiveReference => {
                // Skip classes which have already been checked.
                if (checkedSet.has(transitiveReference)) {
                    return;
                }
                checkedSet.add(transitiveReference);
                // Verify that the Visible class is also Exported.
                if (!topLevelExports.has(transitiveReference)) {
                    // This is an error, `mainExport` makes `transitiveReference` Visible, but
                    // `transitiveReference` is not Exported from the entrypoint. Construct a diagnostic to
                    // give to the user explaining the situation.
                    const descriptor = getDescriptorOfDeclaration(transitiveReference);
                    const name = getNameOfDeclaration(transitiveReference);
                    // Construct the path of visibility, from `mainExport` to `transitiveReference`.
                    let visibleVia = 'NgModule exports';
                    const transitivePath = refGraph.pathFrom(mainExport, transitiveReference);
                    if (transitivePath !== null) {
                        visibleVia = transitivePath.map(seg => getNameOfDeclaration(seg)).join(' -> ');
                    }
                    const diagnostic = Object.assign(Object.assign({ category: ts.DiagnosticCategory.Error, code: ngErrorCode(ErrorCode.SYMBOL_NOT_EXPORTED), file: transitiveReference.getSourceFile() }, getPosOfDeclaration(transitiveReference)), { messageText: `Unsupported private ${descriptor} ${name}. This ${descriptor} is visible to consumers via ${visibleVia}, but is not exported from the top-level library entrypoint.` });
                    diagnostics.push(diagnostic);
                }
            });
        });
        return diagnostics;
    }
    function getPosOfDeclaration(decl) {
        const node = getIdentifierOfDeclaration(decl) || decl;
        return {
            start: node.getStart(),
            length: node.getEnd() + 1 - node.getStart(),
        };
    }
    function getIdentifierOfDeclaration(decl) {
        if ((ts.isClassDeclaration(decl) || ts.isVariableDeclaration(decl) ||
            ts.isFunctionDeclaration(decl)) &&
            decl.name !== undefined && ts.isIdentifier(decl.name)) {
            return decl.name;
        }
        else {
            return null;
        }
    }
    function getNameOfDeclaration(decl) {
        const id = getIdentifierOfDeclaration(decl);
        return id !== null ? id.text : '(unnamed)';
    }
    function getDescriptorOfDeclaration(decl) {
        switch (decl.kind) {
            case ts.SyntaxKind.ClassDeclaration:
                return 'class';
            case ts.SyntaxKind.FunctionDeclaration:
                return 'function';
            case ts.SyntaxKind.VariableDeclaration:
                return 'variable';
            case ts.SyntaxKind.EnumDeclaration:
                return 'enum';
            default:
                return 'declaration';
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class ReferenceGraph {
        constructor() {
            this.references = new Map();
        }
        add(from, to) {
            if (!this.references.has(from)) {
                this.references.set(from, new Set());
            }
            this.references.get(from).add(to);
        }
        transitiveReferencesOf(target) {
            const set = new Set();
            this.collectTransitiveReferences(set, target);
            return set;
        }
        pathFrom(source, target) {
            return this.collectPathFrom(source, target, new Set());
        }
        collectPathFrom(source, target, seen) {
            if (source === target) {
                // Looking for a path from the target to itself - that path is just the target. This is the
                // "base case" of the search.
                return [target];
            }
            else if (seen.has(source)) {
                // The search has already looked through this source before.
                return null;
            }
            // Consider outgoing edges from `source`.
            seen.add(source);
            if (!this.references.has(source)) {
                // There are no outgoing edges from `source`.
                return null;
            }
            else {
                // Look through the outgoing edges of `source`.
                // TODO(alxhub): use proper iteration when the legacy build is removed. (#27762)
                let candidatePath = null;
                this.references.get(source).forEach(edge => {
                    // Early exit if a path has already been found.
                    if (candidatePath !== null) {
                        return;
                    }
                    // Look for a path from this outgoing edge to `target`.
                    const partialPath = this.collectPathFrom(edge, target, seen);
                    if (partialPath !== null) {
                        // A path exists from `edge` to `target`. Insert `source` at the beginning.
                        candidatePath = [source, ...partialPath];
                    }
                });
                return candidatePath;
            }
        }
        collectTransitiveReferences(set, decl) {
            if (this.references.has(decl)) {
                // TODO(alxhub): use proper iteration when the legacy build is removed. (#27762)
                this.references.get(decl).forEach(ref => {
                    if (!set.has(ref)) {
                        set.add(ref);
                        this.collectTransitiveReferences(set, ref);
                    }
                });
            }
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An implementation of the `DependencyTracker` dependency graph API.
     *
     * The `FileDependencyGraph`'s primary job is to determine whether a given file has "logically"
     * changed, given the set of physical changes (direct changes to files on disk).
     *
     * A file is logically changed if at least one of three conditions is met:
     *
     * 1. The file itself has physically changed.
     * 2. One of its dependencies has physically changed.
     * 3. One of its resource dependencies has physically changed.
     */
    class FileDependencyGraph {
        constructor() {
            this.nodes = new Map();
        }
        addDependency(from, on) {
            this.nodeFor(from).dependsOn.add(on.fileName);
        }
        addResourceDependency(from, resource) {
            this.nodeFor(from).usesResources.add(resource);
        }
        addTransitiveDependency(from, on) {
            const nodeFrom = this.nodeFor(from);
            nodeFrom.dependsOn.add(on.fileName);
            const nodeOn = this.nodeFor(on);
            for (const dep of nodeOn.dependsOn) {
                nodeFrom.dependsOn.add(dep);
            }
        }
        addTransitiveResources(from, resourcesOf) {
            const nodeFrom = this.nodeFor(from);
            const nodeOn = this.nodeFor(resourcesOf);
            for (const dep of nodeOn.usesResources) {
                nodeFrom.usesResources.add(dep);
            }
        }
        isStale(sf, changedTsPaths, changedResources) {
            return isLogicallyChanged(sf, this.nodeFor(sf), changedTsPaths, EMPTY_SET, changedResources);
        }
        /**
         * Update the current dependency graph from a previous one, incorporating a set of physical
         * changes.
         *
         * This method performs two tasks:
         *
         * 1. For files which have not logically changed, their dependencies from `previous` are added to
         *    `this` graph.
         * 2. For files which have logically changed, they're added to a set of logically changed files
         *    which is eventually returned.
         *
         * In essence, for build `n`, this method performs:
         *
         * G(n) + L(n) = G(n - 1) + P(n)
         *
         * where:
         *
         * G(n) = the dependency graph of build `n`
         * L(n) = the logically changed files from build n - 1 to build n.
         * P(n) = the physically changed files from build n - 1 to build n.
         */
        updateWithPhysicalChanges(previous, changedTsPaths, deletedTsPaths, changedResources) {
            const logicallyChanged = new Set();
            for (const sf of previous.nodes.keys()) {
                const node = previous.nodeFor(sf);
                if (isLogicallyChanged(sf, node, changedTsPaths, deletedTsPaths, changedResources)) {
                    logicallyChanged.add(sf.fileName);
                }
                else if (!deletedTsPaths.has(sf.fileName)) {
                    this.nodes.set(sf, {
                        dependsOn: new Set(node.dependsOn),
                        usesResources: new Set(node.usesResources),
                    });
                }
            }
            return logicallyChanged;
        }
        nodeFor(sf) {
            if (!this.nodes.has(sf)) {
                this.nodes.set(sf, {
                    dependsOn: new Set(),
                    usesResources: new Set(),
                });
            }
            return this.nodes.get(sf);
        }
    }
    /**
     * Determine whether `sf` has logically changed, given its dependencies and the set of physically
     * changed files and resources.
     */
    function isLogicallyChanged(sf, node, changedTsPaths, deletedTsPaths, changedResources) {
        // A file is logically changed if it has physically changed itself (including being deleted).
        if (changedTsPaths.has(sf.fileName) || deletedTsPaths.has(sf.fileName)) {
            return true;
        }
        // A file is logically changed if one of its dependencies has physically changed.
        for (const dep of node.dependsOn) {
            if (changedTsPaths.has(dep) || deletedTsPaths.has(dep)) {
                return true;
            }
        }
        // A file is logically changed if one of its resources has physically changed.
        for (const dep of node.usesResources) {
            if (changedResources.has(dep)) {
                return true;
            }
        }
        return false;
    }
    const EMPTY_SET = new Set();

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Drives an incremental build, by tracking changes and determining which files need to be emitted.
     */
    class IncrementalDriver {
        constructor(state, allTsFiles, depGraph, logicalChanges) {
            this.allTsFiles = allTsFiles;
            this.depGraph = depGraph;
            this.logicalChanges = logicalChanges;
            this.state = state;
        }
        /**
         * Construct an `IncrementalDriver` with a starting state that incorporates the results of a
         * previous build.
         *
         * The previous build's `BuildState` is reconciled with the new program's changes, and the results
         * are merged into the new build's `PendingBuildState`.
         */
        static reconcile(oldProgram, oldDriver, newProgram, modifiedResourceFiles) {
            // Initialize the state of the current build based on the previous one.
            let state;
            if (oldDriver.state.kind === BuildStateKind.Pending) {
                // The previous build never made it past the pending state. Reuse it as the starting state for
                // this build.
                state = oldDriver.state;
            }
            else {
                // The previous build was successfully analyzed. `pendingEmit` is the only state carried
                // forward into this build.
                state = {
                    kind: BuildStateKind.Pending,
                    pendingEmit: oldDriver.state.pendingEmit,
                    changedResourcePaths: new Set(),
                    changedTsPaths: new Set(),
                    lastGood: oldDriver.state.lastGood,
                };
            }
            // Merge the freshly modified resource files with any prior ones.
            if (modifiedResourceFiles !== null) {
                for (const resFile of modifiedResourceFiles) {
                    state.changedResourcePaths.add(absoluteFrom(resFile));
                }
            }
            // Next, process the files in the new program, with a couple of goals:
            // 1) Determine which TS files have changed, if any, and merge them into `changedTsFiles`.
            // 2) Produce a list of TS files which no longer exist in the program (they've been deleted
            //    since the previous compilation). These need to be removed from the state tracking to avoid
            //    leaking memory.
            // All files in the old program, for easy detection of changes.
            const oldFiles = new Set(oldProgram.getSourceFiles());
            // Assume all the old files were deleted to begin with. Only TS files are tracked.
            const deletedTsPaths = new Set(tsOnlyFiles(oldProgram).map(sf => sf.fileName));
            for (const newFile of newProgram.getSourceFiles()) {
                if (!newFile.isDeclarationFile) {
                    // This file exists in the new program, so remove it from `deletedTsPaths`.
                    deletedTsPaths.delete(newFile.fileName);
                }
                if (oldFiles.has(newFile)) {
                    // This file hasn't changed; no need to look at it further.
                    continue;
                }
                // The file has changed since the last successful build. The appropriate reaction depends on
                // what kind of file it is.
                if (!newFile.isDeclarationFile) {
                    // It's a .ts file, so track it as a change.
                    state.changedTsPaths.add(newFile.fileName);
                }
                else {
                    // It's a .d.ts file. Currently the compiler does not do a great job of tracking
                    // dependencies on .d.ts files, so bail out of incremental builds here and do a full build.
                    // This usually only happens if something in node_modules changes.
                    return IncrementalDriver.fresh(newProgram);
                }
            }
            // The next step is to remove any deleted files from the state.
            for (const filePath of deletedTsPaths) {
                state.pendingEmit.delete(filePath);
                // Even if the file doesn't exist in the current compilation, it still might have been changed
                // in a previous one, so delete it from the set of changed TS files, just in case.
                state.changedTsPaths.delete(filePath);
            }
            // Now, changedTsPaths contains physically changed TS paths. Use the previous program's logical
            // dependency graph to determine logically changed files.
            const depGraph = new FileDependencyGraph();
            // If a previous compilation exists, use its dependency graph to determine the set of logically
            // changed files.
            let logicalChanges = null;
            if (state.lastGood !== null) {
                // Extract the set of logically changed files. At the same time, this operation populates the
                // current (fresh) dependency graph with information about those files which have not
                // logically changed.
                logicalChanges = depGraph.updateWithPhysicalChanges(state.lastGood.depGraph, state.changedTsPaths, deletedTsPaths, state.changedResourcePaths);
                for (const fileName of state.changedTsPaths) {
                    logicalChanges.add(fileName);
                }
                // Any logically changed files need to be re-emitted. Most of the time this would happen
                // regardless because the new dependency graph would _also_ identify the file as stale.
                // However there are edge cases such as removing a component from an NgModule without adding
                // it to another one, where the previous graph identifies the file as logically changed, but
                // the new graph (which does not have that edge) fails to identify that the file should be
                // re-emitted.
                for (const change of logicalChanges) {
                    state.pendingEmit.add(change);
                }
            }
            // `state` now reflects the initial pending state of the current compilation.
            return new IncrementalDriver(state, new Set(tsOnlyFiles(newProgram)), depGraph, logicalChanges);
        }
        static fresh(program) {
            // Initialize the set of files which need to be emitted to the set of all TS files in the
            // program.
            const tsFiles = tsOnlyFiles(program);
            const state = {
                kind: BuildStateKind.Pending,
                pendingEmit: new Set(tsFiles.map(sf => sf.fileName)),
                changedResourcePaths: new Set(),
                changedTsPaths: new Set(),
                lastGood: null,
            };
            return new IncrementalDriver(state, new Set(tsFiles), new FileDependencyGraph(), /* logicalChanges */ null);
        }
        recordSuccessfulAnalysis(traitCompiler) {
            if (this.state.kind !== BuildStateKind.Pending) {
                // Changes have already been incorporated.
                return;
            }
            const pendingEmit = this.state.pendingEmit;
            const state = this.state;
            for (const sf of this.allTsFiles) {
                if (this.depGraph.isStale(sf, state.changedTsPaths, state.changedResourcePaths)) {
                    // Something has changed which requires this file be re-emitted.
                    pendingEmit.add(sf.fileName);
                }
            }
            // Update the state to an `AnalyzedBuildState`.
            this.state = {
                kind: BuildStateKind.Analyzed,
                pendingEmit,
                // Since this compilation was successfully analyzed, update the "last good" artifacts to the
                // ones from the current compilation.
                lastGood: {
                    depGraph: this.depGraph,
                    traitCompiler: traitCompiler,
                    typeCheckingResults: null,
                },
                priorTypeCheckingResults: this.state.lastGood !== null ? this.state.lastGood.typeCheckingResults : null,
            };
        }
        recordSuccessfulTypeCheck(results) {
            if (this.state.lastGood === null || this.state.kind !== BuildStateKind.Analyzed) {
                return;
            }
            this.state.lastGood.typeCheckingResults = results;
        }
        recordSuccessfulEmit(sf) {
            this.state.pendingEmit.delete(sf.fileName);
        }
        safeToSkipEmit(sf) {
            return !this.state.pendingEmit.has(sf.fileName);
        }
        priorWorkFor(sf) {
            if (this.state.lastGood === null || this.logicalChanges === null) {
                // There is no previous good build, so no prior work exists.
                return null;
            }
            else if (this.logicalChanges.has(sf.fileName)) {
                // Prior work might exist, but would be stale as the file in question has logically changed.
                return null;
            }
            else {
                // Prior work might exist, and if it does then it's usable!
                return this.state.lastGood.traitCompiler.recordsFor(sf);
            }
        }
        priorTypeCheckingResultsFor(sf) {
            if (this.state.kind !== BuildStateKind.Analyzed ||
                this.state.priorTypeCheckingResults === null || this.logicalChanges === null) {
                return null;
            }
            if (this.logicalChanges.has(sf.fileName)) {
                return null;
            }
            const fileName = absoluteFromSourceFile(sf);
            if (!this.state.priorTypeCheckingResults.has(fileName)) {
                return null;
            }
            const data = this.state.priorTypeCheckingResults.get(fileName);
            if (data.hasInlines) {
                return null;
            }
            return data;
        }
    }
    var BuildStateKind;
    (function (BuildStateKind) {
        BuildStateKind[BuildStateKind["Pending"] = 0] = "Pending";
        BuildStateKind[BuildStateKind["Analyzed"] = 1] = "Analyzed";
    })(BuildStateKind || (BuildStateKind = {}));
    function tsOnlyFiles(program) {
        return program.getSourceFiles().filter(sf => !sf.isDeclarationFile);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Manages the `IncrementalDriver` associated with a `ts.Program` by monkey-patching it onto the
     * program under `SYM_INCREMENTAL_DRIVER`.
     */
    class PatchedProgramIncrementalBuildStrategy {
        getIncrementalDriver(program) {
            const driver = program[SYM_INCREMENTAL_DRIVER];
            if (driver === undefined || !(driver instanceof IncrementalDriver)) {
                return null;
            }
            return driver;
        }
        setIncrementalDriver(driver, program) {
            program[SYM_INCREMENTAL_DRIVER] = driver;
        }
    }
    /**
     * Symbol under which the `IncrementalDriver` is stored on a `ts.Program`.
     *
     * The TS model of incremental compilation is based around reuse of a previous `ts.Program` in the
     * construction of a new one. The `NgCompiler` follows this abstraction - passing in a previous
     * `ts.Program` is sufficient to trigger incremental compilation. This previous `ts.Program` need
     * not be from an Angular compilation (that is, it need not have been created from `NgCompiler`).
     *
     * If it is, though, Angular can benefit from reusing previous analysis work. This reuse is managed
     * by the `IncrementalDriver`, which is inherited from the old program to the new program. To
     * support this behind the API of passing an old `ts.Program`, the `IncrementalDriver` is stored on
     * the `ts.Program` under this symbol.
     */
    const SYM_INCREMENTAL_DRIVER = Symbol('NgIncrementalDriver');

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Describes the kind of identifier found in a template.
     */
    var IdentifierKind;
    (function (IdentifierKind) {
        IdentifierKind[IdentifierKind["Property"] = 0] = "Property";
        IdentifierKind[IdentifierKind["Method"] = 1] = "Method";
        IdentifierKind[IdentifierKind["Element"] = 2] = "Element";
        IdentifierKind[IdentifierKind["Template"] = 3] = "Template";
        IdentifierKind[IdentifierKind["Attribute"] = 4] = "Attribute";
        IdentifierKind[IdentifierKind["Reference"] = 5] = "Reference";
        IdentifierKind[IdentifierKind["Variable"] = 6] = "Variable";
    })(IdentifierKind || (IdentifierKind = {}));
    /**
     * Describes the absolute byte offsets of a text anchor in a source code.
     */
    class AbsoluteSourceSpan$1 {
        constructor(start, end) {
            this.start = start;
            this.end = end;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A context for storing indexing infromation about components of a program.
     *
     * An `IndexingContext` collects component and template analysis information from
     * `DecoratorHandler`s and exposes them to be indexed.
     */
    class IndexingContext {
        constructor() {
            this.components = new Set();
        }
        /**
         * Adds a component to the context.
         */
        addComponent(info) {
            this.components.add(info);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Visits the AST of an Angular template syntax expression, finding interesting
     * entities (variable references, etc.). Creates an array of Entities found in
     * the expression, with the location of the Entities being relative to the
     * expression.
     *
     * Visiting `text {{prop}}` will return
     * `[TopLevelIdentifier {name: 'prop', span: {start: 7, end: 11}}]`.
     */
    class ExpressionVisitor extends RecursiveAstVisitor {
        constructor(expressionStr, absoluteOffset, boundTemplate, targetToIdentifier) {
            super();
            this.expressionStr = expressionStr;
            this.absoluteOffset = absoluteOffset;
            this.boundTemplate = boundTemplate;
            this.targetToIdentifier = targetToIdentifier;
            this.identifiers = [];
        }
        /**
         * Returns identifiers discovered in an expression.
         *
         * @param ast expression AST to visit
         * @param source expression AST source code
         * @param absoluteOffset absolute byte offset from start of the file to the start of the AST
         * source code.
         * @param boundTemplate bound target of the entire template, which can be used to query for the
         * entities expressions target.
         * @param targetToIdentifier closure converting a template target node to its identifier.
         */
        static getIdentifiers(ast, source, absoluteOffset, boundTemplate, targetToIdentifier) {
            const visitor = new ExpressionVisitor(source, absoluteOffset, boundTemplate, targetToIdentifier);
            visitor.visit(ast);
            return visitor.identifiers;
        }
        visit(ast) {
            ast.visit(this);
        }
        visitMethodCall(ast, context) {
            this.visitIdentifier(ast, IdentifierKind.Method);
            super.visitMethodCall(ast, context);
        }
        visitPropertyRead(ast, context) {
            this.visitIdentifier(ast, IdentifierKind.Property);
            super.visitPropertyRead(ast, context);
        }
        visitPropertyWrite(ast, context) {
            this.visitIdentifier(ast, IdentifierKind.Property);
            super.visitPropertyWrite(ast, context);
        }
        /**
         * Visits an identifier, adding it to the identifier store if it is useful for indexing.
         *
         * @param ast expression AST the identifier is in
         * @param kind identifier kind
         */
        visitIdentifier(ast, kind) {
            // The definition of a non-top-level property such as `bar` in `{{foo.bar}}` is currently
            // impossible to determine by an indexer and unsupported by the indexing module.
            // The indexing module also does not currently support references to identifiers declared in the
            // template itself, which have a non-null expression target.
            if (!(ast.receiver instanceof ImplicitReceiver)) {
                return;
            }
            // Get the location of the identifier of real interest.
            // The compiler's expression parser records the location of some expressions in a manner not
            // useful to the indexer. For example, a `MethodCall` `foo(a, b)` will record the span of the
            // entire method call, but the indexer is interested only in the method identifier.
            const localExpression = this.expressionStr.substr(ast.span.start);
            if (!localExpression.includes(ast.name)) {
                throw new Error(`Impossible state: "${ast.name}" not found in "${localExpression}"`);
            }
            const identifierStart = ast.span.start + localExpression.indexOf(ast.name);
            // Join the relative position of the expression within a node with the absolute position
            // of the node to get the absolute position of the expression in the source code.
            const absoluteStart = this.absoluteOffset + identifierStart;
            const span = new AbsoluteSourceSpan$1(absoluteStart, absoluteStart + ast.name.length);
            const targetAst = this.boundTemplate.getExpressionTarget(ast);
            const target = targetAst ? this.targetToIdentifier(targetAst) : null;
            const identifier = {
                name: ast.name,
                span,
                kind,
                target,
            };
            this.identifiers.push(identifier);
        }
    }
    /**
     * Visits the AST of a parsed Angular template. Discovers and stores
     * identifiers of interest, deferring to an `ExpressionVisitor` as needed.
     */
    class TemplateVisitor extends RecursiveVisitor {
        /**
         * Creates a template visitor for a bound template target. The bound target can be used when
         * deferred to the expression visitor to get information about the target of an expression.
         *
         * @param boundTemplate bound template target
         */
        constructor(boundTemplate) {
            super();
            this.boundTemplate = boundTemplate;
            // Identifiers of interest found in the template.
            this.identifiers = new Set();
            // Map of targets in a template to their identifiers.
            this.targetIdentifierCache = new Map();
            // Map of elements and templates to their identifiers.
            this.elementAndTemplateIdentifierCache = new Map();
        }
        /**
         * Visits a node in the template.
         *
         * @param node node to visit
         */
        visit(node) {
            node.visit(this);
        }
        visitAll(nodes) {
            nodes.forEach(node => this.visit(node));
        }
        /**
         * Add an identifier for an HTML element and visit its children recursively.
         *
         * @param element
         */
        visitElement(element) {
            const elementIdentifier = this.elementOrTemplateToIdentifier(element);
            this.identifiers.add(elementIdentifier);
            this.visitAll(element.references);
            this.visitAll(element.inputs);
            this.visitAll(element.attributes);
            this.visitAll(element.children);
            this.visitAll(element.outputs);
        }
        visitTemplate(template) {
            const templateIdentifier = this.elementOrTemplateToIdentifier(template);
            this.identifiers.add(templateIdentifier);
            this.visitAll(template.variables);
            this.visitAll(template.attributes);
            this.visitAll(template.templateAttrs);
            this.visitAll(template.children);
            this.visitAll(template.references);
        }
        visitBoundAttribute(attribute) {
            // A BoundAttribute's value (the parent AST) may have subexpressions (children ASTs) that have
            // recorded spans extending past the recorded span of the parent. The most common example of
            // this is with `*ngFor`.
            // To resolve this, use the information on the BoundAttribute Template AST, which is always
            // correct, to determine locations of identifiers in the expression.
            //
            // TODO(ayazhafiz): Remove this when https://github.com/angular/angular/pull/31813 lands.
            const attributeSrc = attribute.sourceSpan.toString();
            const attributeAbsolutePosition = attribute.sourceSpan.start.offset;
            // Skip the bytes of the attribute name so that there are no collisions between the attribute
            // name and expression identifier names later.
            const nameSkipOffet = attributeSrc.indexOf(attribute.name) + attribute.name.length;
            const expressionSrc = attributeSrc.substring(nameSkipOffet);
            const expressionAbsolutePosition = attributeAbsolutePosition + nameSkipOffet;
            const identifiers = ExpressionVisitor.getIdentifiers(attribute.value, expressionSrc, expressionAbsolutePosition, this.boundTemplate, this.targetToIdentifier.bind(this));
            identifiers.forEach(id => this.identifiers.add(id));
        }
        visitBoundEvent(attribute) {
            this.visitExpression(attribute.handler);
        }
        visitBoundText(text) {
            this.visitExpression(text.value);
        }
        visitReference(reference) {
            const referenceIdentifer = this.targetToIdentifier(reference);
            this.identifiers.add(referenceIdentifer);
        }
        visitVariable(variable) {
            const variableIdentifier = this.targetToIdentifier(variable);
            this.identifiers.add(variableIdentifier);
        }
        /** Creates an identifier for a template element or template node. */
        elementOrTemplateToIdentifier(node) {
            // If this node has already been seen, return the cached result.
            if (this.elementAndTemplateIdentifierCache.has(node)) {
                return this.elementAndTemplateIdentifierCache.get(node);
            }
            let name;
            let kind;
            if (node instanceof Template) {
                name = node.tagName;
                kind = IdentifierKind.Template;
            }
            else {
                name = node.name;
                kind = IdentifierKind.Element;
            }
            const { sourceSpan } = node;
            // An element's or template's source span can be of the form `<element>`, `<element />`, or
            // `<element></element>`. Only the selector is interesting to the indexer, so the source is
            // searched for the first occurrence of the element (selector) name.
            const start = this.getStartLocation(name, sourceSpan);
            const absoluteSpan = new AbsoluteSourceSpan$1(start, start + name.length);
            // Record the nodes's attributes, which an indexer can later traverse to see if any of them
            // specify a used directive on the node.
            const attributes = node.attributes.map(({ name, sourceSpan }) => {
                return {
                    name,
                    span: new AbsoluteSourceSpan$1(sourceSpan.start.offset, sourceSpan.end.offset),
                    kind: IdentifierKind.Attribute,
                };
            });
            const usedDirectives = this.boundTemplate.getDirectivesOfNode(node) || [];
            const identifier = {
                name,
                span: absoluteSpan,
                kind,
                attributes: new Set(attributes),
                usedDirectives: new Set(usedDirectives.map(dir => {
                    return {
                        node: dir.ref.node,
                        selector: dir.selector,
                    };
                })),
            };
            this.elementAndTemplateIdentifierCache.set(node, identifier);
            return identifier;
        }
        /** Creates an identifier for a template reference or template variable target. */
        targetToIdentifier(node) {
            // If this node has already been seen, return the cached result.
            if (this.targetIdentifierCache.has(node)) {
                return this.targetIdentifierCache.get(node);
            }
            const { name, sourceSpan } = node;
            const start = this.getStartLocation(name, sourceSpan);
            const span = new AbsoluteSourceSpan$1(start, start + name.length);
            let identifier;
            if (node instanceof Reference) {
                // If the node is a reference, we care about its target. The target can be an element, a
                // template, a directive applied on a template or element (in which case the directive field
                // is non-null), or nothing at all.
                const refTarget = this.boundTemplate.getReferenceTarget(node);
                let target = null;
                if (refTarget) {
                    if (refTarget instanceof Element || refTarget instanceof Template) {
                        target = {
                            node: this.elementOrTemplateToIdentifier(refTarget),
                            directive: null,
                        };
                    }
                    else {
                        target = {
                            node: this.elementOrTemplateToIdentifier(refTarget.node),
                            directive: refTarget.directive.ref.node,
                        };
                    }
                }
                identifier = {
                    name,
                    span,
                    kind: IdentifierKind.Reference,
                    target,
                };
            }
            else {
                identifier = {
                    name,
                    span,
                    kind: IdentifierKind.Variable,
                };
            }
            this.targetIdentifierCache.set(node, identifier);
            return identifier;
        }
        /** Gets the start location of a string in a SourceSpan */
        getStartLocation(name, context) {
            const localStr = context.toString();
            if (!localStr.includes(name)) {
                throw new Error(`Impossible state: "${name}" not found in "${localStr}"`);
            }
            return context.start.offset + localStr.indexOf(name);
        }
        /**
         * Visits a node's expression and adds its identifiers, if any, to the visitor's state.
         * Only ASTs with information about the expression source and its location are visited.
         *
         * @param node node whose expression to visit
         */
        visitExpression(ast) {
            // Only include ASTs that have information about their source and absolute source spans.
            if (ast instanceof ASTWithSource && ast.source !== null) {
                // Make target to identifier mapping closure stateful to this visitor instance.
                const targetToIdentifier = this.targetToIdentifier.bind(this);
                const absoluteOffset = ast.sourceSpan.start;
                const identifiers = ExpressionVisitor.getIdentifiers(ast, ast.source, absoluteOffset, this.boundTemplate, targetToIdentifier);
                identifiers.forEach(id => this.identifiers.add(id));
            }
        }
    }
    /**
     * Traverses a template AST and builds identifiers discovered in it.
     *
     * @param boundTemplate bound template target, which can be used for querying expression targets.
     * @return identifiers in template
     */
    function getTemplateIdentifiers(boundTemplate) {
        const visitor = new TemplateVisitor(boundTemplate);
        if (boundTemplate.target.template !== undefined) {
            visitor.visitAll(boundTemplate.target.template);
        }
        return visitor.identifiers;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Generates `IndexedComponent` entries from a `IndexingContext`, which has information
     * about components discovered in the program registered in it.
     *
     * The context must be populated before `generateAnalysis` is called.
     */
    function generateAnalysis(context) {
        const analysis = new Map();
        context.components.forEach(({ declaration, selector, boundTemplate, templateMeta }) => {
            const name = declaration.name.getText();
            const usedComponents = new Set();
            const usedDirs = boundTemplate.getUsedDirectives();
            usedDirs.forEach(dir => {
                if (dir.isComponent) {
                    usedComponents.add(dir.ref.node);
                }
            });
            // Get source files for the component and the template. If the template is inline, its source
            // file is the component's.
            const componentFile = new ParseSourceFile(declaration.getSourceFile().getFullText(), declaration.getSourceFile().fileName);
            let templateFile;
            if (templateMeta.isInline) {
                templateFile = componentFile;
            }
            else {
                templateFile = templateMeta.file;
            }
            analysis.set(declaration, {
                name,
                selector,
                file: componentFile,
                template: {
                    identifiers: getTemplateIdentifiers(boundTemplate),
                    usedComponents,
                    isInline: templateMeta.isInline,
                    file: templateFile,
                },
            });
        });
        return analysis;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class ModuleWithProvidersScanner {
        constructor(host, evaluator, emitter) {
            this.host = host;
            this.evaluator = evaluator;
            this.emitter = emitter;
        }
        scan(sf, dts) {
            for (const stmt of sf.statements) {
                this.visitStatement(dts, stmt);
            }
        }
        visitStatement(dts, stmt) {
            // Detect whether a statement is exported, which is used as one of the hints whether to look
            // more closely at possible MWP functions within. This is a syntactic check, not a semantic
            // check, so it won't detect cases like:
            //
            // var X = ...;
            // export {X}
            //
            // This is intentional, because the alternative is slow and this will catch 99% of the cases we
            // need to handle.
            const isExported = stmt.modifiers !== undefined &&
                stmt.modifiers.some(mod => mod.kind === ts.SyntaxKind.ExportKeyword);
            if (!isExported) {
                return;
            }
            if (ts.isClassDeclaration(stmt)) {
                for (const member of stmt.members) {
                    if (!ts.isMethodDeclaration(member) || !isStatic(member)) {
                        continue;
                    }
                    this.visitFunctionOrMethodDeclaration(dts, member);
                }
            }
            else if (ts.isFunctionDeclaration(stmt)) {
                this.visitFunctionOrMethodDeclaration(dts, stmt);
            }
        }
        visitFunctionOrMethodDeclaration(dts, decl) {
            // First, some sanity. This should have a method body with a single return statement.
            if (decl.body === undefined || decl.body.statements.length !== 1) {
                return;
            }
            const retStmt = decl.body.statements[0];
            if (!ts.isReturnStatement(retStmt) || retStmt.expression === undefined) {
                return;
            }
            const retValue = retStmt.expression;
            // Now, look at the return type of the method. Maybe bail if the type is already marked, or if
            // it's incompatible with a MWP function.
            const returnType = this.returnTypeOf(decl);
            if (returnType === ReturnType.OTHER || returnType === ReturnType.MWP_WITH_TYPE) {
                // Don't process this declaration, it either already declares the right return type, or an
                // incompatible one.
                return;
            }
            const value = this.evaluator.evaluate(retValue);
            if (!(value instanceof Map) || !value.has('ngModule')) {
                // The return value does not provide sufficient information to be able to add a generic type.
                return;
            }
            if (returnType === ReturnType.INFERRED && !isModuleWithProvidersType(value)) {
                // The return type is inferred but the returned object is not of the correct shape, so we
                // shouldn's modify the return type to become `ModuleWithProviders`.
                return;
            }
            // The return type has been verified to represent the `ModuleWithProviders` type, but either the
            // return type is inferred or the generic type argument is missing. In both cases, a new return
            // type is created where the `ngModule` type is included as generic type argument.
            const ngModule = value.get('ngModule');
            if (!(ngModule instanceof Reference$1) || !ts.isClassDeclaration(ngModule.node)) {
                return;
            }
            const ngModuleExpr = this.emitter.emit(ngModule, decl.getSourceFile(), ImportFlags.ForceNewImport);
            const ngModuleType = new ExpressionType(ngModuleExpr);
            const mwpNgType = new ExpressionType(new ExternalExpr(Identifiers$1.ModuleWithProviders), /* modifiers */ null, [ngModuleType]);
            dts.addTypeReplacement(decl, mwpNgType);
        }
        returnTypeOf(decl) {
            if (decl.type === undefined) {
                return ReturnType.INFERRED;
            }
            else if (!ts.isTypeReferenceNode(decl.type)) {
                return ReturnType.OTHER;
            }
            // Try to figure out if the type is of a familiar form, something that looks like it was
            // imported.
            let typeId;
            if (ts.isIdentifier(decl.type.typeName)) {
                // def: ModuleWithProviders
                typeId = decl.type.typeName;
            }
            else if (ts.isQualifiedName(decl.type.typeName) && ts.isIdentifier(decl.type.typeName.left)) {
                // def: i0.ModuleWithProviders
                typeId = decl.type.typeName.right;
            }
            else {
                return ReturnType.OTHER;
            }
            const importDecl = this.host.getImportOfIdentifier(typeId);
            if (importDecl === null || importDecl.from !== '@angular/core' ||
                importDecl.name !== 'ModuleWithProviders') {
                return ReturnType.OTHER;
            }
            if (decl.type.typeArguments === undefined || decl.type.typeArguments.length === 0) {
                // The return type is indeed ModuleWithProviders, but no generic type parameter was found.
                return ReturnType.MWP_NO_TYPE;
            }
            else {
                // The return type is ModuleWithProviders, and the user has already specified a generic type.
                return ReturnType.MWP_WITH_TYPE;
            }
        }
    }
    var ReturnType;
    (function (ReturnType) {
        ReturnType[ReturnType["INFERRED"] = 0] = "INFERRED";
        ReturnType[ReturnType["MWP_NO_TYPE"] = 1] = "MWP_NO_TYPE";
        ReturnType[ReturnType["MWP_WITH_TYPE"] = 2] = "MWP_WITH_TYPE";
        ReturnType[ReturnType["OTHER"] = 3] = "OTHER";
    })(ReturnType || (ReturnType = {}));
    /** Whether the resolved value map represents a ModuleWithProviders object */
    function isModuleWithProvidersType(value) {
        const ngModule = value.has('ngModule');
        const providers = value.has('providers');
        return ngModule && (value.size === 1 || (providers && value.size === 2));
    }
    function isStatic(node) {
        return node.modifiers !== undefined &&
            node.modifiers.some(mod => mod.kind === ts.SyntaxKind.StaticKeyword);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const NOOP_PERF_RECORDER = {
        enabled: false,
        mark: (name, node, category, detail) => { },
        start: (name, node, category, detail) => {
            return 0;
        },
        stop: (span) => { },
    };

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var PerfLogEventType;
    (function (PerfLogEventType) {
        PerfLogEventType[PerfLogEventType["SPAN_OPEN"] = 0] = "SPAN_OPEN";
        PerfLogEventType[PerfLogEventType["SPAN_CLOSE"] = 1] = "SPAN_CLOSE";
        PerfLogEventType[PerfLogEventType["MARK"] = 2] = "MARK";
    })(PerfLogEventType || (PerfLogEventType = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const CSS_PREPROCESSOR_EXT = /(\.scss|\.sass|\.less|\.styl)$/;
    /**
     * `ResourceLoader` which delegates to an `NgCompilerAdapter`'s resource loading methods.
     */
    class AdapterResourceLoader {
        constructor(adapter, options) {
            this.adapter = adapter;
            this.options = options;
            this.cache = new Map();
            this.fetching = new Map();
            this.canPreload = !!this.adapter.readResource;
        }
        /**
         * Resolve the url of a resource relative to the file that contains the reference to it.
         * The return value of this method can be used in the `load()` and `preload()` methods.
         *
         * Uses the provided CompilerHost if it supports mapping resources to filenames.
         * Otherwise, uses a fallback mechanism that searches the module resolution candidates.
         *
         * @param url The, possibly relative, url of the resource.
         * @param fromFile The path to the file that contains the URL of the resource.
         * @returns A resolved url of resource.
         * @throws An error if the resource cannot be resolved.
         */
        resolve(url, fromFile) {
            let resolvedUrl = null;
            if (this.adapter.resourceNameToFileName) {
                resolvedUrl = this.adapter.resourceNameToFileName(url, fromFile);
            }
            else {
                resolvedUrl = this.fallbackResolve(url, fromFile);
            }
            if (resolvedUrl === null) {
                throw new Error(`HostResourceResolver: could not resolve ${url} in context of ${fromFile})`);
            }
            return resolvedUrl;
        }
        /**
         * Preload the specified resource, asynchronously.
         *
         * Once the resource is loaded, its value is cached so it can be accessed synchronously via the
         * `load()` method.
         *
         * @param resolvedUrl The url (resolved by a call to `resolve()`) of the resource to preload.
         * @returns A Promise that is resolved once the resource has been loaded or `undefined` if the
         * file has already been loaded.
         * @throws An Error if pre-loading is not available.
         */
        preload(resolvedUrl) {
            if (!this.adapter.readResource) {
                throw new Error('HostResourceLoader: the CompilerHost provided does not support pre-loading resources.');
            }
            if (this.cache.has(resolvedUrl)) {
                return undefined;
            }
            else if (this.fetching.has(resolvedUrl)) {
                return this.fetching.get(resolvedUrl);
            }
            const result = this.adapter.readResource(resolvedUrl);
            if (typeof result === 'string') {
                this.cache.set(resolvedUrl, result);
                return undefined;
            }
            else {
                const fetchCompletion = result.then(str => {
                    this.fetching.delete(resolvedUrl);
                    this.cache.set(resolvedUrl, str);
                });
                this.fetching.set(resolvedUrl, fetchCompletion);
                return fetchCompletion;
            }
        }
        /**
         * Load the resource at the given url, synchronously.
         *
         * The contents of the resource may have been cached by a previous call to `preload()`.
         *
         * @param resolvedUrl The url (resolved by a call to `resolve()`) of the resource to load.
         * @returns The contents of the resource.
         */
        load(resolvedUrl) {
            if (this.cache.has(resolvedUrl)) {
                return this.cache.get(resolvedUrl);
            }
            const result = this.adapter.readResource ? this.adapter.readResource(resolvedUrl) :
                this.adapter.readFile(resolvedUrl);
            if (typeof result !== 'string') {
                throw new Error(`HostResourceLoader: loader(${resolvedUrl}) returned a Promise`);
            }
            this.cache.set(resolvedUrl, result);
            return result;
        }
        /**
         * Attempt to resolve `url` in the context of `fromFile`, while respecting the rootDirs
         * option from the tsconfig. First, normalize the file name.
         */
        fallbackResolve(url, fromFile) {
            let candidateLocations;
            if (url.startsWith('/')) {
                // This path is not really an absolute path, but instead the leading '/' means that it's
                // rooted in the project rootDirs. So look for it according to the rootDirs.
                candidateLocations = this.getRootedCandidateLocations(url);
            }
            else {
                // This path is a "relative" path and can be resolved as such. To make this easier on the
                // downstream resolver, the './' prefix is added if missing to distinguish these paths from
                // absolute node_modules paths.
                if (!url.startsWith('.')) {
                    url = `./${url}`;
                }
                candidateLocations = this.getResolvedCandidateLocations(url, fromFile);
            }
            for (const candidate of candidateLocations) {
                if (this.adapter.fileExists(candidate)) {
                    return candidate;
                }
                else if (CSS_PREPROCESSOR_EXT.test(candidate)) {
                    /**
                     * If the user specified styleUrl points to *.scss, but the Sass compiler was run before
                     * Angular, then the resource may have been generated as *.css. Simply try the resolution
                     * again.
                     */
                    const cssFallbackUrl = candidate.replace(CSS_PREPROCESSOR_EXT, '.css');
                    if (this.adapter.fileExists(cssFallbackUrl)) {
                        return cssFallbackUrl;
                    }
                }
            }
            return null;
        }
        getRootedCandidateLocations(url) {
            // The path already starts with '/', so add a '.' to make it relative.
            const segment = ('.' + url);
            return this.adapter.rootDirs.map(rootDir => join(rootDir, segment));
        }
        /**
         * TypeScript provides utilities to resolve module names, but not resource files (which aren't
         * a part of the ts.Program). However, TypeScript's module resolution can be used creatively
         * to locate where resource files should be expected to exist. Since module resolution returns
         * a list of file names that were considered, the loader can enumerate the possible locations
         * for the file by setting up a module resolution for it that will fail.
         */
        getResolvedCandidateLocations(url, fromFile) {
            // clang-format off
            const failedLookup = ts.resolveModuleName(url + '.$ngresource$', fromFile, this.options, this.adapter);
            // clang-format on
            if (failedLookup.failedLookupLocations === undefined) {
                throw new Error(`Internal error: expected to find failedLookupLocations during resolution of resource '${url}' in context of ${fromFile}`);
            }
            return failedLookup.failedLookupLocations
                .filter(candidate => candidate.endsWith('.$ngresource$.ts'))
                .map(candidate => candidate.replace(/\.\$ngresource\$\.ts$/, ''));
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class RouterEntryPointImpl {
        constructor(filePath, moduleName) {
            this.filePath = filePath;
            this.moduleName = moduleName;
        }
        get name() {
            return this.moduleName;
        }
        // For debugging purposes.
        toString() {
            return `RouterEntryPoint(name: ${this.name}, filePath: ${this.filePath})`;
        }
    }
    class RouterEntryPointManager {
        constructor(moduleResolver) {
            this.moduleResolver = moduleResolver;
            this.map = new Map();
        }
        resolveLoadChildrenIdentifier(loadChildrenIdentifier, context) {
            const [relativeFile, moduleName] = loadChildrenIdentifier.split('#');
            if (moduleName === undefined) {
                return null;
            }
            const resolvedSf = this.moduleResolver.resolveModule(relativeFile, context.fileName);
            if (resolvedSf === null) {
                return null;
            }
            return this.fromNgModule(resolvedSf, moduleName);
        }
        fromNgModule(sf, moduleName) {
            const key = entryPointKeyFor(sf.fileName, moduleName);
            if (!this.map.has(key)) {
                this.map.set(key, new RouterEntryPointImpl(sf.fileName, moduleName));
            }
            return this.map.get(key);
        }
    }
    function entryPointKeyFor(filePath, moduleName) {
        // Drop the extension to be compatible with how cli calls `listLazyRoutes(entryRoute)`.
        return `${filePath.replace(/\.tsx?$/i, '')}#${moduleName}`;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const ROUTES_MARKER = '__ngRoutesMarker__';
    function scanForCandidateTransitiveModules(expr, evaluator) {
        if (expr === null) {
            return [];
        }
        const candidateModuleKeys = [];
        const entries = evaluator.evaluate(expr);
        function recursivelyAddModules(entry) {
            if (Array.isArray(entry)) {
                for (const e of entry) {
                    recursivelyAddModules(e);
                }
            }
            else if (entry instanceof Map) {
                if (entry.has('ngModule')) {
                    recursivelyAddModules(entry.get('ngModule'));
                }
            }
            else if ((entry instanceof Reference$1) && hasIdentifier(entry.node)) {
                const filePath = entry.node.getSourceFile().fileName;
                const moduleName = entry.node.name.text;
                candidateModuleKeys.push(entryPointKeyFor(filePath, moduleName));
            }
        }
        recursivelyAddModules(entries);
        return candidateModuleKeys;
    }
    function scanForRouteEntryPoints(ngModule, moduleName, data, entryPointManager, evaluator) {
        const loadChildrenIdentifiers = [];
        const from = entryPointManager.fromNgModule(ngModule, moduleName);
        if (data.providers !== null) {
            loadChildrenIdentifiers.push(...scanForProviders(data.providers, evaluator));
        }
        if (data.imports !== null) {
            loadChildrenIdentifiers.push(...scanForRouterModuleUsage(data.imports, evaluator));
        }
        if (data.exports !== null) {
            loadChildrenIdentifiers.push(...scanForRouterModuleUsage(data.exports, evaluator));
        }
        const routes = [];
        for (const loadChildren of loadChildrenIdentifiers) {
            const resolvedTo = entryPointManager.resolveLoadChildrenIdentifier(loadChildren, ngModule);
            if (resolvedTo !== null) {
                routes.push({
                    loadChildren,
                    from,
                    resolvedTo,
                });
            }
        }
        return routes;
    }
    function scanForProviders(expr, evaluator) {
        const loadChildrenIdentifiers = [];
        const providers = evaluator.evaluate(expr);
        function recursivelyAddProviders(provider) {
            if (Array.isArray(provider)) {
                for (const entry of provider) {
                    recursivelyAddProviders(entry);
                }
            }
            else if (provider instanceof Map) {
                if (provider.has('provide') && provider.has('useValue')) {
                    const provide = provider.get('provide');
                    const useValue = provider.get('useValue');
                    if (isRouteToken(provide) && Array.isArray(useValue)) {
                        loadChildrenIdentifiers.push(...scanForLazyRoutes(useValue));
                    }
                }
            }
        }
        recursivelyAddProviders(providers);
        return loadChildrenIdentifiers;
    }
    function scanForRouterModuleUsage(expr, evaluator) {
        const loadChildrenIdentifiers = [];
        const imports = evaluator.evaluate(expr, routerModuleFFR);
        function recursivelyAddRoutes(imp) {
            if (Array.isArray(imp)) {
                for (const entry of imp) {
                    recursivelyAddRoutes(entry);
                }
            }
            else if (imp instanceof Map) {
                if (imp.has(ROUTES_MARKER) && imp.has('routes')) {
                    const routes = imp.get('routes');
                    if (Array.isArray(routes)) {
                        loadChildrenIdentifiers.push(...scanForLazyRoutes(routes));
                    }
                }
            }
        }
        recursivelyAddRoutes(imports);
        return loadChildrenIdentifiers;
    }
    function scanForLazyRoutes(routes) {
        const loadChildrenIdentifiers = [];
        function recursivelyScanRoutes(routes) {
            for (let route of routes) {
                if (!(route instanceof Map)) {
                    continue;
                }
                if (route.has('loadChildren')) {
                    const loadChildren = route.get('loadChildren');
                    if (typeof loadChildren === 'string') {
                        loadChildrenIdentifiers.push(loadChildren);
                    }
                }
                else if (route.has('children')) {
                    const children = route.get('children');
                    if (Array.isArray(children)) {
                        recursivelyScanRoutes(children);
                    }
                }
            }
        }
        recursivelyScanRoutes(routes);
        return loadChildrenIdentifiers;
    }
    /**
     * A foreign function resolver that converts `RouterModule.forRoot/forChild(X)` to a special object
     * of the form `{__ngRoutesMarker__: true, routes: X}`.
     *
     * These objects are then recognizable inside the larger set of imports/exports.
     */
    const routerModuleFFR = function routerModuleFFR(ref, args) {
        if (!isMethodNodeReference(ref) || !ts.isClassDeclaration(ref.node.parent)) {
            return null;
        }
        else if (ref.bestGuessOwningModule === null ||
            ref.bestGuessOwningModule.specifier !== '@angular/router') {
            return null;
        }
        else if (ref.node.parent.name === undefined || ref.node.parent.name.text !== 'RouterModule') {
            return null;
        }
        else if (!ts.isIdentifier(ref.node.name) ||
            (ref.node.name.text !== 'forRoot' && ref.node.name.text !== 'forChild')) {
            return null;
        }
        const routes = args[0];
        return ts.createObjectLiteral([
            ts.createPropertyAssignment(ROUTES_MARKER, ts.createTrue()),
            ts.createPropertyAssignment('routes', routes),
        ]);
    };
    function hasIdentifier(node) {
        const node_ = node;
        return (node_.name !== undefined) && ts.isIdentifier(node_.name);
    }
    function isMethodNodeReference(ref) {
        return ts.isMethodDeclaration(ref.node);
    }
    function isRouteToken(ref) {
        return ref instanceof Reference$1 && ref.bestGuessOwningModule !== null &&
            ref.bestGuessOwningModule.specifier === '@angular/router' && ref.debugName === 'ROUTES';
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class NgModuleRouteAnalyzer {
        constructor(moduleResolver, evaluator) {
            this.evaluator = evaluator;
            this.modules = new Map();
            this.entryPointManager = new RouterEntryPointManager(moduleResolver);
        }
        add(sourceFile, moduleName, imports, exports, providers) {
            const key = entryPointKeyFor(sourceFile.fileName, moduleName);
            if (this.modules.has(key)) {
                throw new Error(`Double route analyzing for '${key}'.`);
            }
            this.modules.set(key, {
                sourceFile,
                moduleName,
                imports,
                exports,
                providers,
            });
        }
        listLazyRoutes(entryModuleKey) {
            if ((entryModuleKey !== undefined) && !this.modules.has(entryModuleKey)) {
                throw new Error(`Failed to list lazy routes: Unknown module '${entryModuleKey}'.`);
            }
            const routes = [];
            const scannedModuleKeys = new Set();
            const pendingModuleKeys = entryModuleKey ? [entryModuleKey] : Array.from(this.modules.keys());
            // When listing lazy routes for a specific entry module, we need to recursively extract
            // "transitive" routes from imported/exported modules. This is not necessary when listing all
            // lazy routes, because all analyzed modules will be scanned anyway.
            const scanRecursively = entryModuleKey !== undefined;
            while (pendingModuleKeys.length > 0) {
                const key = pendingModuleKeys.pop();
                if (scannedModuleKeys.has(key)) {
                    continue;
                }
                else {
                    scannedModuleKeys.add(key);
                }
                const data = this.modules.get(key);
                const entryPoints = scanForRouteEntryPoints(data.sourceFile, data.moduleName, data, this.entryPointManager, this.evaluator);
                routes.push(...entryPoints.map(entryPoint => ({
                    route: entryPoint.loadChildren,
                    module: entryPoint.from,
                    referencedModule: entryPoint.resolvedTo,
                })));
                if (scanRecursively) {
                    pendingModuleKeys.push(...[
                        // Scan the retrieved lazy route entry points.
                        ...entryPoints.map(({ resolvedTo }) => entryPointKeyFor(resolvedTo.filePath, resolvedTo.moduleName)),
                        // Scan the current module's imported modules.
                        ...scanForCandidateTransitiveModules(data.imports, this.evaluator),
                        // Scan the current module's exported modules.
                        ...scanForCandidateTransitiveModules(data.exports, this.evaluator),
                    ].filter(key => this.modules.has(key)));
                }
            }
            return routes;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Reads Angular metadata from classes declared in .d.ts files and computes an `ExportScope`.
     *
     * Given an NgModule declared in a .d.ts file, this resolver can produce a transitive `ExportScope`
     * of all of the directives/pipes it exports. It does this by reading metadata off of Ivy static
     * fields on directives, components, pipes, and NgModules.
     */
    class MetadataDtsModuleScopeResolver {
        /**
         * @param dtsMetaReader a `MetadataReader` which can read metadata from `.d.ts` files.
         */
        constructor(dtsMetaReader, aliasingHost) {
            this.dtsMetaReader = dtsMetaReader;
            this.aliasingHost = aliasingHost;
            /**
             * Cache which holds fully resolved scopes for NgModule classes from .d.ts files.
             */
            this.cache = new Map();
        }
        /**
         * Resolve a `Reference`'d NgModule from a .d.ts file and produce a transitive `ExportScope`
         * listing the directives and pipes which that NgModule exports to others.
         *
         * This operation relies on a `Reference` instead of a direct TypeScrpt node as the `Reference`s
         * produced depend on how the original NgModule was imported.
         */
        resolve(ref) {
            const clazz = ref.node;
            const sourceFile = clazz.getSourceFile();
            if (!sourceFile.isDeclarationFile) {
                throw new Error(`Debug error: DtsModuleScopeResolver.read(${ref.debugName} from ${sourceFile.fileName}), but not a .d.ts file`);
            }
            if (this.cache.has(clazz)) {
                return this.cache.get(clazz);
            }
            // Build up the export scope - those directives and pipes made visible by this module.
            const directives = [];
            const pipes = [];
            const ngModules = new Set([clazz]);
            const meta = this.dtsMetaReader.getNgModuleMetadata(ref);
            if (meta === null) {
                this.cache.set(clazz, null);
                return null;
            }
            const declarations = new Set();
            for (const declRef of meta.declarations) {
                declarations.add(declRef.node);
            }
            // Only the 'exports' field of the NgModule's metadata is important. Imports and declarations
            // don't affect the export scope.
            for (const exportRef of meta.exports) {
                // Attempt to process the export as a directive.
                const directive = this.dtsMetaReader.getDirectiveMetadata(exportRef);
                if (directive !== null) {
                    const isReExport = !declarations.has(exportRef.node);
                    directives.push(this.maybeAlias(directive, sourceFile, isReExport));
                    continue;
                }
                // Attempt to process the export as a pipe.
                const pipe = this.dtsMetaReader.getPipeMetadata(exportRef);
                if (pipe !== null) {
                    const isReExport = !declarations.has(exportRef.node);
                    pipes.push(this.maybeAlias(pipe, sourceFile, isReExport));
                    continue;
                }
                // Attempt to process the export as a module.
                const exportScope = this.resolve(exportRef);
                if (exportScope !== null) {
                    // It is a module. Add exported directives and pipes to the current scope. This might
                    // involve rewriting the `Reference`s to those types to have an alias expression if one is
                    // required.
                    if (this.aliasingHost === null) {
                        // Fast path when aliases aren't required.
                        directives.push(...exportScope.exported.directives);
                        pipes.push(...exportScope.exported.pipes);
                    }
                    else {
                        // It's necessary to rewrite the `Reference`s to add alias expressions. This way, imports
                        // generated to these directives and pipes will use a shallow import to `sourceFile`
                        // instead of a deep import directly to the directive or pipe class.
                        //
                        // One important check here is whether the directive/pipe is declared in the same
                        // source file as the re-exporting NgModule. This can happen if both a directive, its
                        // NgModule, and the re-exporting NgModule are all in the same file. In this case,
                        // no import alias is needed as it would go to the same file anyway.
                        for (const directive of exportScope.exported.directives) {
                            directives.push(this.maybeAlias(directive, sourceFile, /* isReExport */ true));
                        }
                        for (const pipe of exportScope.exported.pipes) {
                            pipes.push(this.maybeAlias(pipe, sourceFile, /* isReExport */ true));
                        }
                        for (const ngModule of exportScope.exported.ngModules) {
                            ngModules.add(ngModule);
                        }
                    }
                }
                continue;
            }
            const exportScope = {
                exported: {
                    directives,
                    pipes,
                    ngModules: Array.from(ngModules),
                },
            };
            this.cache.set(clazz, exportScope);
            return exportScope;
        }
        maybeAlias(dirOrPipe, maybeAliasFrom, isReExport) {
            const ref = dirOrPipe.ref;
            if (this.aliasingHost === null || ref.node.getSourceFile() === maybeAliasFrom) {
                return dirOrPipe;
            }
            const alias = this.aliasingHost.getAliasIn(ref.node, maybeAliasFrom, isReExport);
            if (alias === null) {
                return dirOrPipe;
            }
            return Object.assign(Object.assign({}, dirOrPipe), { ref: ref.cloneWithAlias(alias) });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A registry which collects information about NgModules, Directives, Components, and Pipes which
     * are local (declared in the ts.Program being compiled), and can produce `LocalModuleScope`s
     * which summarize the compilation scope of a component.
     *
     * This class implements the logic of NgModule declarations, imports, and exports and can produce,
     * for a given component, the set of directives and pipes which are "visible" in that component's
     * template.
     *
     * The `LocalModuleScopeRegistry` has two "modes" of operation. During analysis, data for each
     * individual NgModule, Directive, Component, and Pipe is added to the registry. No attempt is made
     * to traverse or validate the NgModule graph (imports, exports, etc). After analysis, one of
     * `getScopeOfModule` or `getScopeForComponent` can be called, which traverses the NgModule graph
     * and applies the NgModule logic to generate a `LocalModuleScope`, the full scope for the given
     * module or component.
     *
     * The `LocalModuleScopeRegistry` is also capable of producing `ts.Diagnostic` errors when Angular
     * semantics are violated.
     */
    class LocalModuleScopeRegistry {
        constructor(localReader, dependencyScopeReader, refEmitter, aliasingHost) {
            this.localReader = localReader;
            this.dependencyScopeReader = dependencyScopeReader;
            this.refEmitter = refEmitter;
            this.aliasingHost = aliasingHost;
            /**
             * Tracks whether the registry has been asked to produce scopes for a module or component. Once
             * this is true, the registry cannot accept registrations of new directives/pipes/modules as it
             * would invalidate the cached scope data.
             */
            this.sealed = false;
            /**
             * A map of components from the current compilation unit to the NgModule which declared them.
             *
             * As components and directives are not distinguished at the NgModule level, this map may also
             * contain directives. This doesn't cause any problems but isn't useful as there is no concept of
             * a directive's compilation scope.
             */
            this.declarationToModule = new Map();
            /**
             * This maps from the directive/pipe class to a map of data for each NgModule that declares the
             * directive/pipe. This data is needed to produce an error for the given class.
             */
            this.duplicateDeclarations = new Map();
            this.moduleToRef = new Map();
            /**
             * A cache of calculated `LocalModuleScope`s for each NgModule declared in the current program.
             *
             * A value of `undefined` indicates the scope was invalid and produced errors (therefore,
             * diagnostics should exist in the `scopeErrors` map).
             */
            this.cache = new Map();
            /**
             * Tracks whether a given component requires "remote scoping".
             *
             * Remote scoping is when the set of directives which apply to a given component is set in the
             * NgModule's file instead of directly on the component def (which is sometimes needed to get
             * around cyclic import issues). This is not used in calculation of `LocalModuleScope`s, but is
             * tracked here for convenience.
             */
            this.remoteScoping = new Set();
            /**
             * Tracks errors accumulated in the processing of scopes for each module declaration.
             */
            this.scopeErrors = new Map();
            /**
             * Tracks which NgModules are unreliable due to errors within their declarations.
             *
             * This provides a unified view of which modules have errors, across all of the different
             * diagnostic categories that can be produced. Theoretically this can be inferred from the other
             * properties of this class, but is tracked explicitly to simplify the logic.
             */
            this.taintedModules = new Set();
        }
        /**
         * Add an NgModule's data to the registry.
         */
        registerNgModuleMetadata(data) {
            this.assertCollecting();
            const ngModule = data.ref.node;
            this.moduleToRef.set(data.ref.node, data.ref);
            // Iterate over the module's declarations, and add them to declarationToModule. If duplicates
            // are found, they're instead tracked in duplicateDeclarations.
            for (const decl of data.declarations) {
                this.registerDeclarationOfModule(ngModule, decl, data.rawDeclarations);
            }
        }
        registerDirectiveMetadata(directive) { }
        registerPipeMetadata(pipe) { }
        getScopeForComponent(clazz) {
            const scope = !this.declarationToModule.has(clazz) ?
                null :
                this.getScopeOfModule(this.declarationToModule.get(clazz).ngModule);
            return scope;
        }
        /**
         * If `node` is declared in more than one NgModule (duplicate declaration), then get the
         * `DeclarationData` for each offending declaration.
         *
         * Ordinarily a class is only declared in one NgModule, in which case this function returns
         * `null`.
         */
        getDuplicateDeclarations(node) {
            if (!this.duplicateDeclarations.has(node)) {
                return null;
            }
            return Array.from(this.duplicateDeclarations.get(node).values());
        }
        /**
         * Collects registered data for a module and its directives/pipes and convert it into a full
         * `LocalModuleScope`.
         *
         * This method implements the logic of NgModule imports and exports. It returns the
         * `LocalModuleScope` for the given NgModule if one can be produced, `null` if no scope was ever
         * defined, or the string `'error'` if the scope contained errors.
         */
        getScopeOfModule(clazz) {
            const scope = this.moduleToRef.has(clazz) ?
                this.getScopeOfModuleReference(this.moduleToRef.get(clazz)) :
                null;
            // If the NgModule class is marked as tainted, consider it an error.
            if (this.taintedModules.has(clazz)) {
                return 'error';
            }
            // Translate undefined -> 'error'.
            return scope !== undefined ? scope : 'error';
        }
        /**
         * Retrieves any `ts.Diagnostic`s produced during the calculation of the `LocalModuleScope` for
         * the given NgModule, or `null` if no errors were present.
         */
        getDiagnosticsOfModule(clazz) {
            // Required to ensure the errors are populated for the given class. If it has been processed
            // before, this will be a no-op due to the scope cache.
            this.getScopeOfModule(clazz);
            if (this.scopeErrors.has(clazz)) {
                return this.scopeErrors.get(clazz);
            }
            else {
                return null;
            }
        }
        /**
         * Returns a collection of the compilation scope for each registered declaration.
         */
        getCompilationScopes() {
            const scopes = [];
            this.declarationToModule.forEach((declData, declaration) => {
                const scope = this.getScopeOfModule(declData.ngModule);
                if (scope !== null && scope !== 'error') {
                    scopes.push(Object.assign({ declaration, ngModule: declData.ngModule }, scope.compilation));
                }
            });
            return scopes;
        }
        registerDeclarationOfModule(ngModule, decl, rawDeclarations) {
            const declData = {
                ngModule,
                ref: decl,
                rawDeclarations,
            };
            // First, check for duplicate declarations of the same directive/pipe.
            if (this.duplicateDeclarations.has(decl.node)) {
                // This directive/pipe has already been identified as being duplicated. Add this module to the
                // map of modules for which a duplicate declaration exists.
                this.duplicateDeclarations.get(decl.node).set(ngModule, declData);
            }
            else if (this.declarationToModule.has(decl.node) &&
                this.declarationToModule.get(decl.node).ngModule !== ngModule) {
                // This directive/pipe is already registered as declared in another module. Mark it as a
                // duplicate instead.
                const duplicateDeclMap = new Map();
                const firstDeclData = this.declarationToModule.get(decl.node);
                // Mark both modules as tainted, since their declarations are missing a component.
                this.taintedModules.add(firstDeclData.ngModule);
                this.taintedModules.add(ngModule);
                // Being detected as a duplicate means there are two NgModules (for now) which declare this
                // directive/pipe. Add both of them to the duplicate tracking map.
                duplicateDeclMap.set(firstDeclData.ngModule, firstDeclData);
                duplicateDeclMap.set(ngModule, declData);
                this.duplicateDeclarations.set(decl.node, duplicateDeclMap);
                // Remove the directive/pipe from `declarationToModule` as it's a duplicate declaration, and
                // therefore not valid.
                this.declarationToModule.delete(decl.node);
            }
            else {
                // This is the first declaration of this directive/pipe, so map it.
                this.declarationToModule.set(decl.node, declData);
            }
        }
        /**
         * Implementation of `getScopeOfModule` which accepts a reference to a class and differentiates
         * between:
         *
         * * no scope being available (returns `null`)
         * * a scope being produced with errors (returns `undefined`).
         */
        getScopeOfModuleReference(ref) {
            if (this.cache.has(ref.node)) {
                return this.cache.get(ref.node);
            }
            // Seal the registry to protect the integrity of the `LocalModuleScope` cache.
            this.sealed = true;
            // `ref` should be an NgModule previously added to the registry. If not, a scope for it
            // cannot be produced.
            const ngModule = this.localReader.getNgModuleMetadata(ref);
            if (ngModule === null) {
                this.cache.set(ref.node, null);
                return null;
            }
            // Modules which contributed to the compilation scope of this module.
            const compilationModules = new Set([ngModule.ref.node]);
            // Modules which contributed to the export scope of this module.
            const exportedModules = new Set([ngModule.ref.node]);
            // Errors produced during computation of the scope are recorded here. At the end, if this array
            // isn't empty then `undefined` will be cached and returned to indicate this scope is invalid.
            const diagnostics = [];
            // At this point, the goal is to produce two distinct transitive sets:
            // - the directives and pipes which are visible to components declared in the NgModule.
            // - the directives and pipes which are exported to any NgModules which import this one.
            // Directives and pipes in the compilation scope.
            const compilationDirectives = new Map();
            const compilationPipes = new Map();
            const declared = new Set();
            // Directives and pipes exported to any importing NgModules.
            const exportDirectives = new Map();
            const exportPipes = new Map();
            // The algorithm is as follows:
            // 1) Add all of the directives/pipes from each NgModule imported into the current one to the
            //    compilation scope.
            // 2) Add directives/pipes declared in the NgModule to the compilation scope. At this point, the
            //    compilation scope is complete.
            // 3) For each entry in the NgModule's exports:
            //    a) Attempt to resolve it as an NgModule with its own exported directives/pipes. If it is
            //       one, add them to the export scope of this NgModule.
            //    b) Otherwise, it should be a class in the compilation scope of this NgModule. If it is,
            //       add it to the export scope.
            //    c) If it's neither an NgModule nor a directive/pipe in the compilation scope, then this
            //       is an error.
            // 1) process imports.
            for (const decl of ngModule.imports) {
                const importScope = this.getExportedScope(decl, diagnostics, ref.node, 'import');
                if (importScope === null) {
                    // An import wasn't an NgModule, so record an error.
                    diagnostics.push(invalidRef(ref.node, decl, 'import'));
                    continue;
                }
                else if (importScope === undefined) {
                    // An import was an NgModule but contained errors of its own. Record this as an error too,
                    // because this scope is always going to be incorrect if one of its imports could not be
                    // read.
                    diagnostics.push(invalidTransitiveNgModuleRef(ref.node, decl, 'import'));
                    continue;
                }
                for (const directive of importScope.exported.directives) {
                    compilationDirectives.set(directive.ref.node, directive);
                }
                for (const pipe of importScope.exported.pipes) {
                    compilationPipes.set(pipe.ref.node, pipe);
                }
                for (const importedModule of importScope.exported.ngModules) {
                    compilationModules.add(importedModule);
                }
            }
            // 2) add declarations.
            for (const decl of ngModule.declarations) {
                const directive = this.localReader.getDirectiveMetadata(decl);
                const pipe = this.localReader.getPipeMetadata(decl);
                if (directive !== null) {
                    compilationDirectives.set(decl.node, Object.assign(Object.assign({}, directive), { ref: decl }));
                }
                else if (pipe !== null) {
                    compilationPipes.set(decl.node, Object.assign(Object.assign({}, pipe), { ref: decl }));
                }
                else {
                    this.taintedModules.add(ngModule.ref.node);
                    const errorNode = decl.getOriginForDiagnostics(ngModule.rawDeclarations);
                    diagnostics.push(makeDiagnostic(ErrorCode.NGMODULE_INVALID_DECLARATION, errorNode, `The class '${decl.node.name.text}' is listed in the declarations ` +
                        `of the NgModule '${ngModule.ref.node.name
                        .text}', but is not a directive, a component, or a pipe. ` +
                        `Either remove it from the NgModule's declarations, or add an appropriate Angular decorator.`, [makeRelatedInformation(decl.node.name, `'${decl.node.name.text}' is declared here.`)]));
                    continue;
                }
                declared.add(decl.node);
            }
            // 3) process exports.
            // Exports can contain modules, components, or directives. They're processed differently.
            // Modules are straightforward. Directives and pipes from exported modules are added to the
            // export maps. Directives/pipes are different - they might be exports of declared types or
            // imported types.
            for (const decl of ngModule.exports) {
                // Attempt to resolve decl as an NgModule.
                const importScope = this.getExportedScope(decl, diagnostics, ref.node, 'export');
                if (importScope === undefined) {
                    // An export was an NgModule but contained errors of its own. Record this as an error too,
                    // because this scope is always going to be incorrect if one of its exports could not be
                    // read.
                    diagnostics.push(invalidTransitiveNgModuleRef(ref.node, decl, 'export'));
                    continue;
                }
                else if (importScope !== null) {
                    // decl is an NgModule.
                    for (const directive of importScope.exported.directives) {
                        exportDirectives.set(directive.ref.node, directive);
                    }
                    for (const pipe of importScope.exported.pipes) {
                        exportPipes.set(pipe.ref.node, pipe);
                    }
                    for (const exportedModule of importScope.exported.ngModules) {
                        exportedModules.add(exportedModule);
                    }
                }
                else if (compilationDirectives.has(decl.node)) {
                    // decl is a directive or component in the compilation scope of this NgModule.
                    const directive = compilationDirectives.get(decl.node);
                    exportDirectives.set(decl.node, directive);
                }
                else if (compilationPipes.has(decl.node)) {
                    // decl is a pipe in the compilation scope of this NgModule.
                    const pipe = compilationPipes.get(decl.node);
                    exportPipes.set(decl.node, pipe);
                }
                else {
                    // decl is an unknown export.
                    if (this.localReader.getDirectiveMetadata(decl) !== null ||
                        this.localReader.getPipeMetadata(decl) !== null) {
                        diagnostics.push(invalidReexport(ref.node, decl));
                    }
                    else {
                        diagnostics.push(invalidRef(ref.node, decl, 'export'));
                    }
                    continue;
                }
            }
            const exported = {
                directives: Array.from(exportDirectives.values()),
                pipes: Array.from(exportPipes.values()),
                ngModules: Array.from(exportedModules),
            };
            const reexports = this.getReexports(ngModule, ref, declared, exported, diagnostics);
            // Check if this scope had any errors during production.
            if (diagnostics.length > 0) {
                // Cache undefined, to mark the fact that the scope is invalid.
                this.cache.set(ref.node, undefined);
                // Save the errors for retrieval.
                this.scopeErrors.set(ref.node, diagnostics);
                // Mark this module as being tainted.
                this.taintedModules.add(ref.node);
                return undefined;
            }
            // Finally, produce the `LocalModuleScope` with both the compilation and export scopes.
            const scope = {
                compilation: {
                    directives: Array.from(compilationDirectives.values()),
                    pipes: Array.from(compilationPipes.values()),
                    ngModules: Array.from(compilationModules),
                },
                exported,
                reexports,
                schemas: ngModule.schemas,
            };
            this.cache.set(ref.node, scope);
            return scope;
        }
        /**
         * Check whether a component requires remote scoping.
         */
        getRequiresRemoteScope(node) {
            return this.remoteScoping.has(node);
        }
        /**
         * Set a component as requiring remote scoping.
         */
        setComponentAsRequiringRemoteScoping(node) {
            this.remoteScoping.add(node);
        }
        /**
         * Look up the `ExportScope` of a given `Reference` to an NgModule.
         *
         * The NgModule in question may be declared locally in the current ts.Program, or it may be
         * declared in a .d.ts file.
         *
         * @returns `null` if no scope could be found, or `undefined` if an invalid scope
         * was found.
         *
         * May also contribute diagnostics of its own by adding to the given `diagnostics`
         * array parameter.
         */
        getExportedScope(ref, diagnostics, ownerForErrors, type) {
            if (ref.node.getSourceFile().isDeclarationFile) {
                // The NgModule is declared in a .d.ts file. Resolve it with the `DependencyScopeReader`.
                if (!ts.isClassDeclaration(ref.node)) {
                    // The NgModule is in a .d.ts file but is not declared as a ts.ClassDeclaration. This is an
                    // error in the .d.ts metadata.
                    const code = type === 'import' ? ErrorCode.NGMODULE_INVALID_IMPORT :
                        ErrorCode.NGMODULE_INVALID_EXPORT;
                    diagnostics.push(makeDiagnostic(code, identifierOfNode(ref.node) || ref.node, `Appears in the NgModule.${type}s of ${nodeNameForError(ownerForErrors)}, but could not be resolved to an NgModule`));
                    return undefined;
                }
                return this.dependencyScopeReader.resolve(ref);
            }
            else {
                // The NgModule is declared locally in the current program. Resolve it from the registry.
                return this.getScopeOfModuleReference(ref);
            }
        }
        getReexports(ngModule, ref, declared, exported, diagnostics) {
            let reexports = null;
            const sourceFile = ref.node.getSourceFile();
            if (this.aliasingHost === null) {
                return null;
            }
            reexports = [];
            // Track re-exports by symbol name, to produce diagnostics if two alias re-exports would share
            // the same name.
            const reexportMap = new Map();
            // Alias ngModuleRef added for readability below.
            const ngModuleRef = ref;
            const addReexport = (exportRef) => {
                if (exportRef.node.getSourceFile() === sourceFile) {
                    return;
                }
                const isReExport = !declared.has(exportRef.node);
                const exportName = this.aliasingHost.maybeAliasSymbolAs(exportRef, sourceFile, ngModule.ref.node.name.text, isReExport);
                if (exportName === null) {
                    return;
                }
                if (!reexportMap.has(exportName)) {
                    if (exportRef.alias && exportRef.alias instanceof ExternalExpr) {
                        reexports.push({
                            fromModule: exportRef.alias.value.moduleName,
                            symbolName: exportRef.alias.value.name,
                            asAlias: exportName,
                        });
                    }
                    else {
                        const expr = this.refEmitter.emit(exportRef.cloneWithNoIdentifiers(), sourceFile);
                        if (!(expr instanceof ExternalExpr) || expr.value.moduleName === null ||
                            expr.value.name === null) {
                            throw new Error('Expected ExternalExpr');
                        }
                        reexports.push({
                            fromModule: expr.value.moduleName,
                            symbolName: expr.value.name,
                            asAlias: exportName,
                        });
                    }
                    reexportMap.set(exportName, exportRef);
                }
                else {
                    // Another re-export already used this name. Produce a diagnostic.
                    const prevRef = reexportMap.get(exportName);
                    diagnostics.push(reexportCollision(ngModuleRef.node, prevRef, exportRef));
                }
            };
            for (const { ref } of exported.directives) {
                addReexport(ref);
            }
            for (const { ref } of exported.pipes) {
                addReexport(ref);
            }
            return reexports;
        }
        assertCollecting() {
            if (this.sealed) {
                throw new Error(`Assertion: LocalModuleScopeRegistry is not COLLECTING`);
            }
        }
    }
    /**
     * Produce a `ts.Diagnostic` for an invalid import or export from an NgModule.
     */
    function invalidRef(clazz, decl, type) {
        const code = type === 'import' ? ErrorCode.NGMODULE_INVALID_IMPORT : ErrorCode.NGMODULE_INVALID_EXPORT;
        const resolveTarget = type === 'import' ? 'NgModule' : 'NgModule, Component, Directive, or Pipe';
        let message = `Appears in the NgModule.${type}s of ${nodeNameForError(clazz)}, but could not be resolved to an ${resolveTarget} class.` +
            '\n\n';
        const library = decl.ownedByModuleGuess !== null ? ` (${decl.ownedByModuleGuess})` : '';
        const sf = decl.node.getSourceFile();
        // Provide extra context to the error for the user.
        if (!sf.isDeclarationFile) {
            // This is a file in the user's program.
            const annotationType = type === 'import' ? '@NgModule' : 'Angular';
            message += `Is it missing an ${annotationType} annotation?`;
        }
        else if (sf.fileName.indexOf('node_modules') !== -1) {
            // This file comes from a third-party library in node_modules.
            message +=
                `This likely means that the library${library} which declares ${decl.debugName} has not ` +
                    'been processed correctly by ngcc, or is not compatible with Angular Ivy. Check if a ' +
                    'newer version of the library is available, and update if so. Also consider checking ' +
                    'with the library\'s authors to see if the library is expected to be compatible with Ivy.';
        }
        else {
            // This is a monorepo style local dependency. Unfortunately these are too different to really
            // offer much moreadvice than this.
            message += `This likely means that the dependency${library} which declares ${decl.debugName} has not been processed correctly by ngcc.`;
        }
        return makeDiagnostic(code, identifierOfNode(decl.node) || decl.node, message);
    }
    /**
     * Produce a `ts.Diagnostic` for an import or export which itself has errors.
     */
    function invalidTransitiveNgModuleRef(clazz, decl, type) {
        const code = type === 'import' ? ErrorCode.NGMODULE_INVALID_IMPORT : ErrorCode.NGMODULE_INVALID_EXPORT;
        return makeDiagnostic(code, identifierOfNode(decl.node) || decl.node, `Appears in the NgModule.${type}s of ${nodeNameForError(clazz)}, but itself has errors`);
    }
    /**
     * Produce a `ts.Diagnostic` for an exported directive or pipe which was not declared or imported
     * by the NgModule in question.
     */
    function invalidReexport(clazz, decl) {
        return makeDiagnostic(ErrorCode.NGMODULE_INVALID_REEXPORT, identifierOfNode(decl.node) || decl.node, `Present in the NgModule.exports of ${nodeNameForError(clazz)} but neither declared nor imported`);
    }
    /**
     * Produce a `ts.Diagnostic` for a collision in re-export names between two directives/pipes.
     */
    function reexportCollision(module, refA, refB) {
        const childMessageText = `This directive/pipe is part of the exports of '${module.name.text}' and shares the same name as another exported directive/pipe.`;
        return makeDiagnostic(ErrorCode.NGMODULE_REEXPORT_NAME_COLLISION, module.name, `
    There was a name collision between two classes named '${refA.node.name.text}', which are both part of the exports of '${module.name.text}'.

    Angular generates re-exports of an NgModule's exported directives/pipes from the module's source file in certain cases, using the declared name of the class. If two classes of the same name are exported, this automatic naming does not work.

    To fix this problem please re-export one or both classes directly from this file.
  `.trim(), [
            makeRelatedInformation(refA.node.name, childMessageText),
            makeRelatedInformation(refB.node.name, childMessageText),
        ]);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A `Symbol` which is used to patch extension data onto `ts.SourceFile`s.
     */
    const NgExtension = Symbol('NgExtension');
    /**
     * Narrows a `ts.SourceFile` if it has an `NgExtension` property.
     */
    function isExtended(sf) {
        return sf[NgExtension] !== undefined;
    }
    /**
     * Check whether `sf` is a shim `ts.SourceFile` (either a per-file shim or a top-level shim).
     */
    function isShim(sf) {
        return isExtended(sf) && (sf[NgExtension].fileShim !== null || sf[NgExtension].isTopLevelShim);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const STRIP_NG_FACTORY = /(.*)NgFactory$/;
    function generatedFactoryTransform(factoryMap, importRewriter) {
        return (context) => {
            return (file) => {
                return transformFactorySourceFile(factoryMap, context, importRewriter, file);
            };
        };
    }
    function transformFactorySourceFile(factoryMap, context, importRewriter, file) {
        // If this is not a generated file, it won't have factory info associated with it.
        if (!factoryMap.has(file.fileName)) {
            // Don't transform non-generated code.
            return file;
        }
        const { moduleSymbols, sourceFilePath } = factoryMap.get(file.fileName);
        file = ts.getMutableClone(file);
        // Not every exported factory statement is valid. They were generated before the program was
        // analyzed, and before ngtsc knew which symbols were actually NgModules. factoryMap contains
        // that knowledge now, so this transform filters the statement list and removes exported factories
        // that aren't actually factories.
        //
        // This could leave the generated factory file empty. To prevent this (it causes issues with
        // closure compiler) a 'NonEmptyModule' export was added when the factory shim was created.
        // Preserve that export if needed, and remove it otherwise.
        //
        // Additionally, an import to @angular/core is generated, but the current compilation unit could
        // actually be @angular/core, in which case such an import is invalid and should be replaced with
        // the proper path to access Ivy symbols in core.
        // The filtered set of statements.
        const transformedStatements = [];
        // The statement identified as the NonEmptyModule export.
        let nonEmptyExport = null;
        // Extracted identifiers which refer to import statements from @angular/core.
        const coreImportIdentifiers = new Set();
        // Consider all the statements.
        for (const stmt of file.statements) {
            // Look for imports to @angular/core.
            if (ts.isImportDeclaration(stmt) && ts.isStringLiteral(stmt.moduleSpecifier) &&
                stmt.moduleSpecifier.text === '@angular/core') {
                // Update the import path to point to the correct file using the ImportRewriter.
                const rewrittenModuleSpecifier = importRewriter.rewriteSpecifier('@angular/core', sourceFilePath);
                if (rewrittenModuleSpecifier !== stmt.moduleSpecifier.text) {
                    transformedStatements.push(ts.updateImportDeclaration(stmt, stmt.decorators, stmt.modifiers, stmt.importClause, ts.createStringLiteral(rewrittenModuleSpecifier)));
                    // Record the identifier by which this imported module goes, so references to its symbols
                    // can be discovered later.
                    if (stmt.importClause !== undefined && stmt.importClause.namedBindings !== undefined &&
                        ts.isNamespaceImport(stmt.importClause.namedBindings)) {
                        coreImportIdentifiers.add(stmt.importClause.namedBindings.name.text);
                    }
                }
                else {
                    transformedStatements.push(stmt);
                }
            }
            else if (ts.isVariableStatement(stmt) && stmt.declarationList.declarations.length === 1) {
                const decl = stmt.declarationList.declarations[0];
                // If this is the NonEmptyModule export, then save it for later.
                if (ts.isIdentifier(decl.name)) {
                    if (decl.name.text === 'NonEmptyModule') {
                        nonEmptyExport = stmt;
                        continue;
                    }
                    // Otherwise, check if this export is a factory for a known NgModule, and retain it if so.
                    const match = STRIP_NG_FACTORY.exec(decl.name.text);
                    const module = match ? moduleSymbols.get(match[1]) : null;
                    if (module) {
                        // If the module can be tree shaken, then the factory should be wrapped in a
                        // `noSideEffects()` call which tells Closure to treat the expression as pure, allowing
                        // it to be removed if the result is not used.
                        //
                        // `NgModule`s with an `id` property will be lazy loaded. Google-internal lazy loading
                        // infra relies on a side effect from the `new NgModuleFactory()` call, which registers
                        // the module globally. Because of this, we **cannot** tree shake any module which has
                        // an `id` property. Doing so would cause lazy loaded modules to never be registered.
                        const moduleIsTreeShakable = !module.hasId;
                        const newStmt = !moduleIsTreeShakable ?
                            stmt :
                            updateInitializers(stmt, (init) => init ? wrapInNoSideEffects(init) : undefined);
                        transformedStatements.push(newStmt);
                    }
                }
                else {
                    // Leave the statement alone, as it can't be understood.
                    transformedStatements.push(stmt);
                }
            }
            else {
                // Include non-variable statements (imports, etc).
                transformedStatements.push(stmt);
            }
        }
        // Check whether the empty module export is still needed.
        if (!transformedStatements.some(ts.isVariableStatement) && nonEmptyExport !== null) {
            // If the resulting file has no factories, include an empty export to
            // satisfy closure compiler.
            transformedStatements.push(nonEmptyExport);
        }
        file.statements = ts.createNodeArray(transformedStatements);
        // If any imports to @angular/core were detected and rewritten (which happens when compiling
        // @angular/core), go through the SourceFile and rewrite references to symbols imported from core.
        if (coreImportIdentifiers.size > 0) {
            const visit = (node) => {
                node = ts.visitEachChild(node, child => visit(child), context);
                // Look for expressions of the form "i.s" where 'i' is a detected name for an @angular/core
                // import that was changed above. Rewrite 's' using the ImportResolver.
                if (ts.isPropertyAccessExpression(node) && ts.isIdentifier(node.expression) &&
                    coreImportIdentifiers.has(node.expression.text)) {
                    // This is an import of a symbol from @angular/core. Transform it with the importRewriter.
                    const rewrittenSymbol = importRewriter.rewriteSymbol(node.name.text, '@angular/core');
                    if (rewrittenSymbol !== node.name.text) {
                        const updated = ts.updatePropertyAccess(node, node.expression, ts.createIdentifier(rewrittenSymbol));
                        node = updated;
                    }
                }
                return node;
            };
            file = visit(file);
        }
        return file;
    }
    /**
     * Wraps the given expression in a call to `noSideEffects()`, which tells
     * Closure we don't care about the side effects of this expression and it should
     * be treated as "pure". Closure is free to tree shake this expression if its
     * result is not used.
     *
     * Example: Takes `1 + 2` and returns `i0.noSideEffects(() => 1 + 2)`.
     */
    function wrapInNoSideEffects(expr) {
        const noSideEffects = ts.createPropertyAccess(ts.createIdentifier('i0'), 'noSideEffects');
        return ts.createCall(noSideEffects, 
        /* typeArguments */ [], 
        /* arguments */
        [
            ts.createFunctionExpression(
            /* modifiers */ [], 
            /* asteriskToken */ undefined, 
            /* name */ undefined, 
            /* typeParameters */ [], 
            /* parameters */ [], 
            /* type */ undefined, 
            /* body */ ts.createBlock([
                ts.createReturn(expr),
            ])),
        ]);
    }
    /**
     * Clones and updates the initializers for a given statement to use the new
     * expression provided. Does not mutate the input statement.
     */
    function updateInitializers(stmt, update) {
        return ts.updateVariableStatement(stmt, stmt.modifiers, ts.updateVariableDeclarationList(stmt.declarationList, stmt.declarationList.declarations.map((decl) => ts.updateVariableDeclaration(decl, decl.name, decl.type, update(decl.initializer)))));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const IVY_SWITCH_PRE_SUFFIX = '__PRE_R3__';
    const IVY_SWITCH_POST_SUFFIX = '__POST_R3__';
    function ivySwitchTransform(_) {
        return flipIvySwitchInFile;
    }
    function flipIvySwitchInFile(sf) {
        // To replace the statements array, it must be copied. This only needs to happen if a statement
        // must actually be replaced within the array, so the newStatements array is lazily initialized.
        let newStatements = undefined;
        // Iterate over the statements in the file.
        for (let i = 0; i < sf.statements.length; i++) {
            const statement = sf.statements[i];
            // Skip over everything that isn't a variable statement.
            if (!ts.isVariableStatement(statement) || !hasIvySwitches(statement)) {
                continue;
            }
            // This statement needs to be replaced. Check if the newStatements array needs to be lazily
            // initialized to a copy of the original statements.
            if (newStatements === undefined) {
                newStatements = [...sf.statements];
            }
            // Flip any switches in the VariableStatement. If there were any, a new statement will be
            // returned; otherwise the old statement will be.
            newStatements[i] = flipIvySwitchesInVariableStatement(statement, sf.statements);
        }
        // Only update the statements in the SourceFile if any have changed.
        if (newStatements !== undefined) {
            sf = ts.getMutableClone(sf);
            sf.statements = ts.createNodeArray(newStatements);
        }
        return sf;
    }
    /**
     * Look for the ts.Identifier of a ts.Declaration with this name.
     *
     * The real identifier is needed (rather than fabricating one) as TypeScript decides how to
     * reference this identifier based on information stored against its node in the AST, which a
     * synthetic node would not have. In particular, since the post-switch variable is often exported,
     * TypeScript needs to know this so it can write `exports.VAR` instead of just `VAR` when emitting
     * code.
     *
     * Only variable, function, and class declarations are currently searched.
     */
    function findPostSwitchIdentifier(statements, name) {
        for (const stmt of statements) {
            if (ts.isVariableStatement(stmt)) {
                const decl = stmt.declarationList.declarations.find(decl => ts.isIdentifier(decl.name) && decl.name.text === name);
                if (decl !== undefined) {
                    return decl.name;
                }
            }
            else if (ts.isFunctionDeclaration(stmt) || ts.isClassDeclaration(stmt)) {
                if (stmt.name !== undefined && ts.isIdentifier(stmt.name) && stmt.name.text === name) {
                    return stmt.name;
                }
            }
        }
        return null;
    }
    /**
     * Flip any Ivy switches which are discovered in the given ts.VariableStatement.
     */
    function flipIvySwitchesInVariableStatement(stmt, statements) {
        // Build a new list of variable declarations. Specific declarations that are initialized to a
        // pre-switch identifier will be replaced with a declaration initialized to the post-switch
        // identifier.
        const newDeclarations = [...stmt.declarationList.declarations];
        for (let i = 0; i < newDeclarations.length; i++) {
            const decl = newDeclarations[i];
            // Skip declarations that aren't initialized to an identifier.
            if (decl.initializer === undefined || !ts.isIdentifier(decl.initializer)) {
                continue;
            }
            // Skip declarations that aren't Ivy switches.
            if (!decl.initializer.text.endsWith(IVY_SWITCH_PRE_SUFFIX)) {
                continue;
            }
            // Determine the name of the post-switch variable.
            const postSwitchName = decl.initializer.text.replace(IVY_SWITCH_PRE_SUFFIX, IVY_SWITCH_POST_SUFFIX);
            // Find the post-switch variable identifier. If one can't be found, it's an error. This is
            // reported as a thrown error and not a diagnostic as transformers cannot output diagnostics.
            let newIdentifier = findPostSwitchIdentifier(statements, postSwitchName);
            if (newIdentifier === null) {
                throw new Error(`Unable to find identifier ${postSwitchName} in ${stmt.getSourceFile().fileName} for the Ivy switch.`);
            }
            // Copy the identifier with updateIdentifier(). This copies the internal information which
            // allows TS to write a correct reference to the identifier.
            newIdentifier = ts.updateIdentifier(newIdentifier);
            newDeclarations[i] = ts.updateVariableDeclaration(
            /* node */ decl, 
            /* name */ decl.name, 
            /* type */ decl.type, 
            /* initializer */ newIdentifier);
        }
        const newDeclList = ts.updateVariableDeclarationList(
        /* declarationList */ stmt.declarationList, 
        /* declarations */ newDeclarations);
        const newStmt = ts.updateVariableStatement(
        /* statement */ stmt, 
        /* modifiers */ stmt.modifiers, 
        /* declarationList */ newDeclList);
        return newStmt;
    }
    /**
     * Check whether the given VariableStatement has any Ivy switch variables.
     */
    function hasIvySwitches(stmt) {
        return stmt.declarationList.declarations.some(decl => decl.initializer !== undefined && ts.isIdentifier(decl.initializer) &&
            decl.initializer.text.endsWith(IVY_SWITCH_PRE_SUFFIX));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var UpdateMode;
    (function (UpdateMode) {
        /**
         * A complete update creates a completely new overlay of type-checking code on top of the user's
         * original program, which doesn't include type-checking code from previous calls to
         * `updateFiles`.
         */
        UpdateMode[UpdateMode["Complete"] = 0] = "Complete";
        /**
         * An incremental update changes the contents of some files in the type-checking program without
         * reverting any prior changes.
         */
        UpdateMode[UpdateMode["Incremental"] = 1] = "Incremental";
    })(UpdateMode || (UpdateMode = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Describes the scope of the caller's interest in template type-checking results.
     */
    var OptimizeFor;
    (function (OptimizeFor) {
        /**
         * Indicates that a consumer of a `TemplateTypeChecker` is only interested in results for a given
         * file, and wants them as fast as possible.
         *
         * Calling `TemplateTypeChecker` methods successively for multiple files while specifying
         * `OptimizeFor.SingleFile` can result in significant unnecessary overhead overall.
         */
        OptimizeFor[OptimizeFor["SingleFile"] = 0] = "SingleFile";
        /**
         * Indicates that a consumer of a `TemplateTypeChecker` intends to query for results pertaining to
         * the entire user program, and so the type-checker should internally optimize for this case.
         *
         * Initial calls to retrieve type-checking information may take longer, but repeated calls to
         * gather information for the whole user program will be significantly faster with this mode of
         * optimization.
         */
        OptimizeFor[OptimizeFor["WholeProgram"] = 1] = "WholeProgram";
    })(OptimizeFor || (OptimizeFor = {}));

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A `ShimGenerator` which adds type-checking files to the `ts.Program`.
     *
     * This is a requirement for performant template type-checking, as TypeScript will only reuse
     * information in the main program when creating the type-checking program if the set of files in
     * each are exactly the same. Thus, the main program also needs the synthetic type-checking files.
     */
    class TypeCheckShimGenerator {
        constructor() {
            this.extensionPrefix = 'ngtypecheck';
            this.shouldEmit = false;
        }
        generateShimForFile(sf, genFilePath, priorShimSf) {
            if (priorShimSf !== null) {
                // If this shim existed in the previous program, reuse it now. It might not be correct, but
                // reusing it in the main program allows the shape of its imports to potentially remain the
                // same and TS can then use the fastest path for incremental program creation. Later during
                // the type-checking phase it's going to either be reused, or replaced anyways. Thus there's
                // no harm in reuse here even if it's out of date.
                return priorShimSf;
            }
            return ts.createSourceFile(genFilePath, 'export const USED_FOR_NG_TYPE_CHECKING = true;', ts.ScriptTarget.Latest, true, ts.ScriptKind.TS);
        }
        static shimFor(fileName) {
            return absoluteFrom(fileName.replace(/\.tsx?$/, '.ngtypecheck.ts'));
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Wraps the node in parenthesis such that inserted span comments become attached to the proper
     * node. This is an alias for `ts.createParen` with the benefit that it signifies that the
     * inserted parenthesis are for diagnostic purposes, not for correctness of the rendered TCB code.
     *
     * Note that it is important that nodes and its attached comment are not wrapped into parenthesis
     * by default, as it prevents correct translation of e.g. diagnostics produced for incorrect method
     * arguments. Such diagnostics would then be produced for the parenthesised node whereas the
     * positional comment would be located within that node, resulting in a mismatch.
     */
    function wrapForDiagnostics(expr) {
        return ts.createParen(expr);
    }
    const IGNORE_MARKER = 'ignore';
    /**
     * Adds a marker to the node that signifies that any errors within the node should not be reported.
     */
    function ignoreDiagnostics(node) {
        ts.addSyntheticTrailingComment(node, ts.SyntaxKind.MultiLineCommentTrivia, IGNORE_MARKER, /* hasTrailingNewLine */ false);
    }
    /**
     * Adds a synthetic comment to the expression that represents the parse span of the provided node.
     * This comment can later be retrieved as trivia of a node to recover original source locations.
     */
    function addParseSpanInfo(node, span) {
        let commentText;
        if (span instanceof AbsoluteSourceSpan) {
            commentText = `${span.start},${span.end}`;
        }
        else {
            commentText = `${span.start.offset},${span.end.offset}`;
        }
        ts.addSyntheticTrailingComment(node, ts.SyntaxKind.MultiLineCommentTrivia, commentText, /* hasTrailingNewLine */ false);
    }
    /**
     * Adds a synthetic comment to the function declaration that contains the template id
     * of the class declaration.
     */
    function addTemplateId(tcb, id) {
        ts.addSyntheticLeadingComment(tcb, ts.SyntaxKind.MultiLineCommentTrivia, id, true);
    }
    /**
     * Determines if the diagnostic should be reported. Some diagnostics are produced because of the
     * way TCBs are generated; those diagnostics should not be reported as type check errors of the
     * template.
     */
    function shouldReportDiagnostic(diagnostic) {
        const { code } = diagnostic;
        if (code === 6133 /* $var is declared but its value is never read. */) {
            return false;
        }
        else if (code === 6199 /* All variables are unused. */) {
            return false;
        }
        else if (code === 2695 /* Left side of comma operator is unused and has no side effects. */) {
            return false;
        }
        else if (code === 7006 /* Parameter '$event' implicitly has an 'any' type. */) {
            return false;
        }
        return true;
    }
    /**
     * Attempts to translate a TypeScript diagnostic produced during template type-checking to their
     * location of origin, based on the comments that are emitted in the TCB code.
     *
     * If the diagnostic could not be translated, `null` is returned to indicate that the diagnostic
     * should not be reported at all. This prevents diagnostics from non-TCB code in a user's source
     * file from being reported as type-check errors.
     */
    function translateDiagnostic(diagnostic, resolver) {
        if (diagnostic.file === undefined || diagnostic.start === undefined) {
            return null;
        }
        // Locate the node that the diagnostic is reported on and determine its location in the source.
        const node = getTokenAtPosition(diagnostic.file, diagnostic.start);
        const sourceLocation = findSourceLocation(node, diagnostic.file);
        if (sourceLocation === null) {
            return null;
        }
        // Now use the external resolver to obtain the full `ParseSourceFile` of the template.
        const span = resolver.toParseSourceSpan(sourceLocation.id, sourceLocation.span);
        if (span === null) {
            return null;
        }
        const mapping = resolver.getSourceMapping(sourceLocation.id);
        return makeTemplateDiagnostic(sourceLocation.id, mapping, span, diagnostic.category, diagnostic.code, diagnostic.messageText);
    }
    function findTypeCheckBlock(file, id) {
        for (const stmt of file.statements) {
            if (ts.isFunctionDeclaration(stmt) && getTemplateId(stmt, file) === id) {
                return stmt;
            }
        }
        return null;
    }
    /**
     * Constructs a `ts.Diagnostic` for a given `ParseSourceSpan` within a template.
     */
    function makeTemplateDiagnostic(templateId, mapping, span, category, code, messageText, relatedMessage) {
        if (mapping.type === 'direct') {
            let relatedInformation = undefined;
            if (relatedMessage !== undefined) {
                relatedInformation = [{
                        category: ts.DiagnosticCategory.Message,
                        code: 0,
                        file: mapping.node.getSourceFile(),
                        start: relatedMessage.span.start.offset,
                        length: relatedMessage.span.end.offset - relatedMessage.span.start.offset,
                        messageText: relatedMessage.text,
                    }];
            }
            // For direct mappings, the error is shown inline as ngtsc was able to pinpoint a string
            // constant within the `@Component` decorator for the template. This allows us to map the error
            // directly into the bytes of the source file.
            return {
                source: 'ngtsc',
                code,
                category,
                messageText,
                file: mapping.node.getSourceFile(),
                componentFile: mapping.node.getSourceFile(),
                templateId,
                start: span.start.offset,
                length: span.end.offset - span.start.offset,
                relatedInformation,
            };
        }
        else if (mapping.type === 'indirect' || mapping.type === 'external') {
            // For indirect mappings (template was declared inline, but ngtsc couldn't map it directly
            // to a string constant in the decorator), the component's file name is given with a suffix
            // indicating it's not the TS file being displayed, but a template.
            // For external temoplates, the HTML filename is used.
            const componentSf = mapping.componentClass.getSourceFile();
            const componentName = mapping.componentClass.name.text;
            // TODO(alxhub): remove cast when TS in g3 supports this narrowing.
            const fileName = mapping.type === 'indirect' ?
                `${componentSf.fileName} (${componentName} template)` :
                mapping.templateUrl;
            // TODO(alxhub): investigate creating a fake `ts.SourceFile` here instead of invoking the TS
            // parser against the template (HTML is just really syntactically invalid TypeScript code ;).
            // Also investigate caching the file to avoid running the parser multiple times.
            const sf = ts.createSourceFile(fileName, mapping.template, ts.ScriptTarget.Latest, false, ts.ScriptKind.JSX);
            let relatedInformation = [];
            if (relatedMessage !== undefined) {
                relatedInformation.push({
                    category: ts.DiagnosticCategory.Message,
                    code: 0,
                    file: sf,
                    start: relatedMessage.span.start.offset,
                    length: relatedMessage.span.end.offset - relatedMessage.span.start.offset,
                    messageText: relatedMessage.text,
                });
            }
            relatedInformation.push({
                category: ts.DiagnosticCategory.Message,
                code: 0,
                file: componentSf,
                // mapping.node represents either the 'template' or 'templateUrl' expression. getStart()
                // and getEnd() are used because they don't include surrounding whitespace.
                start: mapping.node.getStart(),
                length: mapping.node.getEnd() - mapping.node.getStart(),
                messageText: `Error occurs in the template of component ${componentName}.`,
            });
            return {
                source: 'ngtsc',
                category,
                code,
                messageText,
                file: sf,
                componentFile: componentSf,
                templateId,
                start: span.start.offset,
                length: span.end.offset - span.start.offset,
                // Show a secondary message indicating the component whose template contains the error.
                relatedInformation,
            };
        }
        else {
            throw new Error(`Unexpected source mapping type: ${mapping.type}`);
        }
    }
    /**
     * Traverses up the AST starting from the given node to extract the source location from comments
     * that have been emitted into the TCB. If the node does not exist within a TCB, or if an ignore
     * marker comment is found up the tree, this function returns null.
     */
    function findSourceLocation(node, sourceFile) {
        // Search for comments until the TCB's function declaration is encountered.
        while (node !== undefined && !ts.isFunctionDeclaration(node)) {
            if (hasIgnoreMarker(node, sourceFile)) {
                // There's an ignore marker on this node, so the diagnostic should not be reported.
                return null;
            }
            const span = readSpanComment(sourceFile, node);
            if (span !== null) {
                // Once the positional information has been extracted, search further up the TCB to extract
                // the unique id that is attached with the TCB's function declaration.
                const id = getTemplateId(node, sourceFile);
                if (id === null) {
                    return null;
                }
                return { id, span };
            }
            node = node.parent;
        }
        return null;
    }
    function getTemplateId(node, sourceFile) {
        // Walk up to the function declaration of the TCB, the file information is attached there.
        while (!ts.isFunctionDeclaration(node)) {
            if (hasIgnoreMarker(node, sourceFile)) {
                // There's an ignore marker on this node, so the diagnostic should not be reported.
                return null;
            }
            node = node.parent;
            // Bail once we have reached the root.
            if (node === undefined) {
                return null;
            }
        }
        const start = node.getFullStart();
        return ts.forEachLeadingCommentRange(sourceFile.text, start, (pos, end, kind) => {
            if (kind !== ts.SyntaxKind.MultiLineCommentTrivia) {
                return null;
            }
            const commentText = sourceFile.text.substring(pos + 2, end - 2);
            return commentText;
        }) || null;
    }
    const parseSpanComment = /^(\d+),(\d+)$/;
    function readSpanComment(sourceFile, node) {
        return ts.forEachTrailingCommentRange(sourceFile.text, node.getEnd(), (pos, end, kind) => {
            if (kind !== ts.SyntaxKind.MultiLineCommentTrivia) {
                return null;
            }
            const commentText = sourceFile.text.substring(pos + 2, end - 2);
            const match = commentText.match(parseSpanComment);
            if (match === null) {
                return null;
            }
            return new AbsoluteSourceSpan(+match[1], +match[2]);
        }) || null;
    }
    function hasIgnoreMarker(node, sourceFile) {
        return ts.forEachTrailingCommentRange(sourceFile.text, node.getEnd(), (pos, end, kind) => {
            if (kind !== ts.SyntaxKind.MultiLineCommentTrivia) {
                return null;
            }
            const commentText = sourceFile.text.substring(pos + 2, end - 2);
            return commentText === IGNORE_MARKER;
        }) === true;
    }
    function isTemplateDiagnostic(diagnostic) {
        return diagnostic.hasOwnProperty('componentFile') &&
            ts.isSourceFile(diagnostic.componentFile);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const REGISTRY = new DomElementSchemaRegistry();
    const REMOVE_XHTML_REGEX = /^:xhtml:/;
    /**
     * Checks non-Angular elements and properties against the `DomElementSchemaRegistry`, a schema
     * maintained by the Angular team via extraction from a browser IDL.
     */
    class RegistryDomSchemaChecker {
        constructor(resolver) {
            this.resolver = resolver;
            this._diagnostics = [];
        }
        get diagnostics() {
            return this._diagnostics;
        }
        checkElement(id, element, schemas) {
            // HTML elements inside an SVG `foreignObject` are declared in the `xhtml` namespace.
            // We need to strip it before handing it over to the registry because all HTML tag names
            // in the registry are without a namespace.
            const name = element.name.replace(REMOVE_XHTML_REGEX, '');
            if (!REGISTRY.hasElement(name, schemas)) {
                const mapping = this.resolver.getSourceMapping(id);
                let errorMsg = `'${name}' is not a known element:\n`;
                errorMsg +=
                    `1. If '${name}' is an Angular component, then verify that it is part of this module.\n`;
                if (name.indexOf('-') > -1) {
                    errorMsg += `2. If '${name}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.`;
                }
                else {
                    errorMsg +=
                        `2. To allow any element add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;
                }
                const diag = makeTemplateDiagnostic(id, mapping, element.sourceSpan, ts.DiagnosticCategory.Error, ngErrorCode(ErrorCode.SCHEMA_INVALID_ELEMENT), errorMsg);
                this._diagnostics.push(diag);
            }
        }
        checkProperty(id, element, name, span, schemas) {
            if (!REGISTRY.hasProperty(element.name, name, schemas)) {
                const mapping = this.resolver.getSourceMapping(id);
                let errorMsg = `Can't bind to '${name}' since it isn't a known property of '${element.name}'.`;
                if (element.name.startsWith('ng-')) {
                    errorMsg +=
                        `\n1. If '${name}' is an Angular directive, then add 'CommonModule' to the '@NgModule.imports' of this component.` +
                            `\n2. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;
                }
                else if (element.name.indexOf('-') > -1) {
                    errorMsg +=
                        `\n1. If '${element.name}' is an Angular component and it has '${name}' input, then verify that it is part of this module.` +
                            `\n2. If '${element
                            .name}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.` +
                            `\n3. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;
                }
                const diag = makeTemplateDiagnostic(id, mapping, span, ts.DiagnosticCategory.Error, ngErrorCode(ErrorCode.SCHEMA_INVALID_ATTRIBUTE), errorMsg);
                this._diagnostics.push(diag);
            }
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A `Set` of `ts.SyntaxKind`s of `ts.Expression` which are safe to wrap in a `ts.AsExpression`
     * without needing to be wrapped in parentheses.
     *
     * For example, `foo.bar()` is a `ts.CallExpression`, and can be safely cast to `any` with
     * `foo.bar() as any`. however, `foo !== bar` is a `ts.BinaryExpression`, and attempting to cast
     * without the parentheses yields the expression `foo !== bar as any`. This is semantically
     * equivalent to `foo !== (bar as any)`, which is not what was intended. Thus,
     * `ts.BinaryExpression`s need to be wrapped in parentheses before casting.
     */
    //
    const SAFE_TO_CAST_WITHOUT_PARENS = new Set([
        // Expressions which are already parenthesized can be cast without further wrapping.
        ts.SyntaxKind.ParenthesizedExpression,
        // Expressions which form a single lexical unit leave no room for precedence issues with the cast.
        ts.SyntaxKind.Identifier,
        ts.SyntaxKind.CallExpression,
        ts.SyntaxKind.NonNullExpression,
        ts.SyntaxKind.ElementAccessExpression,
        ts.SyntaxKind.PropertyAccessExpression,
        ts.SyntaxKind.ArrayLiteralExpression,
        ts.SyntaxKind.ObjectLiteralExpression,
        // The same goes for various literals.
        ts.SyntaxKind.StringLiteral,
        ts.SyntaxKind.NumericLiteral,
        ts.SyntaxKind.TrueKeyword,
        ts.SyntaxKind.FalseKeyword,
        ts.SyntaxKind.NullKeyword,
        ts.SyntaxKind.UndefinedKeyword,
    ]);
    function tsCastToAny(expr) {
        // Wrap `expr` in parentheses if needed (see `SAFE_TO_CAST_WITHOUT_PARENS` above).
        if (!SAFE_TO_CAST_WITHOUT_PARENS.has(expr.kind)) {
            expr = ts.createParen(expr);
        }
        // The outer expression is always wrapped in parentheses.
        return ts.createParen(ts.createAsExpression(expr, ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword)));
    }
    /**
     * Create an expression which instantiates an element by its HTML tagName.
     *
     * Thanks to narrowing of `document.createElement()`, this expression will have its type inferred
     * based on the tag name, including for custom elements that have appropriate .d.ts definitions.
     */
    function tsCreateElement(tagName) {
        const createElement = ts.createPropertyAccess(
        /* expression */ ts.createIdentifier('document'), 'createElement');
        return ts.createCall(
        /* expression */ createElement, 
        /* typeArguments */ undefined, 
        /* argumentsArray */ [ts.createLiteral(tagName)]);
    }
    /**
     * Create a `ts.VariableStatement` which declares a variable without explicit initialization.
     *
     * The initializer `null!` is used to bypass strict variable initialization checks.
     *
     * Unlike with `tsCreateVariable`, the type of the variable is explicitly specified.
     */
    function tsDeclareVariable(id, type) {
        const decl = ts.createVariableDeclaration(
        /* name */ id, 
        /* type */ type, 
        /* initializer */ ts.createNonNullExpression(ts.createNull()));
        return ts.createVariableStatement(
        /* modifiers */ undefined, 
        /* declarationList */ [decl]);
    }
    /**
     * Create a `ts.VariableStatement` that initializes a variable with a given expression.
     *
     * Unlike with `tsDeclareVariable`, the type of the variable is inferred from the initializer
     * expression.
     */
    function tsCreateVariable(id, initializer) {
        const decl = ts.createVariableDeclaration(
        /* name */ id, 
        /* type */ undefined, 
        /* initializer */ initializer);
        return ts.createVariableStatement(
        /* modifiers */ undefined, 
        /* declarationList */ [decl]);
    }
    /**
     * Construct a `ts.CallExpression` that calls a method on a receiver.
     */
    function tsCallMethod(receiver, methodName, args = []) {
        const methodAccess = ts.createPropertyAccess(receiver, methodName);
        return ts.createCall(
        /* expression */ methodAccess, 
        /* typeArguments */ undefined, 
        /* argumentsArray */ args);
    }
    function checkIfClassIsExported(node) {
        // A class is exported if one of two conditions is met:
        // 1) it has the 'export' modifier.
        // 2) it's declared at the top level, and there is an export statement for the class.
        if (node.modifiers !== undefined &&
            node.modifiers.some(mod => mod.kind === ts.SyntaxKind.ExportKeyword)) {
            // Condition 1 is true, the class has an 'export' keyword attached.
            return true;
        }
        else if (node.parent !== undefined && ts.isSourceFile(node.parent) &&
            checkIfFileHasExport(node.parent, node.name.text)) {
            // Condition 2 is true, the class is exported via an 'export {}' statement.
            return true;
        }
        return false;
    }
    function checkIfFileHasExport(sf, name) {
        for (const stmt of sf.statements) {
            if (ts.isExportDeclaration(stmt) && stmt.exportClause !== undefined &&
                ts.isNamedExports(stmt.exportClause)) {
                for (const element of stmt.exportClause.elements) {
                    if (element.propertyName === undefined && element.name.text === name) {
                        // The named declaration is directly exported.
                        return true;
                    }
                    else if (element.propertyName !== undefined && element.propertyName.text == name) {
                        // The named declaration is exported via an alias.
                        return true;
                    }
                }
            }
        }
        return false;
    }
    function checkIfGenericTypesAreUnbound(node) {
        if (node.typeParameters === undefined) {
            return true;
        }
        return node.typeParameters.every(param => param.constraint === undefined);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Determines whether the provided type can be emitted, which means that it can be safely emitted
     * into a different location.
     *
     * If this function returns true, a `TypeEmitter` should be able to succeed. Vice versa, if this
     * function returns false, then using the `TypeEmitter` should not be attempted as it is known to
     * fail.
     */
    function canEmitType(type, resolver) {
        return canEmitTypeWorker(type);
        function canEmitTypeWorker(type) {
            return visitTypeNode(type, {
                visitTypeReferenceNode: type => canEmitTypeReference(type),
                visitArrayTypeNode: type => canEmitTypeWorker(type.elementType),
                visitKeywordType: () => true,
                visitOtherType: () => false,
            });
        }
        function canEmitTypeReference(type) {
            const reference = resolver(type);
            // If the type could not be resolved, it can not be emitted.
            if (reference === null) {
                return false;
            }
            // If the type is a reference without a owning module, consider the type not to be eligible for
            // emitting.
            if (reference instanceof Reference$1 && !reference.hasOwningModuleGuess) {
                return false;
            }
            // The type can be emitted if either it does not have any type arguments, or all of them can be
            // emitted.
            return type.typeArguments === undefined || type.typeArguments.every(canEmitTypeWorker);
        }
    }
    /**
     * Given a `ts.TypeNode`, this class derives an equivalent `ts.TypeNode` that has been emitted into
     * a different context.
     *
     * For example, consider the following code:
     *
     * ```
     * import {NgIterable} from '@angular/core';
     *
     * class NgForOf<T, U extends NgIterable<T>> {}
     * ```
     *
     * Here, the generic type parameters `T` and `U` can be emitted into a different context, as the
     * type reference to `NgIterable` originates from an absolute module import so that it can be
     * emitted anywhere, using that same module import. The process of emitting translates the
     * `NgIterable` type reference to a type reference that is valid in the context in which it is
     * emitted, for example:
     *
     * ```
     * import * as i0 from '@angular/core';
     * import * as i1 from '@angular/common';
     *
     * const _ctor1: <T, U extends i0.NgIterable<T>>(o: Pick<i1.NgForOf<T, U>, 'ngForOf'>):
     * i1.NgForOf<T, U>;
     * ```
     *
     * Notice how the type reference for `NgIterable` has been translated into a qualified name,
     * referring to the namespace import that was created.
     */
    class TypeEmitter {
        constructor(resolver, emitReference) {
            this.resolver = resolver;
            this.emitReference = emitReference;
        }
        emitType(type) {
            return visitTypeNode(type, {
                visitTypeReferenceNode: type => this.emitTypeReference(type),
                visitArrayTypeNode: type => ts.updateArrayTypeNode(type, this.emitType(type.elementType)),
                visitKeywordType: type => type,
                visitOtherType: () => {
                    throw new Error('Unable to emit a complex type');
                },
            });
        }
        emitTypeReference(type) {
            // Determine the reference that the type corresponds with.
            const reference = this.resolver(type);
            if (reference === null) {
                throw new Error('Unable to emit an unresolved reference');
            }
            // Emit the type arguments, if any.
            let typeArguments = undefined;
            if (type.typeArguments !== undefined) {
                typeArguments = ts.createNodeArray(type.typeArguments.map(typeArg => this.emitType(typeArg)));
            }
            // Emit the type name.
            let typeName = type.typeName;
            if (reference instanceof Reference$1) {
                if (!reference.hasOwningModuleGuess) {
                    throw new Error('A type reference to emit must be imported from an absolute module');
                }
                const emittedType = this.emitReference(reference);
                if (!ts.isTypeReferenceNode(emittedType)) {
                    throw new Error(`Expected TypeReferenceNode for emitted reference, got ${ts.SyntaxKind[emittedType.kind]}`);
                }
                typeName = emittedType.typeName;
            }
            return ts.updateTypeReferenceNode(type, typeName, typeArguments);
        }
    }
    function visitTypeNode(type, visitor) {
        if (ts.isTypeReferenceNode(type)) {
            return visitor.visitTypeReferenceNode(type);
        }
        else if (ts.isArrayTypeNode(type)) {
            return visitor.visitArrayTypeNode(type);
        }
        switch (type.kind) {
            case ts.SyntaxKind.AnyKeyword:
            case ts.SyntaxKind.UnknownKeyword:
            case ts.SyntaxKind.NumberKeyword:
            case ts.SyntaxKind.ObjectKeyword:
            case ts.SyntaxKind.BooleanKeyword:
            case ts.SyntaxKind.StringKeyword:
            case ts.SyntaxKind.UndefinedKeyword:
            case ts.SyntaxKind.NullKeyword:
                return visitor.visitKeywordType(type);
            default:
                return visitor.visitOtherType(type);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * See `TypeEmitter` for more information on the emitting process.
     */
    class TypeParameterEmitter {
        constructor(typeParameters, reflector) {
            this.typeParameters = typeParameters;
            this.reflector = reflector;
        }
        /**
         * Determines whether the type parameters can be emitted. If this returns true, then a call to
         * `emit` is known to succeed. Vice versa, if false is returned then `emit` should not be
         * called, as it would fail.
         */
        canEmit() {
            if (this.typeParameters === undefined) {
                return true;
            }
            return this.typeParameters.every(typeParam => {
                if (typeParam.constraint === undefined) {
                    return true;
                }
                return canEmitType(typeParam.constraint, type => this.resolveTypeReference(type));
            });
        }
        /**
         * Emits the type parameters using the provided emitter function for `Reference`s.
         */
        emit(emitReference) {
            if (this.typeParameters === undefined) {
                return undefined;
            }
            const emitter = new TypeEmitter(type => this.resolveTypeReference(type), emitReference);
            return this.typeParameters.map(typeParam => {
                const constraint = typeParam.constraint !== undefined ? emitter.emitType(typeParam.constraint) : undefined;
                return ts.updateTypeParameterDeclaration(
                /* node */ typeParam, 
                /* name */ typeParam.name, 
                /* constraint */ constraint, 
                /* defaultType */ typeParam.default);
            });
        }
        resolveTypeReference(type) {
            const target = ts.isIdentifier(type.typeName) ? type.typeName : type.typeName.right;
            const declaration = this.reflector.getDeclarationOfIdentifier(target);
            // If no declaration could be resolved or does not have a `ts.Declaration`, the type cannot be
            // resolved.
            if (declaration === null || declaration.node === null) {
                return null;
            }
            // If the declaration corresponds with a local type parameter, the type reference can be used
            // as is.
            if (this.isLocalTypeParameter(declaration.node)) {
                return type;
            }
            let owningModule = null;
            if (declaration.viaModule !== null) {
                owningModule = {
                    specifier: declaration.viaModule,
                    resolutionContext: type.getSourceFile().fileName,
                };
            }
            return new Reference$1(declaration.node, owningModule);
        }
        isLocalTypeParameter(decl) {
            // Checking for local type parameters only occurs during resolution of type parameters, so it is
            // guaranteed that type parameters are present.
            return this.typeParameters.some(param => param === decl);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function generateTypeCtorDeclarationFn(node, meta, nodeTypeRef, typeParams, reflector) {
        if (requiresInlineTypeCtor(node, reflector)) {
            throw new Error(`${node.name.text} requires an inline type constructor`);
        }
        const rawTypeArgs = typeParams !== undefined ? generateGenericArgs(typeParams) : undefined;
        const rawType = ts.createTypeReferenceNode(nodeTypeRef, rawTypeArgs);
        const initParam = constructTypeCtorParameter(node, meta, rawType);
        const typeParameters = typeParametersWithDefaultTypes(typeParams);
        if (meta.body) {
            const fnType = ts.createFunctionTypeNode(
            /* typeParameters */ typeParameters, 
            /* parameters */ [initParam], 
            /* type */ rawType);
            const decl = ts.createVariableDeclaration(
            /* name */ meta.fnName, 
            /* type */ fnType, 
            /* body */ ts.createNonNullExpression(ts.createNull()));
            const declList = ts.createVariableDeclarationList([decl], ts.NodeFlags.Const);
            return ts.createVariableStatement(
            /* modifiers */ undefined, 
            /* declarationList */ declList);
        }
        else {
            return ts.createFunctionDeclaration(
            /* decorators */ undefined, 
            /* modifiers */ [ts.createModifier(ts.SyntaxKind.DeclareKeyword)], 
            /* asteriskToken */ undefined, 
            /* name */ meta.fnName, 
            /* typeParameters */ typeParameters, 
            /* parameters */ [initParam], 
            /* type */ rawType, 
            /* body */ undefined);
        }
    }
    /**
     * Generate an inline type constructor for the given class and metadata.
     *
     * An inline type constructor is a specially shaped TypeScript static method, intended to be placed
     * within a directive class itself, that permits type inference of any generic type parameters of
     * the class from the types of expressions bound to inputs or outputs, and the types of elements
     * that match queries performed by the directive. It also catches any errors in the types of these
     * expressions. This method is never called at runtime, but is used in type-check blocks to
     * construct directive types.
     *
     * An inline type constructor for NgFor looks like:
     *
     * static ngTypeCtor<T>(init: Pick<NgForOf<T>, 'ngForOf'|'ngForTrackBy'|'ngForTemplate'>):
     *   NgForOf<T>;
     *
     * A typical constructor would be:
     *
     * NgForOf.ngTypeCtor(init: {
     *   ngForOf: ['foo', 'bar'],
     *   ngForTrackBy: null as any,
     *   ngForTemplate: null as any,
     * }); // Infers a type of NgForOf<string>.
     *
     * Any inputs declared on the type for which no property binding is present are assigned a value of
     * type `any`, to avoid producing any type errors for unset inputs.
     *
     * Inline type constructors are used when the type being created has bounded generic types which
     * make writing a declared type constructor (via `generateTypeCtorDeclarationFn`) difficult or
     * impossible.
     *
     * @param node the `ClassDeclaration<ts.ClassDeclaration>` for which a type constructor will be
     * generated.
     * @param meta additional metadata required to generate the type constructor.
     * @returns a `ts.MethodDeclaration` for the type constructor.
     */
    function generateInlineTypeCtor(node, meta) {
        // Build rawType, a `ts.TypeNode` of the class with its generic parameters passed through from
        // the definition without any type bounds. For example, if the class is
        // `FooDirective<T extends Bar>`, its rawType would be `FooDirective<T>`.
        const rawTypeArgs = node.typeParameters !== undefined ? generateGenericArgs(node.typeParameters) : undefined;
        const rawType = ts.createTypeReferenceNode(node.name, rawTypeArgs);
        const initParam = constructTypeCtorParameter(node, meta, rawType);
        // If this constructor is being generated into a .ts file, then it needs a fake body. The body
        // is set to a return of `null!`. If the type constructor is being generated into a .d.ts file,
        // it needs no body.
        let body = undefined;
        if (meta.body) {
            body = ts.createBlock([
                ts.createReturn(ts.createNonNullExpression(ts.createNull())),
            ]);
        }
        // Create the type constructor method declaration.
        return ts.createMethod(
        /* decorators */ undefined, 
        /* modifiers */ [ts.createModifier(ts.SyntaxKind.StaticKeyword)], 
        /* asteriskToken */ undefined, 
        /* name */ meta.fnName, 
        /* questionToken */ undefined, 
        /* typeParameters */ typeParametersWithDefaultTypes(node.typeParameters), 
        /* parameters */ [initParam], 
        /* type */ rawType, 
        /* body */ body);
    }
    function constructTypeCtorParameter(node, meta, rawType) {
        // initType is the type of 'init', the single argument to the type constructor method.
        // If the Directive has any inputs, its initType will be:
        //
        // Pick<rawType, 'inputA'|'inputB'>
        //
        // Pick here is used to select only those fields from which the generic type parameters of the
        // directive will be inferred.
        //
        // In the special case there are no inputs, initType is set to {}.
        let initType = null;
        const keys = meta.fields.inputs;
        const plainKeys = [];
        const coercedKeys = [];
        for (const key of keys) {
            if (!meta.coercedInputFields.has(key)) {
                plainKeys.push(ts.createLiteralTypeNode(ts.createStringLiteral(key)));
            }
            else {
                coercedKeys.push(ts.createPropertySignature(
                /* modifiers */ undefined, 
                /* name */ key, 
                /* questionToken */ undefined, 
                /* type */
                ts.createTypeQueryNode(ts.createQualifiedName(rawType.typeName, `ngAcceptInputType_${key}`)), 
                /* initializer */ undefined));
            }
        }
        if (plainKeys.length > 0) {
            // Construct a union of all the field names.
            const keyTypeUnion = ts.createUnionTypeNode(plainKeys);
            // Construct the Pick<rawType, keyTypeUnion>.
            initType = ts.createTypeReferenceNode('Pick', [rawType, keyTypeUnion]);
        }
        if (coercedKeys.length > 0) {
            const coercedLiteral = ts.createTypeLiteralNode(coercedKeys);
            initType =
                initType !== null ? ts.createUnionTypeNode([initType, coercedLiteral]) : coercedLiteral;
        }
        if (initType === null) {
            // Special case - no inputs, outputs, or other fields which could influence the result type.
            initType = ts.createTypeLiteralNode([]);
        }
        // Create the 'init' parameter itself.
        return ts.createParameter(
        /* decorators */ undefined, 
        /* modifiers */ undefined, 
        /* dotDotDotToken */ undefined, 
        /* name */ 'init', 
        /* questionToken */ undefined, 
        /* type */ initType, 
        /* initializer */ undefined);
    }
    function generateGenericArgs(params) {
        return params.map(param => ts.createTypeReferenceNode(param.name, undefined));
    }
    function requiresInlineTypeCtor(node, host) {
        // The class requires an inline type constructor if it has generic type bounds that can not be
        // emitted into a different context.
        return !checkIfGenericTypeBoundsAreContextFree(node, host);
    }
    function checkIfGenericTypeBoundsAreContextFree(node, reflector) {
        // Generic type parameters are considered context free if they can be emitted into any context.
        return new TypeParameterEmitter(node.typeParameters, reflector).canEmit();
    }
    /**
     * Add a default `= any` to type parameters that don't have a default value already.
     *
     * TypeScript uses the default type of a type parameter whenever inference of that parameter fails.
     * This can happen when inferring a complex type from 'any'. For example, if `NgFor`'s inference is
     * done with the TCB code:
     *
     * ```
     * class NgFor<T> {
     *   ngForOf: T[];
     * }
     *
     * declare function ctor<T>(o: Pick<NgFor<T>, 'ngForOf'|'ngForTrackBy'|'ngForTemplate'>): NgFor<T>;
     * ```
     *
     * An invocation looks like:
     *
     * ```
     * var _t1 = ctor({ngForOf: [1, 2], ngForTrackBy: null as any, ngForTemplate: null as any});
     * ```
     *
     * This correctly infers the type `NgFor<number>` for `_t1`, since `T` is inferred from the
     * assignment of type `number[]` to `ngForOf`'s type `T[]`. However, if `any` is passed instead:
     *
     * ```
     * var _t2 = ctor({ngForOf: [1, 2] as any, ngForTrackBy: null as any, ngForTemplate: null as any});
     * ```
     *
     * then inference for `T` fails (it cannot be inferred from `T[] = any`). In this case, `T` takes
     * the type `{}`, and so `_t2` is inferred as `NgFor<{}>`. This is obviously wrong.
     *
     * Adding a default type to the generic declaration in the constructor solves this problem, as the
     * default type will be used in the event that inference fails.
     *
     * ```
     * declare function ctor<T = any>(o: Pick<NgFor<T>, 'ngForOf'>): NgFor<T>;
     *
     * var _t3 = ctor({ngForOf: [1, 2] as any});
     * ```
     *
     * This correctly infers `T` as `any`, and therefore `_t3` as `NgFor<any>`.
     */
    function typeParametersWithDefaultTypes(params) {
        if (params === undefined) {
            return undefined;
        }
        return params.map(param => {
            if (param.default === undefined) {
                return ts.updateTypeParameterDeclaration(
                /* node */ param, 
                /* name */ param.name, 
                /* constraint */ param.constraint, 
                /* defaultType */ ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));
            }
            else {
                return param;
            }
        });
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A context which hosts one or more Type Check Blocks (TCBs).
     *
     * An `Environment` supports the generation of TCBs by tracking necessary imports, declarations of
     * type constructors, and other statements beyond the type-checking code within the TCB itself.
     * Through method calls on `Environment`, the TCB generator can request `ts.Expression`s which
     * reference declarations in the `Environment` for these artifacts`.
     *
     * `Environment` can be used in a standalone fashion, or can be extended to support more specialized
     * usage.
     */
    class Environment {
        constructor(config, importManager, refEmitter, reflector, contextFile) {
            this.config = config;
            this.importManager = importManager;
            this.refEmitter = refEmitter;
            this.reflector = reflector;
            this.contextFile = contextFile;
            this.nextIds = {
                pipeInst: 1,
                typeCtor: 1,
            };
            this.typeCtors = new Map();
            this.typeCtorStatements = [];
            this.pipeInsts = new Map();
            this.pipeInstStatements = [];
            this.outputHelperIdent = null;
            this.helperStatements = [];
        }
        /**
         * Get an expression referring to a type constructor for the given directive.
         *
         * Depending on the shape of the directive itself, this could be either a reference to a declared
         * type constructor, or to an inline type constructor.
         */
        typeCtorFor(dir) {
            const dirRef = dir.ref;
            const node = dirRef.node;
            if (this.typeCtors.has(node)) {
                return this.typeCtors.get(node);
            }
            if (requiresInlineTypeCtor(node, this.reflector)) {
                // The constructor has already been created inline, we just need to construct a reference to
                // it.
                const ref = this.reference(dirRef);
                const typeCtorExpr = ts.createPropertyAccess(ref, 'ngTypeCtor');
                this.typeCtors.set(node, typeCtorExpr);
                return typeCtorExpr;
            }
            else {
                const fnName = `_ctor${this.nextIds.typeCtor++}`;
                const nodeTypeRef = this.referenceType(dirRef);
                if (!ts.isTypeReferenceNode(nodeTypeRef)) {
                    throw new Error(`Expected TypeReferenceNode from reference to ${dirRef.debugName}`);
                }
                const meta = {
                    fnName,
                    body: true,
                    fields: {
                        inputs: Object.keys(dir.inputs),
                        outputs: Object.keys(dir.outputs),
                        // TODO: support queries
                        queries: dir.queries,
                    },
                    coercedInputFields: dir.coercedInputFields,
                };
                const typeParams = this.emitTypeParameters(node);
                const typeCtor = generateTypeCtorDeclarationFn(node, meta, nodeTypeRef.typeName, typeParams, this.reflector);
                this.typeCtorStatements.push(typeCtor);
                const fnId = ts.createIdentifier(fnName);
                this.typeCtors.set(node, fnId);
                return fnId;
            }
        }
        /*
         * Get an expression referring to an instance of the given pipe.
         */
        pipeInst(ref) {
            if (this.pipeInsts.has(ref.node)) {
                return this.pipeInsts.get(ref.node);
            }
            const pipeType = this.referenceType(ref);
            const pipeInstId = ts.createIdentifier(`_pipe${this.nextIds.pipeInst++}`);
            this.pipeInstStatements.push(tsDeclareVariable(pipeInstId, pipeType));
            this.pipeInsts.set(ref.node, pipeInstId);
            return pipeInstId;
        }
        /**
         * Declares a helper function to be able to cast directive outputs of type `EventEmitter<T>` to
         * have an accurate `subscribe()` method that properly carries over the generic type `T` into the
         * listener function passed as argument to `subscribe`. This is done to work around a typing
         * deficiency in `EventEmitter.subscribe`, where the listener function is typed as any.
         */
        declareOutputHelper() {
            if (this.outputHelperIdent !== null) {
                return this.outputHelperIdent;
            }
            const outputHelperIdent = ts.createIdentifier('_outputHelper');
            const genericTypeDecl = ts.createTypeParameterDeclaration('T');
            const genericTypeRef = ts.createTypeReferenceNode('T', /* typeParameters */ undefined);
            const eventEmitter = this.referenceExternalType('@angular/core', 'EventEmitter', [new ExpressionType(new WrappedNodeExpr(genericTypeRef))]);
            // Declare a type that has a `subscribe` method that carries over type `T` as parameter
            // into the callback. The below code generates the following type literal:
            // `{subscribe(cb: (event: T) => any): void;}`
            const observableLike = ts.createTypeLiteralNode([ts.createMethodSignature(
                /* typeParameters */ undefined, 
                /* parameters */ [ts.createParameter(
                    /* decorators */ undefined, 
                    /* modifiers */ undefined, 
                    /* dotDotDotToken */ undefined, 
                    /* name */ 'cb', 
                    /* questionToken */ undefined, 
                    /* type */
                    ts.createFunctionTypeNode(
                    /* typeParameters */ undefined, 
                    /* parameters */ [ts.createParameter(
                        /* decorators */ undefined, 
                        /* modifiers */ undefined, 
                        /* dotDotDotToken */ undefined, 
                        /* name */ 'event', 
                        /* questionToken */ undefined, 
                        /* type */ genericTypeRef)], 
                    /* type */ ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword)))], 
                /* type */ ts.createKeywordTypeNode(ts.SyntaxKind.VoidKeyword), 
                /* name */ 'subscribe', 
                /* questionToken */ undefined)]);
            // Declares the first signature of `_outputHelper` that matches arguments of type
            // `EventEmitter`, to convert them into `observableLike` defined above. The following
            // statement is generated:
            // `declare function _outputHelper<T>(output: EventEmitter<T>): observableLike;`
            this.helperStatements.push(ts.createFunctionDeclaration(
            /* decorators */ undefined, 
            /* modifiers */ [ts.createModifier(ts.SyntaxKind.DeclareKeyword)], 
            /* asteriskToken */ undefined, 
            /* name */ outputHelperIdent, 
            /* typeParameters */ [genericTypeDecl], 
            /* parameters */ [ts.createParameter(
                /* decorators */ undefined, 
                /* modifiers */ undefined, 
                /* dotDotDotToken */ undefined, 
                /* name */ 'output', 
                /* questionToken */ undefined, 
                /* type */ eventEmitter)], 
            /* type */ observableLike, 
            /* body */ undefined));
            // Declares the second signature of `_outputHelper` that matches all other argument types,
            // i.e. ensures type identity for output types other than `EventEmitter`. This corresponds
            // with the following statement:
            // `declare function _outputHelper<T>(output: T): T;`
            this.helperStatements.push(ts.createFunctionDeclaration(
            /* decorators */ undefined, 
            /* modifiers */ [ts.createModifier(ts.SyntaxKind.DeclareKeyword)], 
            /* asteriskToken */ undefined, 
            /* name */ outputHelperIdent, 
            /* typeParameters */ [genericTypeDecl], 
            /* parameters */ [ts.createParameter(
                /* decorators */ undefined, 
                /* modifiers */ undefined, 
                /* dotDotDotToken */ undefined, 
                /* name */ 'output', 
                /* questionToken */ undefined, 
                /* type */ genericTypeRef)], 
            /* type */ genericTypeRef, 
            /* body */ undefined));
            return this.outputHelperIdent = outputHelperIdent;
        }
        /**
         * Generate a `ts.Expression` that references the given node.
         *
         * This may involve importing the node into the file if it's not declared there already.
         */
        reference(ref) {
            // Disable aliasing for imports generated in a template type-checking context, as there is no
            // guarantee that any alias re-exports exist in the .d.ts files. It's safe to use direct imports
            // in these cases as there is no strict dependency checking during the template type-checking
            // pass.
            const ngExpr = this.refEmitter.emit(ref, this.contextFile, ImportFlags.NoAliasing);
            // Use `translateExpression` to convert the `Expression` into a `ts.Expression`.
            return translateExpression(ngExpr, this.importManager, NOOP_DEFAULT_IMPORT_RECORDER, ts.ScriptTarget.ES2015);
        }
        /**
         * Generate a `ts.TypeNode` that references the given node as a type.
         *
         * This may involve importing the node into the file if it's not declared there already.
         */
        referenceType(ref) {
            const ngExpr = this.refEmitter.emit(ref, this.contextFile, ImportFlags.NoAliasing | ImportFlags.AllowTypeImports);
            // Create an `ExpressionType` from the `Expression` and translate it via `translateType`.
            // TODO(alxhub): support references to types with generic arguments in a clean way.
            return translateType(new ExpressionType(ngExpr), this.importManager);
        }
        emitTypeParameters(declaration) {
            const emitter = new TypeParameterEmitter(declaration.typeParameters, this.reflector);
            return emitter.emit(ref => this.referenceType(ref));
        }
        /**
         * Generate a `ts.TypeNode` that references a given type from the provided module.
         *
         * This will involve importing the type into the file, and will also add type parameters if
         * provided.
         */
        referenceExternalType(moduleName, name, typeParams) {
            const external = new ExternalExpr({ moduleName, name });
            return translateType(new ExpressionType(external, null, typeParams), this.importManager);
        }
        getPreludeStatements() {
            return [
                ...this.helperStatements,
                ...this.pipeInstStatements,
                ...this.typeCtorStatements,
            ];
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class OutOfBandDiagnosticRecorderImpl {
        constructor(resolver) {
            this.resolver = resolver;
            this._diagnostics = [];
        }
        get diagnostics() {
            return this._diagnostics;
        }
        missingReferenceTarget(templateId, ref) {
            const mapping = this.resolver.getSourceMapping(templateId);
            const value = ref.value.trim();
            const errorMsg = `No directive found with exportAs '${value}'.`;
            this._diagnostics.push(makeTemplateDiagnostic(templateId, mapping, ref.valueSpan || ref.sourceSpan, ts.DiagnosticCategory.Error, ngErrorCode(ErrorCode.MISSING_REFERENCE_TARGET), errorMsg));
        }
        missingPipe(templateId, ast) {
            const mapping = this.resolver.getSourceMapping(templateId);
            const errorMsg = `No pipe found with name '${ast.name}'.`;
            const sourceSpan = this.resolver.toParseSourceSpan(templateId, ast.nameSpan);
            if (sourceSpan === null) {
                throw new Error(`Assertion failure: no SourceLocation found for usage of pipe '${ast.name}'.`);
            }
            this._diagnostics.push(makeTemplateDiagnostic(templateId, mapping, sourceSpan, ts.DiagnosticCategory.Error, ngErrorCode(ErrorCode.MISSING_PIPE), errorMsg));
        }
        illegalAssignmentToTemplateVar(templateId, assignment, target) {
            const mapping = this.resolver.getSourceMapping(templateId);
            const errorMsg = `Cannot use variable '${assignment
            .name}' as the left-hand side of an assignment expression. Template variables are read-only.`;
            const sourceSpan = this.resolver.toParseSourceSpan(templateId, assignment.sourceSpan);
            if (sourceSpan === null) {
                throw new Error(`Assertion failure: no SourceLocation found for property binding.`);
            }
            this._diagnostics.push(makeTemplateDiagnostic(templateId, mapping, sourceSpan, ts.DiagnosticCategory.Error, ngErrorCode(ErrorCode.WRITE_TO_READ_ONLY_VARIABLE), errorMsg, {
                text: `The variable ${assignment.name} is declared here.`,
                span: target.valueSpan || target.sourceSpan,
            }));
        }
        duplicateTemplateVar(templateId, variable, firstDecl) {
            const mapping = this.resolver.getSourceMapping(templateId);
            const errorMsg = `Cannot redeclare variable '${variable.name}' as it was previously declared elsewhere for the same template.`;
            // The allocation of the error here is pretty useless for variables declared in microsyntax,
            // since the sourceSpan refers to the entire microsyntax property, not a span for the specific
            // variable in question.
            //
            // TODO(alxhub): allocate to a tighter span once one is available.
            this._diagnostics.push(makeTemplateDiagnostic(templateId, mapping, variable.sourceSpan, ts.DiagnosticCategory.Error, ngErrorCode(ErrorCode.DUPLICATE_VARIABLE_DECLARATION), errorMsg, {
                text: `The variable '${firstDecl.name}' was first declared here.`,
                span: firstDecl.sourceSpan,
            }));
        }
        requiresInlineTcb(templateId, node) {
            this._diagnostics.push(makeInlineDiagnostic(templateId, ErrorCode.INLINE_TCB_REQUIRED, node.name, `This component requires inline template type-checking, which is not supported by the current environment.`));
        }
        requiresInlineTypeConstructors(templateId, node, directives) {
            let message;
            if (directives.length > 1) {
                message =
                    `This component uses directives which require inline type constructors, which are not supported by the current environment.`;
            }
            else {
                message =
                    `This component uses a directive which requires an inline type constructor, which is not supported by the current environment.`;
            }
            this._diagnostics.push(makeInlineDiagnostic(templateId, ErrorCode.INLINE_TYPE_CTOR_REQUIRED, node.name, message, directives.map(dir => makeRelatedInformation(dir.name, `Requires an inline type constructor.`))));
        }
    }
    function makeInlineDiagnostic(templateId, code, node, messageText, relatedInformation) {
        return Object.assign(Object.assign({}, makeDiagnostic(code, node, messageText, relatedInformation)), { componentFile: node.getSourceFile(), templateId });
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const NULL_AS_ANY = ts.createAsExpression(ts.createNull(), ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));
    const UNDEFINED = ts.createIdentifier('undefined');
    const BINARY_OPS = new Map([
        ['+', ts.SyntaxKind.PlusToken],
        ['-', ts.SyntaxKind.MinusToken],
        ['<', ts.SyntaxKind.LessThanToken],
        ['>', ts.SyntaxKind.GreaterThanToken],
        ['<=', ts.SyntaxKind.LessThanEqualsToken],
        ['>=', ts.SyntaxKind.GreaterThanEqualsToken],
        ['==', ts.SyntaxKind.EqualsEqualsToken],
        ['===', ts.SyntaxKind.EqualsEqualsEqualsToken],
        ['*', ts.SyntaxKind.AsteriskToken],
        ['/', ts.SyntaxKind.SlashToken],
        ['%', ts.SyntaxKind.PercentToken],
        ['!=', ts.SyntaxKind.ExclamationEqualsToken],
        ['!==', ts.SyntaxKind.ExclamationEqualsEqualsToken],
        ['||', ts.SyntaxKind.BarBarToken],
        ['&&', ts.SyntaxKind.AmpersandAmpersandToken],
        ['&', ts.SyntaxKind.AmpersandToken],
        ['|', ts.SyntaxKind.BarToken],
    ]);
    /**
     * Convert an `AST` to TypeScript code directly, without going through an intermediate `Expression`
     * AST.
     */
    function astToTypescript(ast, maybeResolve, config) {
        const translator = new AstTranslator(maybeResolve, config);
        return translator.translate(ast);
    }
    class AstTranslator {
        constructor(maybeResolve, config) {
            this.maybeResolve = maybeResolve;
            this.config = config;
        }
        translate(ast) {
            // Skip over an `ASTWithSource` as its `visit` method calls directly into its ast's `visit`,
            // which would prevent any custom resolution through `maybeResolve` for that node.
            if (ast instanceof ASTWithSource) {
                ast = ast.ast;
            }
            // The `EmptyExpr` doesn't have a dedicated method on `AstVisitor`, so it's special cased here.
            if (ast instanceof EmptyExpr) {
                return UNDEFINED;
            }
            // First attempt to let any custom resolution logic provide a translation for the given node.
            const resolved = this.maybeResolve(ast);
            if (resolved !== null) {
                return resolved;
            }
            return ast.visit(this);
        }
        visitBinary(ast) {
            const lhs = wrapForDiagnostics(this.translate(ast.left));
            const rhs = wrapForDiagnostics(this.translate(ast.right));
            const op = BINARY_OPS.get(ast.operation);
            if (op === undefined) {
                throw new Error(`Unsupported Binary.operation: ${ast.operation}`);
            }
            const node = ts.createBinary(lhs, op, rhs);
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
        visitChain(ast) {
            const elements = ast.expressions.map(expr => this.translate(expr));
            const node = wrapForDiagnostics(ts.createCommaList(elements));
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
        visitConditional(ast) {
            const condExpr = this.translate(ast.condition);
            const trueExpr = this.translate(ast.trueExp);
            const falseExpr = this.translate(ast.falseExp);
            const node = ts.createParen(ts.createConditional(condExpr, trueExpr, falseExpr));
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
        visitFunctionCall(ast) {
            const receiver = wrapForDiagnostics(this.translate(ast.target));
            const args = ast.args.map(expr => this.translate(expr));
            const node = ts.createCall(receiver, undefined, args);
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
        visitImplicitReceiver(ast) {
            throw new Error('Method not implemented.');
        }
        visitInterpolation(ast) {
            // Build up a chain of binary + operations to simulate the string concatenation of the
            // interpolation's expressions. The chain is started using an actual string literal to ensure
            // the type is inferred as 'string'.
            return ast.expressions.reduce((lhs, ast) => ts.createBinary(lhs, ts.SyntaxKind.PlusToken, this.translate(ast)), ts.createLiteral(''));
        }
        visitKeyedRead(ast) {
            const receiver = wrapForDiagnostics(this.translate(ast.obj));
            const key = this.translate(ast.key);
            const node = ts.createElementAccess(receiver, key);
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
        visitKeyedWrite(ast) {
            const receiver = wrapForDiagnostics(this.translate(ast.obj));
            const left = ts.createElementAccess(receiver, this.translate(ast.key));
            // TODO(joost): annotate `left` with the span of the element access, which is not currently
            //  available on `ast`.
            const right = this.translate(ast.value);
            const node = wrapForDiagnostics(ts.createBinary(left, ts.SyntaxKind.EqualsToken, right));
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
        visitLiteralArray(ast) {
            const elements = ast.expressions.map(expr => this.translate(expr));
            const literal = ts.createArrayLiteral(elements);
            // If strictLiteralTypes is disabled, array literals are cast to `any`.
            const node = this.config.strictLiteralTypes ? literal : tsCastToAny(literal);
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
        visitLiteralMap(ast) {
            const properties = ast.keys.map(({ key }, idx) => {
                const value = this.translate(ast.values[idx]);
                return ts.createPropertyAssignment(ts.createStringLiteral(key), value);
            });
            const literal = ts.createObjectLiteral(properties, true);
            // If strictLiteralTypes is disabled, object literals are cast to `any`.
            const node = this.config.strictLiteralTypes ? literal : tsCastToAny(literal);
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
        visitLiteralPrimitive(ast) {
            let node;
            if (ast.value === undefined) {
                node = ts.createIdentifier('undefined');
            }
            else if (ast.value === null) {
                node = ts.createNull();
            }
            else {
                node = ts.createLiteral(ast.value);
            }
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
        visitMethodCall(ast) {
            const receiver = wrapForDiagnostics(this.translate(ast.receiver));
            const method = ts.createPropertyAccess(receiver, ast.name);
            addParseSpanInfo(method, ast.nameSpan);
            const args = ast.args.map(expr => this.translate(expr));
            const node = ts.createCall(method, undefined, args);
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
        visitNonNullAssert(ast) {
            const expr = wrapForDiagnostics(this.translate(ast.expression));
            const node = ts.createNonNullExpression(expr);
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
        visitPipe(ast) {
            throw new Error('Method not implemented.');
        }
        visitPrefixNot(ast) {
            const expression = wrapForDiagnostics(this.translate(ast.expression));
            const node = ts.createLogicalNot(expression);
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
        visitPropertyRead(ast) {
            // This is a normal property read - convert the receiver to an expression and emit the correct
            // TypeScript expression to read the property.
            const receiver = wrapForDiagnostics(this.translate(ast.receiver));
            const name = ts.createPropertyAccess(receiver, ast.name);
            addParseSpanInfo(name, ast.nameSpan);
            const node = wrapForDiagnostics(name);
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
        visitPropertyWrite(ast) {
            const receiver = wrapForDiagnostics(this.translate(ast.receiver));
            const left = ts.createPropertyAccess(receiver, ast.name);
            addParseSpanInfo(left, ast.nameSpan);
            // TypeScript reports assignment errors on the entire lvalue expression. Annotate the lvalue of
            // the assignment with the sourceSpan, which includes receivers, rather than nameSpan for
            // consistency of the diagnostic location.
            // a.b.c = 1
            // ^^^^^^^^^ sourceSpan
            //     ^     nameSpan
            const leftWithPath = wrapForDiagnostics(left);
            addParseSpanInfo(leftWithPath, ast.sourceSpan);
            const right = this.translate(ast.value);
            const node = wrapForDiagnostics(ts.createBinary(leftWithPath, ts.SyntaxKind.EqualsToken, right));
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
        visitQuote(ast) {
            return NULL_AS_ANY;
        }
        visitSafeMethodCall(ast) {
            // See the comments in SafePropertyRead above for an explanation of the cases here.
            let node;
            const receiver = wrapForDiagnostics(this.translate(ast.receiver));
            const args = ast.args.map(expr => this.translate(expr));
            if (this.config.strictSafeNavigationTypes) {
                // "a?.method(...)" becomes (null as any ? a!.method(...) : undefined)
                const method = ts.createPropertyAccess(ts.createNonNullExpression(receiver), ast.name);
                addParseSpanInfo(method, ast.nameSpan);
                const call = ts.createCall(method, undefined, args);
                node = ts.createParen(ts.createConditional(NULL_AS_ANY, call, UNDEFINED));
            }
            else if (VeSafeLhsInferenceBugDetector.veWillInferAnyFor(ast)) {
                // "a?.method(...)" becomes (a as any).method(...)
                const method = ts.createPropertyAccess(tsCastToAny(receiver), ast.name);
                addParseSpanInfo(method, ast.nameSpan);
                node = ts.createCall(method, undefined, args);
            }
            else {
                // "a?.method(...)" becomes (a!.method(...) as any)
                const method = ts.createPropertyAccess(ts.createNonNullExpression(receiver), ast.name);
                addParseSpanInfo(method, ast.nameSpan);
                node = tsCastToAny(ts.createCall(method, undefined, args));
            }
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
        visitSafePropertyRead(ast) {
            let node;
            const receiver = wrapForDiagnostics(this.translate(ast.receiver));
            // The form of safe property reads depends on whether strictness is in use.
            if (this.config.strictSafeNavigationTypes) {
                // Basically, the return here is either the type of the complete expression with a null-safe
                // property read, or `undefined`. So a ternary is used to create an "or" type:
                // "a?.b" becomes (null as any ? a!.b : undefined)
                // The type of this expression is (typeof a!.b) | undefined, which is exactly as desired.
                const expr = ts.createPropertyAccess(ts.createNonNullExpression(receiver), ast.name);
                node = ts.createParen(ts.createConditional(NULL_AS_ANY, expr, UNDEFINED));
            }
            else if (VeSafeLhsInferenceBugDetector.veWillInferAnyFor(ast)) {
                // Emulate a View Engine bug where 'any' is inferred for the left-hand side of the safe
                // navigation operation. With this bug, the type of the left-hand side is regarded as any.
                // Therefore, the left-hand side only needs repeating in the output (to validate it), and then
                // 'any' is used for the rest of the expression. This is done using a comma operator:
                // "a?.b" becomes (a as any).b, which will of course have type 'any'.
                node = ts.createPropertyAccess(tsCastToAny(receiver), ast.name);
            }
            else {
                // The View Engine bug isn't active, so check the entire type of the expression, but the final
                // result is still inferred as `any`.
                // "a?.b" becomes (a!.b as any)
                const expr = ts.createPropertyAccess(ts.createNonNullExpression(receiver), ast.name);
                node = tsCastToAny(expr);
            }
            addParseSpanInfo(node, ast.sourceSpan);
            return node;
        }
    }
    /**
     * Checks whether View Engine will infer a type of 'any' for the left-hand side of a safe navigation
     * operation.
     *
     * In View Engine's template type-checker, certain receivers of safe navigation operations will
     * cause a temporary variable to be allocated as part of the checking expression, to save the value
     * of the receiver and use it more than once in the expression. This temporary variable has type
     * 'any'. In practice, this means certain receivers cause View Engine to not check the full
     * expression, and other receivers will receive more complete checking.
     *
     * For compatibility, this logic is adapted from View Engine's expression_converter.ts so that the
     * Ivy checker can emulate this bug when needed.
     */
    class VeSafeLhsInferenceBugDetector {
        static veWillInferAnyFor(ast) {
            return ast.receiver.visit(VeSafeLhsInferenceBugDetector.SINGLETON);
        }
        visitBinary(ast) {
            return ast.left.visit(this) || ast.right.visit(this);
        }
        visitChain(ast) {
            return false;
        }
        visitConditional(ast) {
            return ast.condition.visit(this) || ast.trueExp.visit(this) || ast.falseExp.visit(this);
        }
        visitFunctionCall(ast) {
            return true;
        }
        visitImplicitReceiver(ast) {
            return false;
        }
        visitInterpolation(ast) {
            return ast.expressions.some(exp => exp.visit(this));
        }
        visitKeyedRead(ast) {
            return false;
        }
        visitKeyedWrite(ast) {
            return false;
        }
        visitLiteralArray(ast) {
            return true;
        }
        visitLiteralMap(ast) {
            return true;
        }
        visitLiteralPrimitive(ast) {
            return false;
        }
        visitMethodCall(ast) {
            return true;
        }
        visitPipe(ast) {
            return true;
        }
        visitPrefixNot(ast) {
            return ast.expression.visit(this);
        }
        visitNonNullAssert(ast) {
            return ast.expression.visit(this);
        }
        visitPropertyRead(ast) {
            return false;
        }
        visitPropertyWrite(ast) {
            return false;
        }
        visitQuote(ast) {
            return false;
        }
        visitSafeMethodCall(ast) {
            return true;
        }
        visitSafePropertyRead(ast) {
            return false;
        }
    }
    VeSafeLhsInferenceBugDetector.SINGLETON = new VeSafeLhsInferenceBugDetector();

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Visits a template and records any semantic errors within its expressions.
     */
    class ExpressionSemanticVisitor extends RecursiveAstVisitor {
        constructor(templateId, boundTarget, oob) {
            super();
            this.templateId = templateId;
            this.boundTarget = boundTarget;
            this.oob = oob;
        }
        visitPropertyWrite(ast, context) {
            super.visitPropertyWrite(ast, context);
            if (!(ast.receiver instanceof ImplicitReceiver)) {
                return;
            }
            const target = this.boundTarget.getExpressionTarget(ast);
            if (target instanceof Variable) {
                // Template variables are read-only.
                this.oob.illegalAssignmentToTemplateVar(this.templateId, ast, target);
            }
        }
        static visit(ast, id, boundTarget, oob) {
            ast.visit(new ExpressionSemanticVisitor(id, boundTarget, oob));
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Given a `ts.ClassDeclaration` for a component, and metadata regarding that component, compose a
     * "type check block" function.
     *
     * When passed through TypeScript's TypeChecker, type errors that arise within the type check block
     * function indicate issues in the template itself.
     *
     * As a side effect of generating a TCB for the component, `ts.Diagnostic`s may also be produced
     * directly for issues within the template which are identified during generation. These issues are
     * recorded in either the `domSchemaChecker` (which checks usage of DOM elements and bindings) as
     * well as the `oobRecorder` (which records errors when the type-checking code generator is unable
     * to sufficiently understand a template).
     *
     * @param env an `Environment` into which type-checking code will be generated.
     * @param ref a `Reference` to the component class which should be type-checked.
     * @param name a `ts.Identifier` to use for the generated `ts.FunctionDeclaration`.
     * @param meta metadata about the component's template and the function being generated.
     * @param domSchemaChecker used to check and record errors regarding improper usage of DOM elements
     * and bindings.
     * @param oobRecorder used to record errors regarding template elements which could not be correctly
     * translated into types during TCB generation.
     */
    function generateTypeCheckBlock(env, ref, name, meta, domSchemaChecker, oobRecorder) {
        const tcb = new Context$1(env, domSchemaChecker, oobRecorder, meta.id, meta.boundTarget, meta.pipes, meta.schemas);
        const scope = Scope$1.forNodes(tcb, null, tcb.boundTarget.target.template, /* guard */ null);
        const ctxRawType = env.referenceType(ref);
        if (!ts.isTypeReferenceNode(ctxRawType)) {
            throw new Error(`Expected TypeReferenceNode when referencing the ctx param for ${ref.debugName}`);
        }
        const paramList = [tcbCtxParam(ref.node, ctxRawType.typeName, env.config.useContextGenericType)];
        const scopeStatements = scope.render();
        const innerBody = ts.createBlock([
            ...env.getPreludeStatements(),
            ...scopeStatements,
        ]);
        // Wrap the body in an "if (true)" expression. This is unnecessary but has the effect of causing
        // the `ts.Printer` to format the type-check block nicely.
        const body = ts.createBlock([ts.createIf(ts.createTrue(), innerBody, undefined)]);
        const fnDecl = ts.createFunctionDeclaration(
        /* decorators */ undefined, 
        /* modifiers */ undefined, 
        /* asteriskToken */ undefined, 
        /* name */ name, 
        /* typeParameters */ env.config.useContextGenericType ? ref.node.typeParameters : undefined, 
        /* parameters */ paramList, 
        /* type */ undefined, 
        /* body */ body);
        addTemplateId(fnDecl, meta.id);
        return fnDecl;
    }
    /**
     * A code generation operation that's involved in the construction of a Type Check Block.
     *
     * The generation of a TCB is non-linear. Bindings within a template may result in the need to
     * construct certain types earlier than they otherwise would be constructed. That is, if the
     * generation of a TCB for a template is broken down into specific operations (constructing a
     * directive, extracting a variable from a let- operation, etc), then it's possible for operations
     * earlier in the sequence to depend on operations which occur later in the sequence.
     *
     * `TcbOp` abstracts the different types of operations which are required to convert a template into
     * a TCB. This allows for two phases of processing for the template, where 1) a linear sequence of
     * `TcbOp`s is generated, and then 2) these operations are executed, not necessarily in linear
     * order.
     *
     * Each `TcbOp` may insert statements into the body of the TCB, and also optionally return a
     * `ts.Expression` which can be used to reference the operation's result.
     */
    class TcbOp {
        /**
         * Replacement value or operation used while this `TcbOp` is executing (i.e. to resolve circular
         * references during its execution).
         *
         * This is usually a `null!` expression (which asks TS to infer an appropriate type), but another
         * `TcbOp` can be returned in cases where additional code generation is necessary to deal with
         * circular references.
         */
        circularFallback() {
            return INFER_TYPE_FOR_CIRCULAR_OP_EXPR;
        }
    }
    /**
     * A `TcbOp` which creates an expression for a native DOM element (or web component) from a
     * `TmplAstElement`.
     *
     * Executing this operation returns a reference to the element variable.
     */
    class TcbElementOp extends TcbOp {
        constructor(tcb, scope, element) {
            super();
            this.tcb = tcb;
            this.scope = scope;
            this.element = element;
        }
        execute() {
            const id = this.tcb.allocateId();
            // Add the declaration of the element using document.createElement.
            const initializer = tsCreateElement(this.element.name);
            addParseSpanInfo(initializer, this.element.startSourceSpan || this.element.sourceSpan);
            this.scope.addStatement(tsCreateVariable(id, initializer));
            return id;
        }
    }
    /**
     * A `TcbOp` which creates an expression for particular let- `TmplAstVariable` on a
     * `TmplAstTemplate`'s context.
     *
     * Executing this operation returns a reference to the variable variable (lol).
     */
    class TcbVariableOp extends TcbOp {
        constructor(tcb, scope, template, variable) {
            super();
            this.tcb = tcb;
            this.scope = scope;
            this.template = template;
            this.variable = variable;
        }
        execute() {
            // Look for a context variable for the template.
            const ctx = this.scope.resolve(this.template);
            // Allocate an identifier for the TmplAstVariable, and initialize it to a read of the variable
            // on the template context.
            const id = this.tcb.allocateId();
            const initializer = ts.createPropertyAccess(
            /* expression */ ctx, 
            /* name */ this.variable.value || '$implicit');
            addParseSpanInfo(initializer, this.variable.sourceSpan);
            // Declare the variable, and return its identifier.
            this.scope.addStatement(tsCreateVariable(id, initializer));
            return id;
        }
    }
    /**
     * A `TcbOp` which generates a variable for a `TmplAstTemplate`'s context.
     *
     * Executing this operation returns a reference to the template's context variable.
     */
    class TcbTemplateContextOp extends TcbOp {
        constructor(tcb, scope) {
            super();
            this.tcb = tcb;
            this.scope = scope;
        }
        execute() {
            // Allocate a template ctx variable and declare it with an 'any' type. The type of this variable
            // may be narrowed as a result of template guard conditions.
            const ctx = this.tcb.allocateId();
            const type = ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);
            this.scope.addStatement(tsDeclareVariable(ctx, type));
            return ctx;
        }
    }
    /**
     * A `TcbOp` which descends into a `TmplAstTemplate`'s children and generates type-checking code for
     * them.
     *
     * This operation wraps the children's type-checking code in an `if` block, which may include one
     * or more type guard conditions that narrow types within the template body.
     */
    class TcbTemplateBodyOp extends TcbOp {
        constructor(tcb, scope, template) {
            super();
            this.tcb = tcb;
            this.scope = scope;
            this.template = template;
        }
        execute() {
            // An `if` will be constructed, within which the template's children will be type checked. The
            // `if` is used for two reasons: it creates a new syntactic scope, isolating variables declared
            // in the template's TCB from the outer context, and it allows any directives on the templates
            // to perform type narrowing of either expressions or the template's context.
            //
            // The guard is the `if` block's condition. It's usually set to `true` but directives that exist
            // on the template can trigger extra guard expressions that serve to narrow types within the
            // `if`. `guard` is calculated by starting with `true` and adding other conditions as needed.
            // Collect these into `guards` by processing the directives.
            const directiveGuards = [];
            const directives = this.tcb.boundTarget.getDirectivesOfNode(this.template);
            if (directives !== null) {
                for (const dir of directives) {
                    const dirInstId = this.scope.resolve(this.template, dir);
                    const dirId = this.tcb.env.reference(dir.ref);
                    // There are two kinds of guards. Template guards (ngTemplateGuards) allow type narrowing of
                    // the expression passed to an @Input of the directive. Scan the directive to see if it has
                    // any template guards, and generate them if needed.
                    dir.ngTemplateGuards.forEach(guard => {
                        // For each template guard function on the directive, look for a binding to that input.
                        const boundInput = this.template.inputs.find(i => i.name === guard.inputName) ||
                            this.template.templateAttrs.find((i) => i instanceof BoundAttribute && i.name === guard.inputName);
                        if (boundInput !== undefined) {
                            // If there is such a binding, generate an expression for it.
                            const expr = tcbExpression(boundInput.value, this.tcb, this.scope);
                            // The expression has already been checked in the type constructor invocation, so
                            // it should be ignored when used within a template guard.
                            ignoreDiagnostics(expr);
                            if (guard.type === 'binding') {
                                // Use the binding expression itself as guard.
                                directiveGuards.push(expr);
                            }
                            else {
                                // Call the guard function on the directive with the directive instance and that
                                // expression.
                                const guardInvoke = tsCallMethod(dirId, `ngTemplateGuard_${guard.inputName}`, [
                                    dirInstId,
                                    expr,
                                ]);
                                addParseSpanInfo(guardInvoke, boundInput.value.sourceSpan);
                                directiveGuards.push(guardInvoke);
                            }
                        }
                    });
                    // The second kind of guard is a template context guard. This guard narrows the template
                    // rendering context variable `ctx`.
                    if (dir.hasNgTemplateContextGuard && this.tcb.env.config.applyTemplateContextGuards) {
                        const ctx = this.scope.resolve(this.template);
                        const guardInvoke = tsCallMethod(dirId, 'ngTemplateContextGuard', [dirInstId, ctx]);
                        addParseSpanInfo(guardInvoke, this.template.sourceSpan);
                        directiveGuards.push(guardInvoke);
                    }
                }
            }
            // By default the guard is simply `true`.
            let guard = null;
            // If there are any guards from directives, use them instead.
            if (directiveGuards.length > 0) {
                // Pop the first value and use it as the initializer to reduce(). This way, a single guard
                // will be used on its own, but two or more will be combined into binary AND expressions.
                guard = directiveGuards.reduce((expr, dirGuard) => ts.createBinary(expr, ts.SyntaxKind.AmpersandAmpersandToken, dirGuard), directiveGuards.pop());
            }
            // Create a new Scope for the template. This constructs the list of operations for the template
            // children, as well as tracks bindings within the template.
            const tmplScope = Scope$1.forNodes(this.tcb, this.scope, this.template, guard);
            // Render the template's `Scope` into a block.
            let tmplBlock = ts.createBlock(tmplScope.render());
            if (guard !== null) {
                // The scope has a guard that needs to be applied, so wrap the template block into an `if`
                // statement containing the guard expression.
                tmplBlock = ts.createIf(/* expression */ guard, /* thenStatement */ tmplBlock);
            }
            this.scope.addStatement(tmplBlock);
            return null;
        }
    }
    /**
     * A `TcbOp` which renders a text binding (interpolation) into the TCB.
     *
     * Executing this operation returns nothing.
     */
    class TcbTextInterpolationOp extends TcbOp {
        constructor(tcb, scope, binding) {
            super();
            this.tcb = tcb;
            this.scope = scope;
            this.binding = binding;
        }
        execute() {
            const expr = tcbExpression(this.binding.value, this.tcb, this.scope);
            this.scope.addStatement(ts.createExpressionStatement(expr));
            return null;
        }
    }
    /**
     * A `TcbOp` which constructs an instance of a directive with types inferred from its inputs, which
     * also checks the bindings to the directive in the process.
     *
     * Executing this operation returns a reference to the directive instance variable with its inferred
     * type.
     */
    class TcbDirectiveOp extends TcbOp {
        constructor(tcb, scope, node, dir) {
            super();
            this.tcb = tcb;
            this.scope = scope;
            this.node = node;
            this.dir = dir;
        }
        execute() {
            const id = this.tcb.allocateId();
            // Process the directive and construct expressions for each of its bindings.
            const inputs = tcbGetDirectiveInputs(this.node, this.dir, this.tcb, this.scope);
            // Call the type constructor of the directive to infer a type, and assign the directive
            // instance.
            const typeCtor = tcbCallTypeCtor(this.dir, this.tcb, inputs);
            addParseSpanInfo(typeCtor, this.node.sourceSpan);
            this.scope.addStatement(tsCreateVariable(id, typeCtor));
            return id;
        }
        circularFallback() {
            return new TcbDirectiveCircularFallbackOp(this.tcb, this.scope, this.node, this.dir);
        }
    }
    /**
     * A `TcbOp` which is used to generate a fallback expression if the inference of a directive type
     * via `TcbDirectiveOp` requires a reference to its own type. This can happen using a template
     * reference:
     *
     * ```html
     * <some-cmp #ref [prop]="ref.foo"></some-cmp>
     * ```
     *
     * In this case, `TcbDirectiveCircularFallbackOp` will add a second inference of the directive type
     * to the type-check block, this time calling the directive's type constructor without any input
     * expressions. This infers the widest possible supertype for the directive, which is used to
     * resolve any recursive references required to infer the real type.
     */
    class TcbDirectiveCircularFallbackOp extends TcbOp {
        constructor(tcb, scope, node, dir) {
            super();
            this.tcb = tcb;
            this.scope = scope;
            this.node = node;
            this.dir = dir;
        }
        execute() {
            const id = this.tcb.allocateId();
            const typeCtor = this.tcb.env.typeCtorFor(this.dir);
            const circularPlaceholder = ts.createCall(typeCtor, /* typeArguments */ undefined, [ts.createNonNullExpression(ts.createNull())]);
            this.scope.addStatement(tsCreateVariable(id, circularPlaceholder));
            return id;
        }
    }
    /**
     * A `TcbOp` which feeds elements and unclaimed properties to the `DomSchemaChecker`.
     *
     * The DOM schema is not checked via TCB code generation. Instead, the `DomSchemaChecker` ingests
     * elements and property bindings and accumulates synthetic `ts.Diagnostic`s out-of-band. These are
     * later merged with the diagnostics generated from the TCB.
     *
     * For convenience, the TCB iteration of the template is used to drive the `DomSchemaChecker` via
     * the `TcbDomSchemaCheckerOp`.
     */
    class TcbDomSchemaCheckerOp extends TcbOp {
        constructor(tcb, element, checkElement, claimedInputs) {
            super();
            this.tcb = tcb;
            this.element = element;
            this.checkElement = checkElement;
            this.claimedInputs = claimedInputs;
        }
        execute() {
            if (this.checkElement) {
                this.tcb.domSchemaChecker.checkElement(this.tcb.id, this.element, this.tcb.schemas);
            }
            // TODO(alxhub): this could be more efficient.
            for (const binding of this.element.inputs) {
                if (binding.type === 0 /* Property */ && this.claimedInputs.has(binding.name)) {
                    // Skip this binding as it was claimed by a directive.
                    continue;
                }
                if (binding.type === 0 /* Property */) {
                    if (binding.name !== 'style' && binding.name !== 'class') {
                        // A direct binding to a property.
                        const propertyName = ATTR_TO_PROP[binding.name] || binding.name;
                        this.tcb.domSchemaChecker.checkProperty(this.tcb.id, this.element, propertyName, binding.sourceSpan, this.tcb.schemas);
                    }
                }
            }
            return null;
        }
    }
    /**
     * Mapping between attributes names that don't correspond to their element property names.
     * Note: this mapping has to be kept in sync with the equally named mapping in the runtime.
     */
    const ATTR_TO_PROP = {
        'class': 'className',
        'for': 'htmlFor',
        'formaction': 'formAction',
        'innerHtml': 'innerHTML',
        'readonly': 'readOnly',
        'tabindex': 'tabIndex',
    };
    /**
     * A `TcbOp` which generates code to check "unclaimed inputs" - bindings on an element which were
     * not attributed to any directive or component, and are instead processed against the HTML element
     * itself.
     *
     * Currently, only the expressions of these bindings are checked. The targets of the bindings are
     * checked against the DOM schema via a `TcbDomSchemaCheckerOp`.
     *
     * Executing this operation returns nothing.
     */
    class TcbUnclaimedInputsOp extends TcbOp {
        constructor(tcb, scope, element, claimedInputs) {
            super();
            this.tcb = tcb;
            this.scope = scope;
            this.element = element;
            this.claimedInputs = claimedInputs;
        }
        execute() {
            // `this.inputs` contains only those bindings not matched by any directive. These bindings go to
            // the element itself.
            const elId = this.scope.resolve(this.element);
            // TODO(alxhub): this could be more efficient.
            for (const binding of this.element.inputs) {
                if (binding.type === 0 /* Property */ && this.claimedInputs.has(binding.name)) {
                    // Skip this binding as it was claimed by a directive.
                    continue;
                }
                let expr = tcbExpression(binding.value, this.tcb, this.scope);
                if (!this.tcb.env.config.checkTypeOfInputBindings) {
                    // If checking the type of bindings is disabled, cast the resulting expression to 'any'
                    // before the assignment.
                    expr = tsCastToAny(expr);
                }
                else if (!this.tcb.env.config.strictNullInputBindings) {
                    // If strict null checks are disabled, erase `null` and `undefined` from the type by
                    // wrapping the expression in a non-null assertion.
                    expr = ts.createNonNullExpression(expr);
                }
                if (this.tcb.env.config.checkTypeOfDomBindings && binding.type === 0 /* Property */) {
                    if (binding.name !== 'style' && binding.name !== 'class') {
                        // A direct binding to a property.
                        const propertyName = ATTR_TO_PROP[binding.name] || binding.name;
                        const prop = ts.createElementAccess(elId, ts.createStringLiteral(propertyName));
                        const stmt = ts.createBinary(prop, ts.SyntaxKind.EqualsToken, wrapForDiagnostics(expr));
                        addParseSpanInfo(stmt, binding.sourceSpan);
                        this.scope.addStatement(ts.createExpressionStatement(stmt));
                    }
                    else {
                        this.scope.addStatement(ts.createExpressionStatement(expr));
                    }
                }
                else {
                    // A binding to an animation, attribute, class or style. For now, only validate the right-
                    // hand side of the expression.
                    // TODO: properly check class and style bindings.
                    this.scope.addStatement(ts.createExpressionStatement(expr));
                }
            }
            return null;
        }
    }
    /**
     * A `TcbOp` which generates code to check event bindings on an element that correspond with the
     * outputs of a directive.
     *
     * Executing this operation returns nothing.
     */
    class TcbDirectiveOutputsOp extends TcbOp {
        constructor(tcb, scope, node, dir) {
            super();
            this.tcb = tcb;
            this.scope = scope;
            this.node = node;
            this.dir = dir;
        }
        execute() {
            const dirId = this.scope.resolve(this.node, this.dir);
            // `dir.outputs` is an object map of field names on the directive class to event names.
            // This is backwards from what's needed to match event handlers - a map of event names to field
            // names is desired. Invert `dir.outputs` into `fieldByEventName` to create this map.
            const fieldByEventName = new Map();
            const outputs = this.dir.outputs;
            for (const key of Object.keys(outputs)) {
                fieldByEventName.set(outputs[key], key);
            }
            for (const output of this.node.outputs) {
                if (output.type !== 0 /* Regular */ || !fieldByEventName.has(output.name)) {
                    continue;
                }
                const field = fieldByEventName.get(output.name);
                if (this.tcb.env.config.checkTypeOfOutputEvents) {
                    // For strict checking of directive events, generate a call to the `subscribe` method
                    // on the directive's output field to let type information flow into the handler function's
                    // `$event` parameter.
                    //
                    // Note that the `EventEmitter<T>` type from '@angular/core' that is typically used for
                    // outputs has a typings deficiency in its `subscribe` method. The generic type `T` is not
                    // carried into the handler function, which is vital for inference of the type of `$event`.
                    // As a workaround, the directive's field is passed into a helper function that has a
                    // specially crafted set of signatures, to effectively cast `EventEmitter<T>` to something
                    // that has a `subscribe` method that properly carries the `T` into the handler function.
                    const handler = tcbCreateEventHandler(output, this.tcb, this.scope, 0 /* Infer */);
                    const outputField = ts.createElementAccess(dirId, ts.createStringLiteral(field));
                    const outputHelper = ts.createCall(this.tcb.env.declareOutputHelper(), undefined, [outputField]);
                    const subscribeFn = ts.createPropertyAccess(outputHelper, 'subscribe');
                    const call = ts.createCall(subscribeFn, /* typeArguments */ undefined, [handler]);
                    addParseSpanInfo(call, output.sourceSpan);
                    this.scope.addStatement(ts.createExpressionStatement(call));
                }
                else {
                    // If strict checking of directive events is disabled, emit a handler function where the
                    // `$event` parameter has an explicit `any` type.
                    const handler = tcbCreateEventHandler(output, this.tcb, this.scope, 1 /* Any */);
                    this.scope.addStatement(ts.createExpressionStatement(handler));
                }
                ExpressionSemanticVisitor.visit(output.handler, this.tcb.id, this.tcb.boundTarget, this.tcb.oobRecorder);
            }
            return null;
        }
    }
    /**
     * A `TcbOp` which generates code to check "unclaimed outputs" - event bindings on an element which
     * were not attributed to any directive or component, and are instead processed against the HTML
     * element itself.
     *
     * Executing this operation returns nothing.
     */
    class TcbUnclaimedOutputsOp extends TcbOp {
        constructor(tcb, scope, element, claimedOutputs) {
            super();
            this.tcb = tcb;
            this.scope = scope;
            this.element = element;
            this.claimedOutputs = claimedOutputs;
        }
        execute() {
            const elId = this.scope.resolve(this.element);
            // TODO(alxhub): this could be more efficient.
            for (const output of this.element.outputs) {
                if (this.claimedOutputs.has(output.name)) {
                    // Skip this event handler as it was claimed by a directive.
                    continue;
                }
                if (output.type === 1 /* Animation */) {
                    // Animation output bindings always have an `$event` parameter of type `AnimationEvent`.
                    const eventType = this.tcb.env.config.checkTypeOfAnimationEvents ?
                        this.tcb.env.referenceExternalType('@angular/animations', 'AnimationEvent') :
                        1 /* Any */;
                    const handler = tcbCreateEventHandler(output, this.tcb, this.scope, eventType);
                    this.scope.addStatement(ts.createExpressionStatement(handler));
                }
                else if (this.tcb.env.config.checkTypeOfDomEvents) {
                    // If strict checking of DOM events is enabled, generate a call to `addEventListener` on
                    // the element instance so that TypeScript's type inference for
                    // `HTMLElement.addEventListener` using `HTMLElementEventMap` to infer an accurate type for
                    // `$event` depending on the event name. For unknown event names, TypeScript resorts to the
                    // base `Event` type.
                    const handler = tcbCreateEventHandler(output, this.tcb, this.scope, 0 /* Infer */);
                    const call = ts.createCall(
                    /* expression */ ts.createPropertyAccess(elId, 'addEventListener'), 
                    /* typeArguments */ undefined, 
                    /* arguments */ [ts.createStringLiteral(output.name), handler]);
                    addParseSpanInfo(call, output.sourceSpan);
                    this.scope.addStatement(ts.createExpressionStatement(call));
                }
                else {
                    // If strict checking of DOM inputs is disabled, emit a handler function where the `$event`
                    // parameter has an explicit `any` type.
                    const handler = tcbCreateEventHandler(output, this.tcb, this.scope, 1 /* Any */);
                    this.scope.addStatement(ts.createExpressionStatement(handler));
                }
                ExpressionSemanticVisitor.visit(output.handler, this.tcb.id, this.tcb.boundTarget, this.tcb.oobRecorder);
            }
            return null;
        }
    }
    /**
     * Value used to break a circular reference between `TcbOp`s.
     *
     * This value is returned whenever `TcbOp`s have a circular dependency. The expression is a non-null
     * assertion of the null value (in TypeScript, the expression `null!`). This construction will infer
     * the least narrow type for whatever it's assigned to.
     */
    const INFER_TYPE_FOR_CIRCULAR_OP_EXPR = ts.createNonNullExpression(ts.createNull());
    /**
     * Overall generation context for the type check block.
     *
     * `Context` handles operations during code generation which are global with respect to the whole
     * block. It's responsible for variable name allocation and management of any imports needed. It
     * also contains the template metadata itself.
     */
    class Context$1 {
        constructor(env, domSchemaChecker, oobRecorder, id, boundTarget, pipes, schemas) {
            this.env = env;
            this.domSchemaChecker = domSchemaChecker;
            this.oobRecorder = oobRecorder;
            this.id = id;
            this.boundTarget = boundTarget;
            this.pipes = pipes;
            this.schemas = schemas;
            this.nextId = 1;
        }
        /**
         * Allocate a new variable name for use within the `Context`.
         *
         * Currently this uses a monotonically increasing counter, but in the future the variable name
         * might change depending on the type of data being stored.
         */
        allocateId() {
            return ts.createIdentifier(`_t${this.nextId++}`);
        }
        getPipeByName(name) {
            if (!this.pipes.has(name)) {
                return null;
            }
            return this.env.pipeInst(this.pipes.get(name));
        }
    }
    /**
     * Local scope within the type check block for a particular template.
     *
     * The top-level template and each nested `<ng-template>` have their own `Scope`, which exist in a
     * hierarchy. The structure of this hierarchy mirrors the syntactic scopes in the generated type
     * check block, where each nested template is encased in an `if` structure.
     *
     * As a template's `TcbOp`s are executed in a given `Scope`, statements are added via
     * `addStatement()`. When this processing is complete, the `Scope` can be turned into a `ts.Block`
     * via `renderToBlock()`.
     *
     * If a `TcbOp` requires the output of another, it can call `resolve()`.
     */
    class Scope$1 {
        constructor(tcb, parent = null, guard = null) {
            this.tcb = tcb;
            this.parent = parent;
            this.guard = guard;
            /**
             * A queue of operations which need to be performed to generate the TCB code for this scope.
             *
             * This array can contain either a `TcbOp` which has yet to be executed, or a `ts.Expression|null`
             * representing the memoized result of executing the operation. As operations are executed, their
             * results are written into the `opQueue`, overwriting the original operation.
             *
             * If an operation is in the process of being executed, it is temporarily overwritten here with
             * `INFER_TYPE_FOR_CIRCULAR_OP_EXPR`. This way, if a cycle is encountered where an operation
             * depends transitively on its own result, the inner operation will infer the least narrow type
             * that fits instead. This has the same semantics as TypeScript itself when types are referenced
             * circularly.
             */
            this.opQueue = [];
            /**
             * A map of `TmplAstElement`s to the index of their `TcbElementOp` in the `opQueue`
             */
            this.elementOpMap = new Map();
            /**
             * A map of maps which tracks the index of `TcbDirectiveOp`s in the `opQueue` for each directive
             * on a `TmplAstElement` or `TmplAstTemplate` node.
             */
            this.directiveOpMap = new Map();
            /**
             * Map of immediately nested <ng-template>s (within this `Scope`) represented by `TmplAstTemplate`
             * nodes to the index of their `TcbTemplateContextOp`s in the `opQueue`.
             */
            this.templateCtxOpMap = new Map();
            /**
             * Map of variables declared on the template that created this `Scope` (represented by
             * `TmplAstVariable` nodes) to the index of their `TcbVariableOp`s in the `opQueue`.
             */
            this.varMap = new Map();
            /**
             * Statements for this template.
             *
             * Executing the `TcbOp`s in the `opQueue` populates this array.
             */
            this.statements = [];
        }
        /**
         * Constructs a `Scope` given either a `TmplAstTemplate` or a list of `TmplAstNode`s.
         *
         * @param tcb the overall context of TCB generation.
         * @param parent the `Scope` of the parent template (if any) or `null` if this is the root
         * `Scope`.
         * @param templateOrNodes either a `TmplAstTemplate` representing the template for which to
         * calculate the `Scope`, or a list of nodes if no outer template object is available.
         * @param guard an expression that is applied to this scope for type narrowing purposes.
         */
        static forNodes(tcb, parent, templateOrNodes, guard) {
            const scope = new Scope$1(tcb, parent, guard);
            let children;
            // If given an actual `TmplAstTemplate` instance, then process any additional information it
            // has.
            if (templateOrNodes instanceof Template) {
                // The template's variable declarations need to be added as `TcbVariableOp`s.
                const varMap = new Map();
                for (const v of templateOrNodes.variables) {
                    // Validate that variables on the `TmplAstTemplate` are only declared once.
                    if (!varMap.has(v.name)) {
                        varMap.set(v.name, v);
                    }
                    else {
                        const firstDecl = varMap.get(v.name);
                        tcb.oobRecorder.duplicateTemplateVar(tcb.id, v, firstDecl);
                    }
                    const opIndex = scope.opQueue.push(new TcbVariableOp(tcb, scope, templateOrNodes, v)) - 1;
                    scope.varMap.set(v, opIndex);
                }
                children = templateOrNodes.children;
            }
            else {
                children = templateOrNodes;
            }
            for (const node of children) {
                scope.appendNode(node);
            }
            return scope;
        }
        /**
         * Look up a `ts.Expression` representing the value of some operation in the current `Scope`,
         * including any parent scope(s).
         *
         * @param node a `TmplAstNode` of the operation in question. The lookup performed will depend on
         * the type of this node:
         *
         * Assuming `directive` is not present, then `resolve` will return:
         *
         * * `TmplAstElement` - retrieve the expression for the element DOM node
         * * `TmplAstTemplate` - retrieve the template context variable
         * * `TmplAstVariable` - retrieve a template let- variable
         *
         * @param directive if present, a directive type on a `TmplAstElement` or `TmplAstTemplate` to
         * look up instead of the default for an element or template node.
         */
        resolve(node, directive) {
            // Attempt to resolve the operation locally.
            const res = this.resolveLocal(node, directive);
            if (res !== null) {
                return res;
            }
            else if (this.parent !== null) {
                // Check with the parent.
                return this.parent.resolve(node, directive);
            }
            else {
                throw new Error(`Could not resolve ${node} / ${directive}`);
            }
        }
        /**
         * Add a statement to this scope.
         */
        addStatement(stmt) {
            this.statements.push(stmt);
        }
        /**
         * Get the statements.
         */
        render() {
            for (let i = 0; i < this.opQueue.length; i++) {
                this.executeOp(i);
            }
            return this.statements;
        }
        /**
         * Returns an expression of all template guards that apply to this scope, including those of
         * parent scopes. If no guards have been applied, null is returned.
         */
        guards() {
            let parentGuards = null;
            if (this.parent !== null) {
                // Start with the guards from the parent scope, if present.
                parentGuards = this.parent.guards();
            }
            if (this.guard === null) {
                // This scope does not have a guard, so return the parent's guards as is.
                return parentGuards;
            }
            else if (parentGuards === null) {
                // There's no guards from the parent scope, so this scope's guard represents all available
                // guards.
                return this.guard;
            }
            else {
                // Both the parent scope and this scope provide a guard, so create a combination of the two.
                // It is important that the parent guard is used as left operand, given that it may provide
                // narrowing that is required for this scope's guard to be valid.
                return ts.createBinary(parentGuards, ts.SyntaxKind.AmpersandAmpersandToken, this.guard);
            }
        }
        resolveLocal(ref, directive) {
            if (ref instanceof Variable && this.varMap.has(ref)) {
                // Resolving a context variable for this template.
                // Execute the `TcbVariableOp` associated with the `TmplAstVariable`.
                return this.resolveOp(this.varMap.get(ref));
            }
            else if (ref instanceof Template && directive === undefined &&
                this.templateCtxOpMap.has(ref)) {
                // Resolving the context of the given sub-template.
                // Execute the `TcbTemplateContextOp` for the template.
                return this.resolveOp(this.templateCtxOpMap.get(ref));
            }
            else if ((ref instanceof Element || ref instanceof Template) &&
                directive !== undefined && this.directiveOpMap.has(ref)) {
                // Resolving a directive on an element or sub-template.
                const dirMap = this.directiveOpMap.get(ref);
                if (dirMap.has(directive)) {
                    return this.resolveOp(dirMap.get(directive));
                }
                else {
                    return null;
                }
            }
            else if (ref instanceof Element && this.elementOpMap.has(ref)) {
                // Resolving the DOM node of an element in this template.
                return this.resolveOp(this.elementOpMap.get(ref));
            }
            else {
                return null;
            }
        }
        /**
         * Like `executeOp`, but assert that the operation actually returned `ts.Expression`.
         */
        resolveOp(opIndex) {
            const res = this.executeOp(opIndex);
            if (res === null) {
                throw new Error(`Error resolving operation, got null`);
            }
            return res;
        }
        /**
         * Execute a particular `TcbOp` in the `opQueue`.
         *
         * This method replaces the operation in the `opQueue` with the result of execution (once done)
         * and also protects against a circular dependency from the operation to itself by temporarily
         * setting the operation's result to a special expression.
         */
        executeOp(opIndex) {
            const op = this.opQueue[opIndex];
            if (!(op instanceof TcbOp)) {
                return op;
            }
            // Set the result of the operation in the queue to its circular fallback. If executing this
            // operation results in a circular dependency, this will prevent an infinite loop and allow for
            // the resolution of such cycles.
            this.opQueue[opIndex] = op.circularFallback();
            const res = op.execute();
            // Once the operation has finished executing, it's safe to cache the real result.
            this.opQueue[opIndex] = res;
            return res;
        }
        appendNode(node) {
            if (node instanceof Element) {
                const opIndex = this.opQueue.push(new TcbElementOp(this.tcb, this, node)) - 1;
                this.elementOpMap.set(node, opIndex);
                this.appendDirectivesAndInputsOfNode(node);
                this.appendOutputsOfNode(node);
                for (const child of node.children) {
                    this.appendNode(child);
                }
                this.checkReferencesOfNode(node);
            }
            else if (node instanceof Template) {
                // Template children are rendered in a child scope.
                this.appendDirectivesAndInputsOfNode(node);
                this.appendOutputsOfNode(node);
                if (this.tcb.env.config.checkTemplateBodies) {
                    const ctxIndex = this.opQueue.push(new TcbTemplateContextOp(this.tcb, this)) - 1;
                    this.templateCtxOpMap.set(node, ctxIndex);
                    this.opQueue.push(new TcbTemplateBodyOp(this.tcb, this, node));
                }
                this.checkReferencesOfNode(node);
            }
            else if (node instanceof BoundText) {
                this.opQueue.push(new TcbTextInterpolationOp(this.tcb, this, node));
            }
        }
        checkReferencesOfNode(node) {
            for (const ref of node.references) {
                if (this.tcb.boundTarget.getReferenceTarget(ref) === null) {
                    this.tcb.oobRecorder.missingReferenceTarget(this.tcb.id, ref);
                }
            }
        }
        appendDirectivesAndInputsOfNode(node) {
            // Collect all the inputs on the element.
            const claimedInputs = new Set();
            const directives = this.tcb.boundTarget.getDirectivesOfNode(node);
            if (directives === null || directives.length === 0) {
                // If there are no directives, then all inputs are unclaimed inputs, so queue an operation
                // to add them if needed.
                if (node instanceof Element) {
                    this.opQueue.push(new TcbUnclaimedInputsOp(this.tcb, this, node, claimedInputs));
                    this.opQueue.push(new TcbDomSchemaCheckerOp(this.tcb, node, /* checkElement */ true, claimedInputs));
                }
                return;
            }
            const dirMap = new Map();
            for (const dir of directives) {
                const dirIndex = this.opQueue.push(new TcbDirectiveOp(this.tcb, this, node, dir)) - 1;
                dirMap.set(dir, dirIndex);
            }
            this.directiveOpMap.set(node, dirMap);
            // After expanding the directives, we might need to queue an operation to check any unclaimed
            // inputs.
            if (node instanceof Element) {
                // Go through the directives and remove any inputs that it claims from `elementInputs`.
                for (const dir of directives) {
                    for (const fieldName of Object.keys(dir.inputs)) {
                        const value = dir.inputs[fieldName];
                        claimedInputs.add(Array.isArray(value) ? value[0] : value);
                    }
                }
                this.opQueue.push(new TcbUnclaimedInputsOp(this.tcb, this, node, claimedInputs));
                // If there are no directives which match this element, then it's a "plain" DOM element (or a
                // web component), and should be checked against the DOM schema. If any directives match,
                // we must assume that the element could be custom (either a component, or a directive like
                // <router-outlet>) and shouldn't validate the element name itself.
                const checkElement = directives.length === 0;
                this.opQueue.push(new TcbDomSchemaCheckerOp(this.tcb, node, checkElement, claimedInputs));
            }
        }
        appendOutputsOfNode(node) {
            // Collect all the outputs on the element.
            const claimedOutputs = new Set();
            const directives = this.tcb.boundTarget.getDirectivesOfNode(node);
            if (directives === null || directives.length === 0) {
                // If there are no directives, then all outputs are unclaimed outputs, so queue an operation
                // to add them if needed.
                if (node instanceof Element) {
                    this.opQueue.push(new TcbUnclaimedOutputsOp(this.tcb, this, node, claimedOutputs));
                }
                return;
            }
            // Queue operations for all directives to check the relevant outputs for a directive.
            for (const dir of directives) {
                this.opQueue.push(new TcbDirectiveOutputsOp(this.tcb, this, node, dir));
            }
            // After expanding the directives, we might need to queue an operation to check any unclaimed
            // outputs.
            if (node instanceof Element) {
                // Go through the directives and register any outputs that it claims in `claimedOutputs`.
                for (const dir of directives) {
                    for (const outputField of Object.keys(dir.outputs)) {
                        claimedOutputs.add(dir.outputs[outputField]);
                    }
                }
                this.opQueue.push(new TcbUnclaimedOutputsOp(this.tcb, this, node, claimedOutputs));
            }
        }
    }
    /**
     * Create the `ctx` parameter to the top-level TCB function.
     *
     * This is a parameter with a type equivalent to the component type, with all generic type
     * parameters listed (without their generic bounds).
     */
    function tcbCtxParam(node, name, useGenericType) {
        let typeArguments = undefined;
        // Check if the component is generic, and pass generic type parameters if so.
        if (node.typeParameters !== undefined) {
            if (useGenericType) {
                typeArguments =
                    node.typeParameters.map(param => ts.createTypeReferenceNode(param.name, undefined));
            }
            else {
                typeArguments =
                    node.typeParameters.map(() => ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));
            }
        }
        const type = ts.createTypeReferenceNode(name, typeArguments);
        return ts.createParameter(
        /* decorators */ undefined, 
        /* modifiers */ undefined, 
        /* dotDotDotToken */ undefined, 
        /* name */ 'ctx', 
        /* questionToken */ undefined, 
        /* type */ type, 
        /* initializer */ undefined);
    }
    /**
     * Process an `AST` expression and convert it into a `ts.Expression`, generating references to the
     * correct identifiers in the current scope.
     */
    function tcbExpression(ast, tcb, scope) {
        const translator = new TcbExpressionTranslator(tcb, scope);
        return translator.translate(ast);
    }
    class TcbExpressionTranslator {
        constructor(tcb, scope) {
            this.tcb = tcb;
            this.scope = scope;
        }
        translate(ast) {
            // `astToTypescript` actually does the conversion. A special resolver `tcbResolve` is passed
            // which interprets specific expression nodes that interact with the `ImplicitReceiver`. These
            // nodes actually refer to identifiers within the current scope.
            return astToTypescript(ast, ast => this.resolve(ast), this.tcb.env.config);
        }
        /**
         * Resolve an `AST` expression within the given scope.
         *
         * Some `AST` expressions refer to top-level concepts (references, variables, the component
         * context). This method assists in resolving those.
         */
        resolve(ast) {
            if (ast instanceof PropertyRead && ast.receiver instanceof ImplicitReceiver) {
                // Try to resolve a bound target for this expression. If no such target is available, then
                // the expression is referencing the top-level component context. In that case, `null` is
                // returned here to let it fall through resolution so it will be caught when the
                // `ImplicitReceiver` is resolved in the branch below.
                return this.resolveTarget(ast);
            }
            else if (ast instanceof PropertyWrite && ast.receiver instanceof ImplicitReceiver) {
                const target = this.resolveTarget(ast);
                if (target === null) {
                    return null;
                }
                const expr = this.translate(ast.value);
                const result = ts.createParen(ts.createBinary(target, ts.SyntaxKind.EqualsToken, expr));
                addParseSpanInfo(result, ast.sourceSpan);
                return result;
            }
            else if (ast instanceof ImplicitReceiver) {
                // AST instances representing variables and references look very similar to property reads
                // or method calls from the component context: both have the shape
                // PropertyRead(ImplicitReceiver, 'propName') or MethodCall(ImplicitReceiver, 'methodName').
                //
                // `translate` will first try to `resolve` the outer PropertyRead/MethodCall. If this works,
                // it's because the `BoundTarget` found an expression target for the whole expression, and
                // therefore `translate` will never attempt to `resolve` the ImplicitReceiver of that
                // PropertyRead/MethodCall.
                //
                // Therefore if `resolve` is called on an `ImplicitReceiver`, it's because no outer
                // PropertyRead/MethodCall resolved to a variable or reference, and therefore this is a
                // property read or method call on the component context itself.
                return ts.createIdentifier('ctx');
            }
            else if (ast instanceof BindingPipe) {
                const expr = this.translate(ast.exp);
                let pipe;
                if (this.tcb.env.config.checkTypeOfPipes) {
                    pipe = this.tcb.getPipeByName(ast.name);
                    if (pipe === null) {
                        // No pipe by that name exists in scope. Record this as an error.
                        this.tcb.oobRecorder.missingPipe(this.tcb.id, ast);
                        // Return an 'any' value to at least allow the rest of the expression to be checked.
                        pipe = NULL_AS_ANY;
                    }
                }
                else {
                    pipe = ts.createParen(ts.createAsExpression(ts.createNull(), ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword)));
                }
                const args = ast.args.map(arg => this.translate(arg));
                const result = tsCallMethod(pipe, 'transform', [expr, ...args]);
                addParseSpanInfo(result, ast.sourceSpan);
                return result;
            }
            else if (ast instanceof MethodCall && ast.receiver instanceof ImplicitReceiver) {
                // Resolve the special `$any(expr)` syntax to insert a cast of the argument to type `any`.
                // `$any(expr)` -> `expr as any`
                if (ast.name === '$any' && ast.args.length === 1) {
                    const expr = this.translate(ast.args[0]);
                    const exprAsAny = ts.createAsExpression(expr, ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));
                    const result = ts.createParen(exprAsAny);
                    addParseSpanInfo(result, ast.sourceSpan);
                    return result;
                }
                // Attempt to resolve a bound target for the method, and generate the method call if a target
                // could be resolved. If no target is available, then the method is referencing the top-level
                // component context, in which case `null` is returned to let the `ImplicitReceiver` being
                // resolved to the component context.
                const receiver = this.resolveTarget(ast);
                if (receiver === null) {
                    return null;
                }
                const method = ts.createPropertyAccess(wrapForDiagnostics(receiver), ast.name);
                addParseSpanInfo(method, ast.nameSpan);
                const args = ast.args.map(arg => this.translate(arg));
                const node = ts.createCall(method, undefined, args);
                addParseSpanInfo(node, ast.sourceSpan);
                return node;
            }
            else {
                // This AST isn't special after all.
                return null;
            }
        }
        /**
         * Attempts to resolve a bound target for a given expression, and translates it into the
         * appropriate `ts.Expression` that represents the bound target. If no target is available,
         * `null` is returned.
         */
        resolveTarget(ast) {
            const binding = this.tcb.boundTarget.getExpressionTarget(ast);
            if (binding === null) {
                return null;
            }
            // This expression has a binding to some variable or reference in the template. Resolve it.
            if (binding instanceof Variable) {
                const expr = ts.getMutableClone(this.scope.resolve(binding));
                addParseSpanInfo(expr, ast.sourceSpan);
                return expr;
            }
            else if (binding instanceof Reference) {
                const target = this.tcb.boundTarget.getReferenceTarget(binding);
                if (target === null) {
                    // This reference is unbound. Traversal of the `TmplAstReference` itself should have
                    // recorded the error in the `OutOfBandDiagnosticRecorder`.
                    // Still check the rest of the expression if possible by using an `any` value.
                    return NULL_AS_ANY;
                }
                // The reference is either to an element, an <ng-template> node, or to a directive on an
                // element or template.
                if (target instanceof Element) {
                    if (!this.tcb.env.config.checkTypeOfDomReferences) {
                        // References to DOM nodes are pinned to 'any'.
                        return NULL_AS_ANY;
                    }
                    const expr = ts.getMutableClone(this.scope.resolve(target));
                    addParseSpanInfo(expr, ast.sourceSpan);
                    return expr;
                }
                else if (target instanceof Template) {
                    if (!this.tcb.env.config.checkTypeOfNonDomReferences) {
                        // References to `TemplateRef`s pinned to 'any'.
                        return NULL_AS_ANY;
                    }
                    // Direct references to an <ng-template> node simply require a value of type
                    // `TemplateRef<any>`. To get this, an expression of the form
                    // `(null as any as TemplateRef<any>)` is constructed.
                    let value = ts.createNull();
                    value = ts.createAsExpression(value, ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));
                    value = ts.createAsExpression(value, this.tcb.env.referenceExternalType('@angular/core', 'TemplateRef', [DYNAMIC_TYPE]));
                    value = ts.createParen(value);
                    addParseSpanInfo(value, ast.sourceSpan);
                    return value;
                }
                else {
                    if (!this.tcb.env.config.checkTypeOfNonDomReferences) {
                        // References to directives are pinned to 'any'.
                        return NULL_AS_ANY;
                    }
                    const expr = ts.getMutableClone(this.scope.resolve(target.node, target.directive));
                    addParseSpanInfo(expr, ast.sourceSpan);
                    return expr;
                }
            }
            else {
                throw new Error(`Unreachable: ${binding}`);
            }
        }
    }
    /**
     * Call the type constructor of a directive instance on a given template node, inferring a type for
     * the directive instance from any bound inputs.
     */
    function tcbCallTypeCtor(dir, tcb, inputs) {
        const typeCtor = tcb.env.typeCtorFor(dir);
        // Construct an array of `ts.PropertyAssignment`s for each of the directive's inputs.
        const members = inputs.map(input => {
            const propertyName = ts.createStringLiteral(input.field);
            if (input.type === 'binding') {
                // For bound inputs, the property is assigned the binding expression.
                let expr = input.expression;
                if (!tcb.env.config.checkTypeOfInputBindings) {
                    // If checking the type of bindings is disabled, cast the resulting expression to 'any'
                    // before the assignment.
                    expr = tsCastToAny(expr);
                }
                else if (!tcb.env.config.strictNullInputBindings) {
                    // If strict null checks are disabled, erase `null` and `undefined` from the type by
                    // wrapping the expression in a non-null assertion.
                    expr = ts.createNonNullExpression(expr);
                }
                const assignment = ts.createPropertyAssignment(propertyName, wrapForDiagnostics(expr));
                addParseSpanInfo(assignment, input.sourceSpan);
                return assignment;
            }
            else {
                // A type constructor is required to be called with all input properties, so any unset
                // inputs are simply assigned a value of type `any` to ignore them.
                return ts.createPropertyAssignment(propertyName, NULL_AS_ANY);
            }
        });
        // Call the `ngTypeCtor` method on the directive class, with an object literal argument created
        // from the matched inputs.
        return ts.createCall(
        /* expression */ typeCtor, 
        /* typeArguments */ undefined, 
        /* argumentsArray */ [ts.createObjectLiteral(members)]);
    }
    function tcbGetDirectiveInputs(el, dir, tcb, scope) {
        // Only the first binding to a property is written.
        // TODO(alxhub): produce an error for duplicate bindings to the same property, independently of
        // this logic.
        const directiveInputs = new Map();
        // `dir.inputs` is an object map of field names on the directive class to property names.
        // This is backwards from what's needed to match bindings - a map of properties to field names
        // is desired. Invert `dir.inputs` into `propMatch` to create this map.
        const propMatch = new Map();
        const inputs = dir.inputs;
        Object.keys(inputs).forEach(key => {
            Array.isArray(inputs[key]) ? propMatch.set(inputs[key][0], key) :
                propMatch.set(inputs[key], key);
        });
        el.inputs.forEach(processAttribute);
        el.attributes.forEach(processAttribute);
        if (el instanceof Template) {
            el.templateAttrs.forEach(processAttribute);
        }
        // Add unset directive inputs for each of the remaining unset fields.
        // Note: it's actually important here that `propMatch.values()` isn't used, as there can be
        // multiple fields which share the same property name and only one of them will be listed as a
        // value in `propMatch`.
        for (const field of Object.keys(inputs)) {
            if (!directiveInputs.has(field)) {
                directiveInputs.set(field, { type: 'unset', field });
            }
        }
        return Array.from(directiveInputs.values());
        /**
         * Add a binding expression to the map for each input/template attribute of the directive that has
         * a matching binding.
         */
        function processAttribute(attr) {
            // Skip non-property bindings.
            if (attr instanceof BoundAttribute && attr.type !== 0 /* Property */) {
                return;
            }
            // Skip text attributes if configured to do so.
            if (!tcb.env.config.checkTypeOfAttributes && attr instanceof TextAttribute) {
                return;
            }
            // Skip the attribute if the directive does not have an input for it.
            if (!propMatch.has(attr.name)) {
                return;
            }
            const field = propMatch.get(attr.name);
            // Skip the attribute if a previous binding also wrote to it.
            if (directiveInputs.has(field)) {
                return;
            }
            let expr;
            if (attr instanceof BoundAttribute) {
                // Produce an expression representing the value of the binding.
                expr = tcbExpression(attr.value, tcb, scope);
            }
            else {
                // For regular attributes with a static string value, use the represented string literal.
                expr = ts.createStringLiteral(attr.value);
            }
            directiveInputs.set(field, {
                type: 'binding',
                field: field,
                expression: expr,
                sourceSpan: attr.sourceSpan,
            });
        }
    }
    const EVENT_PARAMETER = '$event';
    /**
     * Creates an arrow function to be used as handler function for event bindings. The handler
     * function has a single parameter `$event` and the bound event's handler `AST` represented as a
     * TypeScript expression as its body.
     *
     * When `eventType` is set to `Infer`, the `$event` parameter will not have an explicit type. This
     * allows for the created handler function to have its `$event` parameter's type inferred based on
     * how it's used, to enable strict type checking of event bindings. When set to `Any`, the `$event`
     * parameter will have an explicit `any` type, effectively disabling strict type checking of event
     * bindings. Alternatively, an explicit type can be passed for the `$event` parameter.
     */
    function tcbCreateEventHandler(event, tcb, scope, eventType) {
        const handler = tcbEventHandlerExpression(event.handler, tcb, scope);
        let eventParamType;
        if (eventType === 0 /* Infer */) {
            eventParamType = undefined;
        }
        else if (eventType === 1 /* Any */) {
            eventParamType = ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);
        }
        else {
            eventParamType = eventType;
        }
        // Obtain all guards that have been applied to the scope and its parents, as they have to be
        // repeated within the handler function for their narrowing to be in effect within the handler.
        const guards = scope.guards();
        let body = ts.createExpressionStatement(handler);
        if (guards !== null) {
            // Wrap the body in an `if` statement containing all guards that have to be applied.
            body = ts.createIf(guards, body);
        }
        const eventParam = ts.createParameter(
        /* decorators */ undefined, 
        /* modifiers */ undefined, 
        /* dotDotDotToken */ undefined, 
        /* name */ EVENT_PARAMETER, 
        /* questionToken */ undefined, 
        /* type */ eventParamType);
        return ts.createFunctionExpression(
        /* modifier */ undefined, 
        /* asteriskToken */ undefined, 
        /* name */ undefined, 
        /* typeParameters */ undefined, 
        /* parameters */ [eventParam], 
        /* type */ ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword), 
        /* body */ ts.createBlock([body]));
    }
    /**
     * Similar to `tcbExpression`, this function converts the provided `AST` expression into a
     * `ts.Expression`, with special handling of the `$event` variable that can be used within event
     * bindings.
     */
    function tcbEventHandlerExpression(ast, tcb, scope) {
        const translator = new TcbEventHandlerTranslator(tcb, scope);
        return translator.translate(ast);
    }
    class TcbEventHandlerTranslator extends TcbExpressionTranslator {
        resolve(ast) {
            // Recognize a property read on the implicit receiver corresponding with the event parameter
            // that is available in event bindings. Since this variable is a parameter of the handler
            // function that the converted expression becomes a child of, just create a reference to the
            // parameter by its name.
            if (ast instanceof PropertyRead && ast.receiver instanceof ImplicitReceiver &&
                ast.name === EVENT_PARAMETER) {
                const event = ts.createIdentifier(EVENT_PARAMETER);
                addParseSpanInfo(event, ast.nameSpan);
                return event;
            }
            return super.resolve(ast);
        }
    }
    function requiresInlineTypeCheckBlock(node) {
        // In order to qualify for a declared TCB (not inline) two conditions must be met:
        // 1) the class must be exported
        // 2) it must not have constrained generic types
        if (!checkIfClassIsExported(node)) {
            // Condition 1 is false, the class is not exported.
            return true;
        }
        else if (!checkIfGenericTypesAreUnbound(node)) {
            // Condition 2 is false, the class has constrained generic types
            return true;
        }
        else {
            return false;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An `Environment` representing the single type-checking file into which most (if not all) Type
     * Check Blocks (TCBs) will be generated.
     *
     * The `TypeCheckFile` hosts multiple TCBs and allows the sharing of declarations (e.g. type
     * constructors) between them. Rather than return such declarations via `getPreludeStatements()`, it
     * hoists them to the top of the generated `ts.SourceFile`.
     */
    class TypeCheckFile extends Environment {
        constructor(fileName, config, refEmitter, reflector, compilerHost) {
            super(config, new ImportManager(new NoopImportRewriter(), 'i'), refEmitter, reflector, ts.createSourceFile(compilerHost.getCanonicalFileName(fileName), '', ts.ScriptTarget.Latest, true));
            this.fileName = fileName;
            this.nextTcbId = 1;
            this.tcbStatements = [];
        }
        addTypeCheckBlock(ref, meta, domSchemaChecker, oobRecorder) {
            const fnId = ts.createIdentifier(`_tcb${this.nextTcbId++}`);
            const fn = generateTypeCheckBlock(this, ref, fnId, meta, domSchemaChecker, oobRecorder);
            this.tcbStatements.push(fn);
        }
        render() {
            let source = this.importManager.getAllImports(this.contextFile.fileName)
                .map(i => `import * as ${i.qualifier} from '${i.specifier}';`)
                .join('\n') +
                '\n\n';
            const printer = ts.createPrinter();
            source += '\n';
            for (const stmt of this.helperStatements) {
                source += printer.printNode(ts.EmitHint.Unspecified, stmt, this.contextFile) + '\n';
            }
            for (const stmt of this.pipeInstStatements) {
                source += printer.printNode(ts.EmitHint.Unspecified, stmt, this.contextFile) + '\n';
            }
            for (const stmt of this.typeCtorStatements) {
                source += printer.printNode(ts.EmitHint.Unspecified, stmt, this.contextFile) + '\n';
            }
            source += '\n';
            for (const stmt of this.tcbStatements) {
                source += printer.printNode(ts.EmitHint.Unspecified, stmt, this.contextFile) + '\n';
            }
            // Ensure the template type-checking file is an ES module. Otherwise, it's interpreted as some
            // kind of global namespace in TS, which forces a full re-typecheck of the user's program that
            // is somehow more expensive than the initial parse.
            source += '\nexport const IS_A_MODULE = true;\n';
            return source;
        }
        getPreludeStatements() {
            return [];
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * How a type-checking context should handle operations which would require inlining.
     */
    var InliningMode;
    (function (InliningMode) {
        /**
         * Use inlining operations when required.
         */
        InliningMode[InliningMode["InlineOps"] = 0] = "InlineOps";
        /**
         * Produce diagnostics if an operation would require inlining.
         */
        InliningMode[InliningMode["Error"] = 1] = "Error";
    })(InliningMode || (InliningMode = {}));
    /**
     * A template type checking context for a program.
     *
     * The `TypeCheckContext` allows registration of components and their templates which need to be
     * type checked.
     */
    class TypeCheckContextImpl {
        constructor(config, compilerHost, componentMappingStrategy, refEmitter, reflector, host, inlining) {
            this.config = config;
            this.compilerHost = compilerHost;
            this.componentMappingStrategy = componentMappingStrategy;
            this.refEmitter = refEmitter;
            this.reflector = reflector;
            this.host = host;
            this.inlining = inlining;
            this.fileMap = new Map();
            /**
             * A `Map` of `ts.SourceFile`s that the context has seen to the operations (additions of methods
             * or type-check blocks) that need to be eventually performed on that file.
             */
            this.opMap = new Map();
            /**
             * Tracks when an a particular class has a pending type constructor patching operation already
             * queued.
             */
            this.typeCtorPending = new Set();
        }
        /**
         * Record a template for the given component `node`, with a `SelectorMatcher` for directive
         * matching.
         *
         * @param node class of the node being recorded.
         * @param template AST nodes of the template being recorded.
         * @param matcher `SelectorMatcher` which tracks directives that are in scope for this template.
         */
        addTemplate(ref, binder, template, pipes, schemas, sourceMapping, file) {
            if (!this.host.shouldCheckComponent(ref.node)) {
                return;
            }
            const sfPath = absoluteFromSourceFile(ref.node.getSourceFile());
            const overrideTemplate = this.host.getTemplateOverride(sfPath, ref.node);
            if (overrideTemplate !== null) {
                template = overrideTemplate;
            }
            // Accumulate a list of any directives which could not have type constructors generated due to
            // unsupported inlining operations.
            let missingInlines = [];
            const fileData = this.dataForFile(ref.node.getSourceFile());
            const shimData = this.pendingShimForComponent(ref.node);
            const boundTarget = binder.bind({ template });
            // Get all of the directives used in the template and record type constructors for all of them.
            for (const dir of boundTarget.getUsedDirectives()) {
                const dirRef = dir.ref;
                const dirNode = dirRef.node;
                if (requiresInlineTypeCtor(dirNode, this.reflector)) {
                    if (this.inlining === InliningMode.Error) {
                        missingInlines.push(dirNode);
                        continue;
                    }
                    // Add a type constructor operation for the directive.
                    this.addInlineTypeCtor(fileData, dirNode.getSourceFile(), dirRef, {
                        fnName: 'ngTypeCtor',
                        // The constructor should have a body if the directive comes from a .ts file, but not if
                        // it comes from a .d.ts file. .d.ts declarations don't have bodies.
                        body: !dirNode.getSourceFile().isDeclarationFile,
                        fields: {
                            inputs: Object.keys(dir.inputs),
                            outputs: Object.keys(dir.outputs),
                            // TODO(alxhub): support queries
                            queries: dir.queries,
                        },
                        coercedInputFields: dir.coercedInputFields,
                    });
                }
            }
            const templateId = fileData.sourceManager.getTemplateId(ref.node);
            shimData.templates.set(templateId, {
                template,
                boundTarget,
            });
            const tcbRequiresInline = requiresInlineTypeCheckBlock(ref.node);
            // If inlining is not supported, but is required for either the TCB or one of its directive
            // dependencies, then exit here with an error.
            if (this.inlining === InliningMode.Error && (tcbRequiresInline || missingInlines.length > 0)) {
                // This template cannot be supported because the underlying strategy does not support inlining
                // and inlining would be required.
                // Record diagnostics to indicate the issues with this template.
                if (tcbRequiresInline) {
                    shimData.oobRecorder.requiresInlineTcb(templateId, ref.node);
                }
                if (missingInlines.length > 0) {
                    shimData.oobRecorder.requiresInlineTypeConstructors(templateId, ref.node, missingInlines);
                }
                // Checking this template would be unsupported, so don't try.
                return;
            }
            const meta = {
                id: fileData.sourceManager.captureSource(ref.node, sourceMapping, file),
                boundTarget,
                pipes,
                schemas,
            };
            if (tcbRequiresInline) {
                // This class didn't meet the requirements for external type checking, so generate an inline
                // TCB for the class.
                this.addInlineTypeCheckBlock(fileData, shimData, ref, meta);
            }
            else {
                // The class can be type-checked externally as normal.
                shimData.file.addTypeCheckBlock(ref, meta, shimData.domSchemaChecker, shimData.oobRecorder);
            }
        }
        /**
         * Record a type constructor for the given `node` with the given `ctorMetadata`.
         */
        addInlineTypeCtor(fileData, sf, ref, ctorMeta) {
            if (this.typeCtorPending.has(ref.node)) {
                return;
            }
            this.typeCtorPending.add(ref.node);
            // Lazily construct the operation map.
            if (!this.opMap.has(sf)) {
                this.opMap.set(sf, []);
            }
            const ops = this.opMap.get(sf);
            // Push a `TypeCtorOp` into the operation queue for the source file.
            ops.push(new TypeCtorOp(ref, ctorMeta));
            fileData.hasInlines = true;
        }
        /**
         * Transform a `ts.SourceFile` into a version that includes type checking code.
         *
         * If this particular `ts.SourceFile` requires changes, the text representing its new contents
         * will be returned. Otherwise, a `null` return indicates no changes were necessary.
         */
        transform(sf) {
            // If there are no operations pending for this particular file, return `null` to indicate no
            // changes.
            if (!this.opMap.has(sf)) {
                return null;
            }
            // Imports may need to be added to the file to support type-checking of directives used in the
            // template within it.
            const importManager = new ImportManager(new NoopImportRewriter(), '_i');
            // Each Op has a splitPoint index into the text where it needs to be inserted. Split the
            // original source text into chunks at these split points, where code will be inserted between
            // the chunks.
            const ops = this.opMap.get(sf).sort(orderOps);
            const textParts = splitStringAtPoints(sf.text, ops.map(op => op.splitPoint));
            // Use a `ts.Printer` to generate source code.
            const printer = ts.createPrinter({ omitTrailingSemicolon: true });
            // Begin with the intial section of the code text.
            let code = textParts[0];
            // Process each operation and use the printer to generate source code for it, inserting it into
            // the source code in between the original chunks.
            ops.forEach((op, idx) => {
                const text = op.execute(importManager, sf, this.refEmitter, printer);
                code += '\n\n' + text + textParts[idx + 1];
            });
            // Write out the imports that need to be added to the beginning of the file.
            let imports = importManager.getAllImports(sf.fileName)
                .map(i => `import * as ${i.qualifier} from '${i.specifier}';`)
                .join('\n');
            code = imports + '\n' + code;
            return code;
        }
        finalize() {
            // First, build the map of updates to source files.
            const updates = new Map();
            for (const originalSf of this.opMap.keys()) {
                const newText = this.transform(originalSf);
                if (newText !== null) {
                    updates.set(absoluteFromSourceFile(originalSf), newText);
                }
            }
            // Then go through each input file that has pending code generation operations.
            for (const [sfPath, pendingFileData] of this.fileMap) {
                // For each input file, consider generation operations for each of its shims.
                for (const pendingShimData of pendingFileData.shimData.values()) {
                    this.host.recordShimData(sfPath, {
                        genesisDiagnostics: [
                            ...pendingShimData.domSchemaChecker.diagnostics,
                            ...pendingShimData.oobRecorder.diagnostics,
                        ],
                        hasInlines: pendingFileData.hasInlines,
                        path: pendingShimData.file.fileName,
                        templates: pendingShimData.templates,
                    });
                    updates.set(pendingShimData.file.fileName, pendingShimData.file.render());
                }
            }
            return updates;
        }
        addInlineTypeCheckBlock(fileData, shimData, ref, tcbMeta) {
            const sf = ref.node.getSourceFile();
            if (!this.opMap.has(sf)) {
                this.opMap.set(sf, []);
            }
            const ops = this.opMap.get(sf);
            ops.push(new TcbOp$1(ref, tcbMeta, this.config, this.reflector, shimData.domSchemaChecker, shimData.oobRecorder));
            fileData.hasInlines = true;
        }
        pendingShimForComponent(node) {
            const fileData = this.dataForFile(node.getSourceFile());
            const shimPath = this.componentMappingStrategy.shimPathForComponent(node);
            if (!fileData.shimData.has(shimPath)) {
                fileData.shimData.set(shimPath, {
                    domSchemaChecker: new RegistryDomSchemaChecker(fileData.sourceManager),
                    oobRecorder: new OutOfBandDiagnosticRecorderImpl(fileData.sourceManager),
                    file: new TypeCheckFile(shimPath, this.config, this.refEmitter, this.reflector, this.compilerHost),
                    templates: new Map(),
                });
            }
            return fileData.shimData.get(shimPath);
        }
        dataForFile(sf) {
            const sfPath = absoluteFromSourceFile(sf);
            if (!this.fileMap.has(sfPath)) {
                const data = {
                    hasInlines: false,
                    sourceManager: this.host.getSourceManager(sfPath),
                    shimData: new Map(),
                };
                this.fileMap.set(sfPath, data);
            }
            return this.fileMap.get(sfPath);
        }
    }
    /**
     * A type check block operation which produces type check code for a particular component.
     */
    class TcbOp$1 {
        constructor(ref, meta, config, reflector, domSchemaChecker, oobRecorder) {
            this.ref = ref;
            this.meta = meta;
            this.config = config;
            this.reflector = reflector;
            this.domSchemaChecker = domSchemaChecker;
            this.oobRecorder = oobRecorder;
        }
        /**
         * Type check blocks are inserted immediately after the end of the component class.
         */
        get splitPoint() {
            return this.ref.node.end + 1;
        }
        execute(im, sf, refEmitter, printer) {
            const env = new Environment(this.config, im, refEmitter, this.reflector, sf);
            const fnName = ts.createIdentifier(`_tcb_${this.ref.node.pos}`);
            const fn = generateTypeCheckBlock(env, this.ref, fnName, this.meta, this.domSchemaChecker, this.oobRecorder);
            return printer.printNode(ts.EmitHint.Unspecified, fn, sf);
        }
    }
    /**
     * A type constructor operation which produces type constructor code for a particular directive.
     */
    class TypeCtorOp {
        constructor(ref, meta) {
            this.ref = ref;
            this.meta = meta;
        }
        /**
         * Type constructor operations are inserted immediately before the end of the directive class.
         */
        get splitPoint() {
            return this.ref.node.end - 1;
        }
        execute(im, sf, refEmitter, printer) {
            const tcb = generateInlineTypeCtor(this.ref.node, this.meta);
            return printer.printNode(ts.EmitHint.Unspecified, tcb, sf);
        }
    }
    /**
     * Compare two operations and return their split point ordering.
     */
    function orderOps(op1, op2) {
        return op1.splitPoint - op2.splitPoint;
    }
    /**
     * Split a string into chunks at any number of split points.
     */
    function splitStringAtPoints(str, points) {
        const splits = [];
        let start = 0;
        for (let i = 0; i < points.length; i++) {
            const point = points[i];
            splits.push(str.substring(start, point));
            start = point;
        }
        splits.push(str.substring(start));
        return splits;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const LF_CHAR = 10;
    const CR_CHAR = 13;
    const LINE_SEP_CHAR = 8232;
    const PARAGRAPH_CHAR = 8233;
    /** Gets the line and character for the given position from the line starts map. */
    function getLineAndCharacterFromPosition(lineStartsMap, position) {
        const lineIndex = findClosestLineStartPosition(lineStartsMap, position);
        return { character: position - lineStartsMap[lineIndex], line: lineIndex };
    }
    /**
     * Computes the line start map of the given text. This can be used in order to
     * retrieve the line and character of a given text position index.
     */
    function computeLineStartsMap(text) {
        const result = [0];
        let pos = 0;
        while (pos < text.length) {
            const char = text.charCodeAt(pos++);
            // Handles the "CRLF" line break. In that case we peek the character
            // after the "CR" and check if it is a line feed.
            if (char === CR_CHAR) {
                if (text.charCodeAt(pos) === LF_CHAR) {
                    pos++;
                }
                result.push(pos);
            }
            else if (char === LF_CHAR || char === LINE_SEP_CHAR || char === PARAGRAPH_CHAR) {
                result.push(pos);
            }
        }
        result.push(pos);
        return result;
    }
    /** Finds the closest line start for the given position. */
    function findClosestLineStartPosition(linesMap, position, low = 0, high = linesMap.length - 1) {
        while (low <= high) {
            const pivotIdx = Math.floor((low + high) / 2);
            const pivotEl = linesMap[pivotIdx];
            if (pivotEl === position) {
                return pivotIdx;
            }
            else if (position > pivotEl) {
                low = pivotIdx + 1;
            }
            else {
                high = pivotIdx - 1;
            }
        }
        // In case there was no exact match, return the closest "lower" line index. We also
        // subtract the index by one because want the index of the previous line start.
        return low - 1;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Represents the source of a template that was processed during type-checking. This information is
     * used when translating parse offsets in diagnostics back to their original line/column location.
     */
    class TemplateSource {
        constructor(mapping, file) {
            this.mapping = mapping;
            this.file = file;
            this.lineStarts = null;
        }
        toParseSourceSpan(start, end) {
            const startLoc = this.toParseLocation(start);
            const endLoc = this.toParseLocation(end);
            return new ParseSourceSpan(startLoc, endLoc);
        }
        toParseLocation(position) {
            const lineStarts = this.acquireLineStarts();
            const { line, character } = getLineAndCharacterFromPosition(lineStarts, position);
            return new ParseLocation(this.file, position, line, character);
        }
        acquireLineStarts() {
            if (this.lineStarts === null) {
                this.lineStarts = computeLineStartsMap(this.file.content);
            }
            return this.lineStarts;
        }
    }
    /**
     * Assigns IDs to templates and keeps track of their origins.
     *
     * Implements `TemplateSourceResolver` to resolve the source of a template based on these IDs.
     */
    class TemplateSourceManager {
        constructor() {
            /**
             * This map keeps track of all template sources that have been type-checked by the id that is
             * attached to a TCB's function declaration as leading trivia. This enables translation of
             * diagnostics produced for TCB code to their source location in the template.
             */
            this.templateSources = new Map();
        }
        getTemplateId(node) {
            return getTemplateId$1(node);
        }
        captureSource(node, mapping, file) {
            const id = getTemplateId$1(node);
            this.templateSources.set(id, new TemplateSource(mapping, file));
            return id;
        }
        getSourceMapping(id) {
            if (!this.templateSources.has(id)) {
                throw new Error(`Unexpected unknown template ID: ${id}`);
            }
            return this.templateSources.get(id).mapping;
        }
        toParseSourceSpan(id, span) {
            if (!this.templateSources.has(id)) {
                return null;
            }
            const templateSource = this.templateSources.get(id);
            return templateSource.toParseSourceSpan(span.start, span.end);
        }
    }
    const TEMPLATE_ID = Symbol('ngTemplateId');
    const NEXT_TEMPLATE_ID = Symbol('ngNextTemplateId');
    function getTemplateId$1(node) {
        if (node[TEMPLATE_ID] === undefined) {
            node[TEMPLATE_ID] = allocateTemplateId(node.getSourceFile());
        }
        return node[TEMPLATE_ID];
    }
    function allocateTemplateId(sf) {
        if (sf[NEXT_TEMPLATE_ID] === undefined) {
            sf[NEXT_TEMPLATE_ID] = 1;
        }
        return (`tcb${sf[NEXT_TEMPLATE_ID]++}`);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Primary template type-checking engine, which performs type-checking using a
     * `TypeCheckingProgramStrategy` for type-checking program maintenance, and the
     * `ProgramTypeCheckAdapter` for generation of template type-checking code.
     */
    class TemplateTypeCheckerImpl {
        constructor(originalProgram, typeCheckingStrategy, typeCheckAdapter, config, refEmitter, reflector, compilerHost, priorBuild) {
            this.originalProgram = originalProgram;
            this.typeCheckingStrategy = typeCheckingStrategy;
            this.typeCheckAdapter = typeCheckAdapter;
            this.config = config;
            this.refEmitter = refEmitter;
            this.reflector = reflector;
            this.compilerHost = compilerHost;
            this.priorBuild = priorBuild;
            this.state = new Map();
            this.isComplete = false;
        }
        resetOverrides() {
            for (const fileRecord of this.state.values()) {
                if (fileRecord.templateOverrides !== null) {
                    fileRecord.templateOverrides = null;
                    fileRecord.shimData.clear();
                    fileRecord.isComplete = false;
                }
            }
        }
        getTemplate(component) {
            this.ensureShimForComponent(component);
            const sf = component.getSourceFile();
            const sfPath = absoluteFromSourceFile(sf);
            const shimPath = this.typeCheckingStrategy.shimPathForComponent(component);
            const fileRecord = this.getFileData(sfPath);
            if (!fileRecord.shimData.has(shimPath)) {
                return [];
            }
            const templateId = fileRecord.sourceManager.getTemplateId(component);
            const shimRecord = fileRecord.shimData.get(shimPath);
            if (!shimRecord.templates.has(templateId)) {
                return null;
            }
            return shimRecord.templates.get(templateId).template;
        }
        overrideComponentTemplate(component, template) {
            const { nodes, errors } = parseTemplate(template, 'override.html', {
                preserveWhitespaces: true,
                leadingTriviaChars: [],
            });
            if (errors !== undefined) {
                return { nodes, errors };
            }
            const filePath = absoluteFromSourceFile(component.getSourceFile());
            const fileRecord = this.getFileData(filePath);
            const id = fileRecord.sourceManager.getTemplateId(component);
            if (fileRecord.templateOverrides === null) {
                fileRecord.templateOverrides = new Map();
            }
            fileRecord.templateOverrides.set(id, nodes);
            // Clear data for the shim in question, so it'll be regenerated on the next request.
            const shimFile = this.typeCheckingStrategy.shimPathForComponent(component);
            fileRecord.shimData.delete(shimFile);
            fileRecord.isComplete = false;
            this.isComplete = false;
            return { nodes };
        }
        /**
         * Retrieve type-checking diagnostics from the given `ts.SourceFile` using the most recent
         * type-checking program.
         */
        getDiagnosticsForFile(sf, optimizeFor) {
            switch (optimizeFor) {
                case OptimizeFor.WholeProgram:
                    this.ensureAllShimsForAllFiles();
                    break;
                case OptimizeFor.SingleFile:
                    this.ensureAllShimsForOneFile(sf);
                    break;
            }
            const sfPath = absoluteFromSourceFile(sf);
            const fileRecord = this.state.get(sfPath);
            const typeCheckProgram = this.typeCheckingStrategy.getProgram();
            const diagnostics = [];
            if (fileRecord.hasInlines) {
                const inlineSf = getSourceFileOrError(typeCheckProgram, sfPath);
                diagnostics.push(...typeCheckProgram.getSemanticDiagnostics(inlineSf).map(diag => convertDiagnostic(diag, fileRecord.sourceManager)));
            }
            for (const [shimPath, shimRecord] of fileRecord.shimData) {
                const shimSf = getSourceFileOrError(typeCheckProgram, shimPath);
                diagnostics.push(...typeCheckProgram.getSemanticDiagnostics(shimSf).map(diag => convertDiagnostic(diag, fileRecord.sourceManager)));
                diagnostics.push(...shimRecord.genesisDiagnostics);
            }
            return diagnostics.filter((diag) => diag !== null);
        }
        getDiagnosticsForComponent(component) {
            this.ensureShimForComponent(component);
            const sf = component.getSourceFile();
            const sfPath = absoluteFromSourceFile(sf);
            const shimPath = this.typeCheckingStrategy.shimPathForComponent(component);
            const fileRecord = this.getFileData(sfPath);
            if (!fileRecord.shimData.has(shimPath)) {
                return [];
            }
            const templateId = fileRecord.sourceManager.getTemplateId(component);
            const shimRecord = fileRecord.shimData.get(shimPath);
            const typeCheckProgram = this.typeCheckingStrategy.getProgram();
            const diagnostics = [];
            if (shimRecord.hasInlines) {
                const inlineSf = getSourceFileOrError(typeCheckProgram, sfPath);
                diagnostics.push(...typeCheckProgram.getSemanticDiagnostics(inlineSf).map(diag => convertDiagnostic(diag, fileRecord.sourceManager)));
            }
            const shimSf = getSourceFileOrError(typeCheckProgram, shimPath);
            diagnostics.push(...typeCheckProgram.getSemanticDiagnostics(shimSf).map(diag => convertDiagnostic(diag, fileRecord.sourceManager)));
            diagnostics.push(...shimRecord.genesisDiagnostics);
            return diagnostics.filter((diag) => diag !== null && diag.templateId === templateId);
        }
        getTypeCheckBlock(component) {
            this.ensureAllShimsForOneFile(component.getSourceFile());
            const program = this.typeCheckingStrategy.getProgram();
            const filePath = absoluteFromSourceFile(component.getSourceFile());
            const shimPath = this.typeCheckingStrategy.shimPathForComponent(component);
            if (!this.state.has(filePath)) {
                throw new Error(`Error: no data for source file: ${filePath}`);
            }
            const fileRecord = this.state.get(filePath);
            const id = fileRecord.sourceManager.getTemplateId(component);
            const shimSf = getSourceFileOrNull(program, shimPath);
            if (shimSf === null || !fileRecord.shimData.has(shimPath)) {
                throw new Error(`Error: no shim file in program: ${shimPath}`);
            }
            let node = findTypeCheckBlock(shimSf, id);
            if (node === null) {
                // Try for an inline block.
                const inlineSf = getSourceFileOrError(program, filePath);
                node = findTypeCheckBlock(inlineSf, id);
            }
            return node;
        }
        maybeAdoptPriorResultsForFile(sf) {
            const sfPath = absoluteFromSourceFile(sf);
            if (this.state.has(sfPath)) {
                const existingResults = this.state.get(sfPath);
                if (existingResults.templateOverrides !== null) {
                    // Cannot adopt prior results if template overrides have been requested.
                    return;
                }
                if (existingResults.isComplete) {
                    // All data for this file has already been generated, so no need to adopt anything.
                    return;
                }
            }
            const previousResults = this.priorBuild.priorTypeCheckingResultsFor(sf);
            if (previousResults === null || !previousResults.isComplete ||
                previousResults.templateOverrides !== null) {
                return;
            }
            this.state.set(sfPath, previousResults);
        }
        ensureAllShimsForAllFiles() {
            if (this.isComplete) {
                return;
            }
            const host = new WholeProgramTypeCheckingHost(this);
            const ctx = this.newContext(host);
            for (const sf of this.originalProgram.getSourceFiles()) {
                if (sf.isDeclarationFile || isShim(sf)) {
                    continue;
                }
                this.maybeAdoptPriorResultsForFile(sf);
                const sfPath = absoluteFromSourceFile(sf);
                const fileData = this.getFileData(sfPath);
                if (fileData.isComplete) {
                    continue;
                }
                this.typeCheckAdapter.typeCheck(sf, ctx);
                fileData.isComplete = true;
            }
            this.updateFromContext(ctx);
            this.isComplete = true;
        }
        ensureAllShimsForOneFile(sf) {
            this.maybeAdoptPriorResultsForFile(sf);
            const sfPath = absoluteFromSourceFile(sf);
            const fileData = this.getFileData(sfPath);
            if (fileData.isComplete) {
                // All data for this file is present and accounted for already.
                return;
            }
            const host = new SingleFileTypeCheckingHost(sfPath, fileData, this.typeCheckingStrategy, this);
            const ctx = this.newContext(host);
            this.typeCheckAdapter.typeCheck(sf, ctx);
            fileData.isComplete = true;
            this.updateFromContext(ctx);
        }
        ensureShimForComponent(component) {
            const sf = component.getSourceFile();
            const sfPath = absoluteFromSourceFile(sf);
            this.maybeAdoptPriorResultsForFile(sf);
            const fileData = this.getFileData(sfPath);
            const shimPath = this.typeCheckingStrategy.shimPathForComponent(component);
            if (fileData.shimData.has(shimPath)) {
                // All data for this component is available.
                return;
            }
            const host = new SingleShimTypeCheckingHost(sfPath, fileData, this.typeCheckingStrategy, this, shimPath);
            const ctx = this.newContext(host);
            this.typeCheckAdapter.typeCheck(sf, ctx);
            this.updateFromContext(ctx);
        }
        newContext(host) {
            const inlining = this.typeCheckingStrategy.supportsInlineOperations ? InliningMode.InlineOps :
                InliningMode.Error;
            return new TypeCheckContextImpl(this.config, this.compilerHost, this.typeCheckingStrategy, this.refEmitter, this.reflector, host, inlining);
        }
        /**
         * Remove any shim data that depends on inline operations applied to the type-checking program.
         *
         * This can be useful if new inlines need to be applied, and it's not possible to guarantee that
         * they won't overwrite or corrupt existing inlines that are used by such shims.
         */
        clearAllShimDataUsingInlines() {
            for (const fileData of this.state.values()) {
                if (!fileData.hasInlines) {
                    continue;
                }
                for (const [shimFile, shimData] of fileData.shimData.entries()) {
                    if (shimData.hasInlines) {
                        fileData.shimData.delete(shimFile);
                    }
                }
                fileData.hasInlines = false;
                fileData.isComplete = false;
                this.isComplete = false;
            }
        }
        updateFromContext(ctx) {
            const updates = ctx.finalize();
            this.typeCheckingStrategy.updateFiles(updates, UpdateMode.Incremental);
            this.priorBuild.recordSuccessfulTypeCheck(this.state);
        }
        getFileData(path) {
            if (!this.state.has(path)) {
                this.state.set(path, {
                    hasInlines: false,
                    templateOverrides: null,
                    sourceManager: new TemplateSourceManager(),
                    isComplete: false,
                    shimData: new Map(),
                });
            }
            return this.state.get(path);
        }
    }
    function convertDiagnostic(diag, sourceResolver) {
        if (!shouldReportDiagnostic(diag)) {
            return null;
        }
        return translateDiagnostic(diag, sourceResolver);
    }
    /**
     * Drives a `TypeCheckContext` to generate type-checking code for every component in the program.
     */
    class WholeProgramTypeCheckingHost {
        constructor(impl) {
            this.impl = impl;
        }
        getSourceManager(sfPath) {
            return this.impl.getFileData(sfPath).sourceManager;
        }
        shouldCheckComponent(node) {
            const fileData = this.impl.getFileData(absoluteFromSourceFile(node.getSourceFile()));
            const shimPath = this.impl.typeCheckingStrategy.shimPathForComponent(node);
            // The component needs to be checked unless the shim which would contain it already exists.
            return !fileData.shimData.has(shimPath);
        }
        getTemplateOverride(sfPath, node) {
            const fileData = this.impl.getFileData(sfPath);
            if (fileData.templateOverrides === null) {
                return null;
            }
            const templateId = fileData.sourceManager.getTemplateId(node);
            if (fileData.templateOverrides.has(templateId)) {
                return fileData.templateOverrides.get(templateId);
            }
            return null;
        }
        recordShimData(sfPath, data) {
            const fileData = this.impl.getFileData(sfPath);
            fileData.shimData.set(data.path, data);
            if (data.hasInlines) {
                fileData.hasInlines = true;
            }
        }
        recordComplete(sfPath) {
            this.impl.getFileData(sfPath).isComplete = true;
        }
    }
    /**
     * Drives a `TypeCheckContext` to generate type-checking code efficiently for a single input file.
     */
    class SingleFileTypeCheckingHost {
        constructor(sfPath, fileData, strategy, impl) {
            this.sfPath = sfPath;
            this.fileData = fileData;
            this.strategy = strategy;
            this.impl = impl;
            this.seenInlines = false;
        }
        assertPath(sfPath) {
            if (this.sfPath !== sfPath) {
                throw new Error(`AssertionError: querying TypeCheckingHost outside of assigned file`);
            }
        }
        getSourceManager(sfPath) {
            this.assertPath(sfPath);
            return this.fileData.sourceManager;
        }
        shouldCheckComponent(node) {
            if (this.sfPath !== absoluteFromSourceFile(node.getSourceFile())) {
                return false;
            }
            const shimPath = this.strategy.shimPathForComponent(node);
            // Only need to generate a TCB for the class if no shim exists for it currently.
            return !this.fileData.shimData.has(shimPath);
        }
        getTemplateOverride(sfPath, node) {
            this.assertPath(sfPath);
            if (this.fileData.templateOverrides === null) {
                return null;
            }
            const templateId = this.fileData.sourceManager.getTemplateId(node);
            if (this.fileData.templateOverrides.has(templateId)) {
                return this.fileData.templateOverrides.get(templateId);
            }
            return null;
        }
        recordShimData(sfPath, data) {
            this.assertPath(sfPath);
            // Previous type-checking state may have required the use of inlines (assuming they were
            // supported). If the current operation also requires inlines, this presents a problem:
            // generating new inlines may invalidate any old inlines that old state depends on.
            //
            // Rather than resolve this issue by tracking specific dependencies on inlines, if the new state
            // relies on inlines, any old state that relied on them is simply cleared. This happens when the
            // first new state that uses inlines is encountered.
            if (data.hasInlines && !this.seenInlines) {
                this.impl.clearAllShimDataUsingInlines();
                this.seenInlines = true;
            }
            this.fileData.shimData.set(data.path, data);
            if (data.hasInlines) {
                this.fileData.hasInlines = true;
            }
        }
        recordComplete(sfPath) {
            this.assertPath(sfPath);
            this.fileData.isComplete = true;
        }
    }
    /**
     * Drives a `TypeCheckContext` to generate type-checking code efficiently for only those components
     * which map to a single shim of a single input file.
     */
    class SingleShimTypeCheckingHost extends SingleFileTypeCheckingHost {
        constructor(sfPath, fileData, strategy, impl, shimPath) {
            super(sfPath, fileData, strategy, impl);
            this.shimPath = shimPath;
        }
        shouldCheckNode(node) {
            if (this.sfPath !== absoluteFromSourceFile(node.getSourceFile())) {
                return false;
            }
            // Only generate a TCB for the component if it maps to the requested shim file.
            const shimPath = this.strategy.shimPathForComponent(node);
            if (shimPath !== this.shimPath) {
                return false;
            }
            // Only need to generate a TCB for the class if no shim exists for it currently.
            return !this.fileData.shimData.has(shimPath);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * The heart of the Angular Ivy compiler.
     *
     * The `NgCompiler` provides an API for performing Angular compilation within a custom TypeScript
     * compiler. Each instance of `NgCompiler` supports a single compilation, which might be
     * incremental.
     *
     * `NgCompiler` is lazy, and does not perform any of the work of the compilation until one of its
     * output methods (e.g. `getDiagnostics`) is called.
     *
     * See the README.md for more information.
     */
    class NgCompiler {
        constructor(adapter, options, tsProgram, typeCheckingProgramStrategy, incrementalStrategy, oldProgram = null, perfRecorder = NOOP_PERF_RECORDER) {
            this.adapter = adapter;
            this.options = options;
            this.tsProgram = tsProgram;
            this.typeCheckingProgramStrategy = typeCheckingProgramStrategy;
            this.incrementalStrategy = incrementalStrategy;
            this.perfRecorder = perfRecorder;
            /**
             * Lazily evaluated state of the compilation.
             *
             * This is created on demand by calling `ensureAnalyzed`.
             */
            this.compilation = null;
            /**
             * Any diagnostics related to the construction of the compilation.
             *
             * These are diagnostics which arose during setup of the host and/or program.
             */
            this.constructionDiagnostics = [];
            /**
             * Semantic diagnostics related to the program itself.
             *
             * This is set by (and memoizes) `getDiagnostics`.
             */
            this.diagnostics = null;
            this.constructionDiagnostics.push(...this.adapter.constructionDiagnostics);
            const incompatibleTypeCheckOptionsDiagnostic = verifyCompatibleTypeCheckOptions(this.options);
            if (incompatibleTypeCheckOptionsDiagnostic !== null) {
                this.constructionDiagnostics.push(incompatibleTypeCheckOptionsDiagnostic);
            }
            this.nextProgram = tsProgram;
            this.closureCompilerEnabled = !!this.options.annotateForClosureCompiler;
            this.entryPoint =
                adapter.entryPoint !== null ? getSourceFileOrNull(tsProgram, adapter.entryPoint) : null;
            const moduleResolutionCache = ts.createModuleResolutionCache(this.adapter.getCurrentDirectory(), 
            // Note: this used to be an arrow-function closure. However, JS engines like v8 have some
            // strange behaviors with retaining the lexical scope of the closure. Even if this function
            // doesn't retain a reference to `this`, if other closures in the constructor here reference
            // `this` internally then a closure created here would retain them. This can cause major
            // memory leak issues since the `moduleResolutionCache` is a long-lived object and finds its
            // way into all kinds of places inside TS internal objects.
            this.adapter.getCanonicalFileName.bind(this.adapter));
            this.moduleResolver =
                new ModuleResolver(tsProgram, this.options, this.adapter, moduleResolutionCache);
            this.resourceManager = new AdapterResourceLoader(adapter, this.options);
            this.cycleAnalyzer = new CycleAnalyzer(new ImportGraph(this.moduleResolver));
            let modifiedResourceFiles = null;
            if (this.adapter.getModifiedResourceFiles !== undefined) {
                modifiedResourceFiles = this.adapter.getModifiedResourceFiles() || null;
            }
            if (oldProgram === null) {
                this.incrementalDriver = IncrementalDriver.fresh(tsProgram);
            }
            else {
                const oldDriver = this.incrementalStrategy.getIncrementalDriver(oldProgram);
                if (oldDriver !== null) {
                    this.incrementalDriver =
                        IncrementalDriver.reconcile(oldProgram, oldDriver, tsProgram, modifiedResourceFiles);
                }
                else {
                    // A previous ts.Program was used to create the current one, but it wasn't from an
                    // `NgCompiler`. That doesn't hurt anything, but the Angular analysis will have to start
                    // from a fresh state.
                    this.incrementalDriver = IncrementalDriver.fresh(tsProgram);
                }
            }
            this.incrementalStrategy.setIncrementalDriver(this.incrementalDriver, tsProgram);
            this.ignoreForDiagnostics =
                new Set(tsProgram.getSourceFiles().filter(sf => this.adapter.isShim(sf)));
            this.ignoreForEmit = this.adapter.ignoreForEmit;
        }
        /**
         * Get all Angular-related diagnostics for this compilation.
         *
         * If a `ts.SourceFile` is passed, only diagnostics related to that file are returned.
         */
        getDiagnostics(file) {
            if (this.diagnostics === null) {
                const compilation = this.ensureAnalyzed();
                this.diagnostics =
                    [...compilation.traitCompiler.diagnostics, ...this.getTemplateDiagnostics()];
                if (this.entryPoint !== null && compilation.exportReferenceGraph !== null) {
                    this.diagnostics.push(...checkForPrivateExports(this.entryPoint, this.tsProgram.getTypeChecker(), compilation.exportReferenceGraph));
                }
            }
            if (file === undefined) {
                return this.diagnostics;
            }
            else {
                return this.diagnostics.filter(diag => {
                    if (diag.file === file) {
                        return true;
                    }
                    else if (isTemplateDiagnostic(diag) && diag.componentFile === file) {
                        // Template diagnostics are reported when diagnostics for the component file are
                        // requested (since no consumer of `getDiagnostics` would ever ask for diagnostics from
                        // the fake ts.SourceFile for templates).
                        return true;
                    }
                    else {
                        return false;
                    }
                });
            }
        }
        /**
         * Get all setup-related diagnostics for this compilation.
         */
        getOptionDiagnostics() {
            return this.constructionDiagnostics;
        }
        /**
         * Get the `ts.Program` to use as a starting point when spawning a subsequent incremental
         * compilation.
         *
         * The `NgCompiler` spawns an internal incremental TypeScript compilation (inheriting the
         * consumer's `ts.Program` into a new one for the purposes of template type-checking). After this
         * operation, the consumer's `ts.Program` is no longer usable for starting a new incremental
         * compilation. `getNextProgram` retrieves the `ts.Program` which can be used instead.
         */
        getNextProgram() {
            return this.nextProgram;
        }
        getTemplateTypeChecker() {
            return this.ensureAnalyzed().templateTypeChecker;
        }
        /**
         * Perform Angular's analysis step (as a precursor to `getDiagnostics` or `prepareEmit`)
         * asynchronously.
         *
         * Normally, this operation happens lazily whenever `getDiagnostics` or `prepareEmit` are called.
         * However, certain consumers may wish to allow for an asynchronous phase of analysis, where
         * resources such as `styleUrls` are resolved asynchonously. In these cases `analyzeAsync` must be
         * called first, and its `Promise` awaited prior to calling any other APIs of `NgCompiler`.
         */
        analyzeAsync() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.compilation !== null) {
                    return;
                }
                this.compilation = this.makeCompilation();
                const analyzeSpan = this.perfRecorder.start('analyze');
                const promises = [];
                for (const sf of this.tsProgram.getSourceFiles()) {
                    if (sf.isDeclarationFile) {
                        continue;
                    }
                    const analyzeFileSpan = this.perfRecorder.start('analyzeFile', sf);
                    let analysisPromise = this.compilation.traitCompiler.analyzeAsync(sf);
                    this.scanForMwp(sf);
                    if (analysisPromise === undefined) {
                        this.perfRecorder.stop(analyzeFileSpan);
                    }
                    else if (this.perfRecorder.enabled) {
                        analysisPromise = analysisPromise.then(() => this.perfRecorder.stop(analyzeFileSpan));
                    }
                    if (analysisPromise !== undefined) {
                        promises.push(analysisPromise);
                    }
                }
                yield Promise.all(promises);
                this.perfRecorder.stop(analyzeSpan);
                this.resolveCompilation(this.compilation.traitCompiler);
            });
        }
        /**
         * List lazy routes detected during analysis.
         *
         * This can be called for one specific route, or to retrieve all top-level routes.
         */
        listLazyRoutes(entryRoute) {
            if (entryRoute) {
                // Note:
                // This resolution step is here to match the implementation of the old `AotCompilerHost` (see
                // https://github.com/angular/angular/blob/50732e156/packages/compiler-cli/src/transformers/compiler_host.ts#L175-L188).
                //
                // `@angular/cli` will always call this API with an absolute path, so the resolution step is
                // not necessary, but keeping it backwards compatible in case someone else is using the API.
                // Relative entry paths are disallowed.
                if (entryRoute.startsWith('.')) {
                    throw new Error(`Failed to list lazy routes: Resolution of relative paths (${entryRoute}) is not supported.`);
                }
                // Non-relative entry paths fall into one of the following categories:
                // - Absolute system paths (e.g. `/foo/bar/my-project/my-module`), which are unaffected by the
                //   logic below.
                // - Paths to enternal modules (e.g. `some-lib`).
                // - Paths mapped to directories in `tsconfig.json` (e.g. `shared/my-module`).
                //   (See https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping.)
                //
                // In all cases above, the `containingFile` argument is ignored, so we can just take the first
                // of the root files.
                const containingFile = this.tsProgram.getRootFileNames()[0];
                const [entryPath, moduleName] = entryRoute.split('#');
                const resolvedModule = resolveModuleName(entryPath, containingFile, this.options, this.adapter, null);
                if (resolvedModule) {
                    entryRoute = entryPointKeyFor(resolvedModule.resolvedFileName, moduleName);
                }
            }
            const compilation = this.ensureAnalyzed();
            return compilation.routeAnalyzer.listLazyRoutes(entryRoute);
        }
        /**
         * Fetch transformers and other information which is necessary for a consumer to `emit` the
         * program with Angular-added definitions.
         */
        prepareEmit() {
            const compilation = this.ensureAnalyzed();
            const coreImportsFrom = compilation.isCore ? getR3SymbolsFile(this.tsProgram) : null;
            let importRewriter;
            if (coreImportsFrom !== null) {
                importRewriter = new R3SymbolsImportRewriter(coreImportsFrom.fileName);
            }
            else {
                importRewriter = new NoopImportRewriter();
            }
            const before = [
                ivyTransformFactory(compilation.traitCompiler, compilation.reflector, importRewriter, compilation.defaultImportTracker, compilation.isCore, this.closureCompilerEnabled),
                aliasTransformFactory(compilation.traitCompiler.exportStatements),
                compilation.defaultImportTracker.importPreservingTransformer(),
            ];
            const afterDeclarations = [];
            if (compilation.dtsTransforms !== null) {
                afterDeclarations.push(declarationTransformFactory(compilation.dtsTransforms, importRewriter));
            }
            // Only add aliasing re-exports to the .d.ts output if the `AliasingHost` requests it.
            if (compilation.aliasingHost !== null && compilation.aliasingHost.aliasExportsInDts) {
                afterDeclarations.push(aliasTransformFactory(compilation.traitCompiler.exportStatements));
            }
            if (this.adapter.factoryTracker !== null) {
                before.push(generatedFactoryTransform(this.adapter.factoryTracker.sourceInfo, importRewriter));
            }
            before.push(ivySwitchTransform);
            return { transformers: { before, afterDeclarations } };
        }
        /**
         * Run the indexing process and return a `Map` of all indexed components.
         *
         * See the `indexing` package for more details.
         */
        getIndexedComponents() {
            const compilation = this.ensureAnalyzed();
            const context = new IndexingContext();
            compilation.traitCompiler.index(context);
            return generateAnalysis(context);
        }
        ensureAnalyzed() {
            if (this.compilation === null) {
                this.analyzeSync();
            }
            return this.compilation;
        }
        analyzeSync() {
            const analyzeSpan = this.perfRecorder.start('analyze');
            this.compilation = this.makeCompilation();
            for (const sf of this.tsProgram.getSourceFiles()) {
                if (sf.isDeclarationFile) {
                    continue;
                }
                const analyzeFileSpan = this.perfRecorder.start('analyzeFile', sf);
                this.compilation.traitCompiler.analyzeSync(sf);
                this.scanForMwp(sf);
                this.perfRecorder.stop(analyzeFileSpan);
            }
            this.perfRecorder.stop(analyzeSpan);
            this.resolveCompilation(this.compilation.traitCompiler);
        }
        resolveCompilation(traitCompiler) {
            traitCompiler.resolve();
            this.recordNgModuleScopeDependencies();
            // At this point, analysis is complete and the compiler can now calculate which files need to
            // be emitted, so do that.
            this.incrementalDriver.recordSuccessfulAnalysis(traitCompiler);
        }
        get fullTemplateTypeCheck() {
            // Determine the strictness level of type checking based on compiler options. As
            // `strictTemplates` is a superset of `fullTemplateTypeCheck`, the former implies the latter.
            // Also see `verifyCompatibleTypeCheckOptions` where it is verified that `fullTemplateTypeCheck`
            // is not disabled when `strictTemplates` is enabled.
            const strictTemplates = !!this.options.strictTemplates;
            return strictTemplates || !!this.options.fullTemplateTypeCheck;
        }
        getTypeCheckingConfig() {
            // Determine the strictness level of type checking based on compiler options. As
            // `strictTemplates` is a superset of `fullTemplateTypeCheck`, the former implies the latter.
            // Also see `verifyCompatibleTypeCheckOptions` where it is verified that `fullTemplateTypeCheck`
            // is not disabled when `strictTemplates` is enabled.
            const strictTemplates = !!this.options.strictTemplates;
            // First select a type-checking configuration, based on whether full template type-checking is
            // requested.
            let typeCheckingConfig;
            if (this.fullTemplateTypeCheck) {
                typeCheckingConfig = {
                    applyTemplateContextGuards: strictTemplates,
                    checkQueries: false,
                    checkTemplateBodies: true,
                    checkTypeOfInputBindings: strictTemplates,
                    strictNullInputBindings: strictTemplates,
                    checkTypeOfAttributes: strictTemplates,
                    // Even in full template type-checking mode, DOM binding checks are not quite ready yet.
                    checkTypeOfDomBindings: false,
                    checkTypeOfOutputEvents: strictTemplates,
                    checkTypeOfAnimationEvents: strictTemplates,
                    // Checking of DOM events currently has an adverse effect on developer experience,
                    // e.g. for `<input (blur)="update($event.target.value)">` enabling this check results in:
                    // - error TS2531: Object is possibly 'null'.
                    // - error TS2339: Property 'value' does not exist on type 'EventTarget'.
                    checkTypeOfDomEvents: strictTemplates,
                    checkTypeOfDomReferences: strictTemplates,
                    // Non-DOM references have the correct type in View Engine so there is no strictness flag.
                    checkTypeOfNonDomReferences: true,
                    // Pipes are checked in View Engine so there is no strictness flag.
                    checkTypeOfPipes: true,
                    strictSafeNavigationTypes: strictTemplates,
                    useContextGenericType: strictTemplates,
                    strictLiteralTypes: true,
                };
            }
            else {
                typeCheckingConfig = {
                    applyTemplateContextGuards: false,
                    checkQueries: false,
                    checkTemplateBodies: false,
                    checkTypeOfInputBindings: false,
                    strictNullInputBindings: false,
                    checkTypeOfAttributes: false,
                    checkTypeOfDomBindings: false,
                    checkTypeOfOutputEvents: false,
                    checkTypeOfAnimationEvents: false,
                    checkTypeOfDomEvents: false,
                    checkTypeOfDomReferences: false,
                    checkTypeOfNonDomReferences: false,
                    checkTypeOfPipes: false,
                    strictSafeNavigationTypes: false,
                    useContextGenericType: false,
                    strictLiteralTypes: false,
                };
            }
            // Apply explicitly configured strictness flags on top of the default configuration
            // based on "fullTemplateTypeCheck".
            if (this.options.strictInputTypes !== undefined) {
                typeCheckingConfig.checkTypeOfInputBindings = this.options.strictInputTypes;
                typeCheckingConfig.applyTemplateContextGuards = this.options.strictInputTypes;
            }
            if (this.options.strictNullInputTypes !== undefined) {
                typeCheckingConfig.strictNullInputBindings = this.options.strictNullInputTypes;
            }
            if (this.options.strictOutputEventTypes !== undefined) {
                typeCheckingConfig.checkTypeOfOutputEvents = this.options.strictOutputEventTypes;
                typeCheckingConfig.checkTypeOfAnimationEvents = this.options.strictOutputEventTypes;
            }
            if (this.options.strictDomEventTypes !== undefined) {
                typeCheckingConfig.checkTypeOfDomEvents = this.options.strictDomEventTypes;
            }
            if (this.options.strictSafeNavigationTypes !== undefined) {
                typeCheckingConfig.strictSafeNavigationTypes = this.options.strictSafeNavigationTypes;
            }
            if (this.options.strictDomLocalRefTypes !== undefined) {
                typeCheckingConfig.checkTypeOfDomReferences = this.options.strictDomLocalRefTypes;
            }
            if (this.options.strictAttributeTypes !== undefined) {
                typeCheckingConfig.checkTypeOfAttributes = this.options.strictAttributeTypes;
            }
            if (this.options.strictContextGenerics !== undefined) {
                typeCheckingConfig.useContextGenericType = this.options.strictContextGenerics;
            }
            if (this.options.strictLiteralTypes !== undefined) {
                typeCheckingConfig.strictLiteralTypes = this.options.strictLiteralTypes;
            }
            return typeCheckingConfig;
        }
        getTemplateDiagnostics() {
            // Skip template type-checking if it's disabled.
            if (this.options.ivyTemplateTypeCheck === false && !this.fullTemplateTypeCheck) {
                return [];
            }
            const compilation = this.ensureAnalyzed();
            // Get the diagnostics.
            const typeCheckSpan = this.perfRecorder.start('typeCheckDiagnostics');
            const diagnostics = [];
            for (const sf of this.tsProgram.getSourceFiles()) {
                if (sf.isDeclarationFile || this.adapter.isShim(sf)) {
                    continue;
                }
                diagnostics.push(...compilation.templateTypeChecker.getDiagnosticsForFile(sf, OptimizeFor.WholeProgram));
            }
            const program = this.typeCheckingProgramStrategy.getProgram();
            this.perfRecorder.stop(typeCheckSpan);
            this.incrementalStrategy.setIncrementalDriver(this.incrementalDriver, program);
            this.nextProgram = program;
            return diagnostics;
        }
        /**
         * Reifies the inter-dependencies of NgModules and the components within their compilation scopes
         * into the `IncrementalDriver`'s dependency graph.
         */
        recordNgModuleScopeDependencies() {
            const recordSpan = this.perfRecorder.start('recordDependencies');
            const depGraph = this.incrementalDriver.depGraph;
            for (const scope of this.compilation.scopeRegistry.getCompilationScopes()) {
                const file = scope.declaration.getSourceFile();
                const ngModuleFile = scope.ngModule.getSourceFile();
                // A change to any dependency of the declaration causes the declaration to be invalidated,
                // which requires the NgModule to be invalidated as well.
                depGraph.addTransitiveDependency(ngModuleFile, file);
                // A change to the NgModule file should cause the declaration itself to be invalidated.
                depGraph.addDependency(file, ngModuleFile);
                const meta = this.compilation.metaReader.getDirectiveMetadata(new Reference$1(scope.declaration));
                if (meta !== null && meta.isComponent) {
                    // If a component's template changes, it might have affected the import graph, and thus the
                    // remote scoping feature which is activated in the event of potential import cycles. Thus,
                    // the module depends not only on the transitive dependencies of the component, but on its
                    // resources as well.
                    depGraph.addTransitiveResources(ngModuleFile, file);
                    // A change to any directive/pipe in the compilation scope should cause the component to be
                    // invalidated.
                    for (const directive of scope.directives) {
                        // When a directive in scope is updated, the component needs to be recompiled as e.g. a
                        // selector may have changed.
                        depGraph.addTransitiveDependency(file, directive.ref.node.getSourceFile());
                    }
                    for (const pipe of scope.pipes) {
                        // When a pipe in scope is updated, the component needs to be recompiled as e.g. the
                        // pipe's name may have changed.
                        depGraph.addTransitiveDependency(file, pipe.ref.node.getSourceFile());
                    }
                    // Components depend on the entire export scope. In addition to transitive dependencies on
                    // all directives/pipes in the export scope, they also depend on every NgModule in the
                    // scope, as changes to a module may add new directives/pipes to the scope.
                    for (const depModule of scope.ngModules) {
                        // There is a correctness issue here. To be correct, this should be a transitive
                        // dependency on the depModule file, since the depModule's exports might change via one of
                        // its dependencies, even if depModule's file itself doesn't change. However, doing this
                        // would also trigger recompilation if a non-exported component or directive changed,
                        // which causes performance issues for rebuilds.
                        //
                        // Given the rebuild issue is an edge case, currently we err on the side of performance
                        // instead of correctness. A correct and performant design would distinguish between
                        // changes to the depModule which affect its export scope and changes which do not, and
                        // only add a dependency for the former. This concept is currently in development.
                        //
                        // TODO(alxhub): fix correctness issue by understanding the semantics of the dependency.
                        depGraph.addDependency(file, depModule.getSourceFile());
                    }
                }
                else {
                    // Directives (not components) and pipes only depend on the NgModule which directly declares
                    // them.
                    depGraph.addDependency(file, ngModuleFile);
                }
            }
            this.perfRecorder.stop(recordSpan);
        }
        scanForMwp(sf) {
            this.compilation.mwpScanner.scan(sf, {
                addTypeReplacement: (node, type) => {
                    // Only obtain the return type transform for the source file once there's a type to replace,
                    // so that no transform is allocated when there's nothing to do.
                    this.compilation.dtsTransforms.getReturnTypeTransform(sf).addTypeReplacement(node, type);
                }
            });
        }
        makeCompilation() {
            const checker = this.tsProgram.getTypeChecker();
            const reflector = new TypeScriptReflectionHost(checker);
            // Construct the ReferenceEmitter.
            let refEmitter;
            let aliasingHost = null;
            if (this.adapter.unifiedModulesHost === null || !this.options._useHostForImportGeneration) {
                let localImportStrategy;
                // The strategy used for local, in-project imports depends on whether TS has been configured
                // with rootDirs. If so, then multiple directories may be mapped in the same "module
                // namespace" and the logic of `LogicalProjectStrategy` is required to generate correct
                // imports which may cross these multiple directories. Otherwise, plain relative imports are
                // sufficient.
                if (this.options.rootDir !== undefined ||
                    (this.options.rootDirs !== undefined && this.options.rootDirs.length > 0)) {
                    // rootDirs logic is in effect - use the `LogicalProjectStrategy` for in-project relative
                    // imports.
                    localImportStrategy = new LogicalProjectStrategy(reflector, new LogicalFileSystem([...this.adapter.rootDirs], this.adapter));
                }
                else {
                    // Plain relative imports are all that's needed.
                    localImportStrategy = new RelativePathStrategy(reflector);
                }
                // The CompilerHost doesn't have fileNameToModuleName, so build an NPM-centric reference
                // resolution strategy.
                refEmitter = new ReferenceEmitter([
                    // First, try to use local identifiers if available.
                    new LocalIdentifierStrategy(),
                    // Next, attempt to use an absolute import.
                    new AbsoluteModuleStrategy(this.tsProgram, checker, this.moduleResolver, reflector),
                    // Finally, check if the reference is being written into a file within the project's .ts
                    // sources, and use a relative import if so. If this fails, ReferenceEmitter will throw
                    // an error.
                    localImportStrategy,
                ]);
                // If an entrypoint is present, then all user imports should be directed through the
                // entrypoint and private exports are not needed. The compiler will validate that all publicly
                // visible directives/pipes are importable via this entrypoint.
                if (this.entryPoint === null && this.options.generateDeepReexports === true) {
                    // No entrypoint is present and deep re-exports were requested, so configure the aliasing
                    // system to generate them.
                    aliasingHost = new PrivateExportAliasingHost(reflector);
                }
            }
            else {
                // The CompilerHost supports fileNameToModuleName, so use that to emit imports.
                refEmitter = new ReferenceEmitter([
                    // First, try to use local identifiers if available.
                    new LocalIdentifierStrategy(),
                    // Then use aliased references (this is a workaround to StrictDeps checks).
                    new AliasStrategy(),
                    // Then use fileNameToModuleName to emit imports.
                    new UnifiedModulesStrategy(reflector, this.adapter.unifiedModulesHost),
                ]);
                aliasingHost = new UnifiedModulesAliasingHost(this.adapter.unifiedModulesHost);
            }
            const evaluator = new PartialEvaluator(reflector, checker, this.incrementalDriver.depGraph);
            const dtsReader = new DtsMetadataReader(checker, reflector);
            const localMetaRegistry = new LocalMetadataRegistry();
            const localMetaReader = localMetaRegistry;
            const depScopeReader = new MetadataDtsModuleScopeResolver(dtsReader, aliasingHost);
            const scopeRegistry = new LocalModuleScopeRegistry(localMetaReader, depScopeReader, refEmitter, aliasingHost);
            const scopeReader = scopeRegistry;
            const metaRegistry = new CompoundMetadataRegistry([localMetaRegistry, scopeRegistry]);
            const injectableRegistry = new InjectableClassRegistry(reflector);
            const metaReader = new CompoundMetadataReader([localMetaReader, dtsReader]);
            // If a flat module entrypoint was specified, then track references via a `ReferenceGraph` in
            // order to produce proper diagnostics for incorrectly exported directives/pipes/etc. If there
            // is no flat module entrypoint then don't pay the cost of tracking references.
            let referencesRegistry;
            let exportReferenceGraph = null;
            if (this.entryPoint !== null) {
                exportReferenceGraph = new ReferenceGraph();
                referencesRegistry = new ReferenceGraphAdapter(exportReferenceGraph);
            }
            else {
                referencesRegistry = new NoopReferencesRegistry();
            }
            const routeAnalyzer = new NgModuleRouteAnalyzer(this.moduleResolver, evaluator);
            const dtsTransforms = new DtsTransformRegistry();
            const mwpScanner = new ModuleWithProvidersScanner(reflector, evaluator, refEmitter);
            const isCore = isAngularCorePackage(this.tsProgram);
            const defaultImportTracker = new DefaultImportTracker();
            // Set up the IvyCompilation, which manages state for the Ivy transformer.
            const handlers = [
                new ComponentDecoratorHandler(reflector, evaluator, metaRegistry, metaReader, scopeReader, scopeRegistry, isCore, this.resourceManager, this.adapter.rootDirs, this.options.preserveWhitespaces || false, this.options.i18nUseExternalIds !== false, this.options.enableI18nLegacyMessageIdFormat !== false, this.options.i18nNormalizeLineEndingsInICUs, this.moduleResolver, this.cycleAnalyzer, refEmitter, defaultImportTracker, this.incrementalDriver.depGraph, injectableRegistry, this.closureCompilerEnabled),
                // TODO(alxhub): understand why the cast here is necessary (something to do with `null`
                // not being assignable to `unknown` when wrapped in `Readonly`).
                // clang-format off
                new DirectiveDecoratorHandler(reflector, evaluator, metaRegistry, scopeRegistry, metaReader, defaultImportTracker, injectableRegistry, isCore, this.closureCompilerEnabled, 
                // In ngtsc we no longer want to compile undecorated classes with Angular features.
                // Migrations for these patterns ran as part of `ng update` and we want to ensure
                // that projects do not regress. See https://hackmd.io/@alx/ryfYYuvzH for more details.
                /* compileUndecoratedClassesWithAngularFeatures */ false),
                // clang-format on
                // Pipe handler must be before injectable handler in list so pipe factories are printed
                // before injectable factories (so injectable factories can delegate to them)
                new PipeDecoratorHandler(reflector, evaluator, metaRegistry, scopeRegistry, defaultImportTracker, injectableRegistry, isCore),
                new InjectableDecoratorHandler(reflector, defaultImportTracker, isCore, this.options.strictInjectionParameters || false, injectableRegistry),
                new NgModuleDecoratorHandler(reflector, evaluator, metaReader, metaRegistry, scopeRegistry, referencesRegistry, isCore, routeAnalyzer, refEmitter, this.adapter.factoryTracker, defaultImportTracker, this.closureCompilerEnabled, injectableRegistry, this.options.i18nInLocale),
            ];
            const traitCompiler = new TraitCompiler(handlers, reflector, this.perfRecorder, this.incrementalDriver, this.options.compileNonExportedClasses !== false, dtsTransforms);
            const templateTypeChecker = new TemplateTypeCheckerImpl(this.tsProgram, this.typeCheckingProgramStrategy, traitCompiler, this.getTypeCheckingConfig(), refEmitter, reflector, this.adapter, this.incrementalDriver);
            return {
                isCore,
                traitCompiler,
                reflector,
                scopeRegistry,
                dtsTransforms,
                exportReferenceGraph,
                routeAnalyzer,
                mwpScanner,
                metaReader,
                defaultImportTracker,
                aliasingHost,
                refEmitter,
                templateTypeChecker,
            };
        }
    }
    /**
     * Determine if the given `Program` is @angular/core.
     */
    function isAngularCorePackage(program) {
        // Look for its_just_angular.ts somewhere in the program.
        const r3Symbols = getR3SymbolsFile(program);
        if (r3Symbols === null) {
            return false;
        }
        // Look for the constant ITS_JUST_ANGULAR in that file.
        return r3Symbols.statements.some(stmt => {
            // The statement must be a variable declaration statement.
            if (!ts.isVariableStatement(stmt)) {
                return false;
            }
            // It must be exported.
            if (stmt.modifiers === undefined ||
                !stmt.modifiers.some(mod => mod.kind === ts.SyntaxKind.ExportKeyword)) {
                return false;
            }
            // It must declare ITS_JUST_ANGULAR.
            return stmt.declarationList.declarations.some(decl => {
                // The declaration must match the name.
                if (!ts.isIdentifier(decl.name) || decl.name.text !== 'ITS_JUST_ANGULAR') {
                    return false;
                }
                // It must initialize the variable to true.
                if (decl.initializer === undefined || decl.initializer.kind !== ts.SyntaxKind.TrueKeyword) {
                    return false;
                }
                // This definition matches.
                return true;
            });
        });
    }
    /**
     * Find the 'r3_symbols.ts' file in the given `Program`, or return `null` if it wasn't there.
     */
    function getR3SymbolsFile(program) {
        return program.getSourceFiles().find(file => file.fileName.indexOf('r3_symbols.ts') >= 0) || null;
    }
    /**
     * Since "strictTemplates" is a true superset of type checking capabilities compared to
     * "strictTemplateTypeCheck", it is required that the latter is not explicitly disabled if the
     * former is enabled.
     */
    function verifyCompatibleTypeCheckOptions(options) {
        if (options.fullTemplateTypeCheck === false && options.strictTemplates === true) {
            return {
                category: ts.DiagnosticCategory.Error,
                code: ngErrorCode(ErrorCode.CONFIG_STRICT_TEMPLATES_IMPLIES_FULL_TEMPLATE_TYPECHECK),
                file: undefined,
                start: undefined,
                length: undefined,
                messageText: `Angular compiler option "strictTemplates" is enabled, however "fullTemplateTypeCheck" is disabled.

Having the "strictTemplates" flag enabled implies that "fullTemplateTypeCheck" is also enabled, so
the latter can not be explicitly disabled.

One of the following actions is required:
1. Remove the "fullTemplateTypeCheck" option.
2. Remove "strictTemplates" or set it to 'false'.

More information about the template type checking compiler options can be found in the documentation:
https://v9.angular.io/guide/template-typecheck#template-type-checking`,
            };
        }
        return null;
    }
    class ReferenceGraphAdapter {
        constructor(graph) {
            this.graph = graph;
        }
        add(source, ...references) {
            for (const { node } of references) {
                let sourceFile = node.getSourceFile();
                if (sourceFile === undefined) {
                    sourceFile = ts.getOriginalNode(node).getSourceFile();
                }
                // Only record local references (not references into .d.ts files).
                if (sourceFile === undefined || !isDtsPath(sourceFile.fileName)) {
                    this.graph.add(source, node);
                }
            }
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function createNgCompilerOptions(basePath, config, tsOptions) {
        // enableIvy `ngtsc` is an alias for `true`.
        const { angularCompilerOptions = {} } = config;
        const { enableIvy } = angularCompilerOptions;
        angularCompilerOptions.enableIvy = enableIvy !== false && enableIvy !== 'tsc';
        return Object.assign(Object.assign(Object.assign({}, tsOptions), angularCompilerOptions), { genDir: basePath, basePath });
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Known values for global variables in `@angular/core` that Terser should set using
     * https://github.com/terser-js/terser#conditional-compilation
     */
    const GLOBAL_DEFS_FOR_TERSER = {
        ngDevMode: false,
        ngI18nClosureMode: false,
    };
    const GLOBAL_DEFS_FOR_TERSER_WITH_AOT = Object.assign(Object.assign({}, GLOBAL_DEFS_FOR_TERSER), { ngJitMode: false });

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    setFileSystem(new NodeJSFileSystem());

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class LanguageService {
        constructor(project, tsLS) {
            this.tsLS = tsLS;
            this.lastKnownProgram = null;
            this.options = parseNgCompilerOptions(project);
            this.strategy = createTypeCheckingProgramStrategy(project);
            this.adapter = createNgCompilerAdapter(project);
            this.watchConfigFile(project);
        }
        getSemanticDiagnostics(fileName) {
            const program = this.strategy.getProgram();
            const compiler = this.createCompiler(program);
            if (fileName.endsWith('.ts')) {
                const sourceFile = program.getSourceFile(fileName);
                if (!sourceFile) {
                    return [];
                }
                const ttc = compiler.getTemplateTypeChecker();
                const diagnostics = ttc.getDiagnosticsForFile(sourceFile, OptimizeFor.SingleFile);
                this.lastKnownProgram = compiler.getNextProgram();
                return diagnostics;
            }
            throw new Error('Ivy LS currently does not support external template');
        }
        createCompiler(program) {
            return new NgCompiler(this.adapter, this.options, program, this.strategy, new PatchedProgramIncrementalBuildStrategy(), this.lastKnownProgram);
        }
        watchConfigFile(project) {
            // TODO: Check the case when the project is disposed. An InferredProject
            // could be disposed when a tsconfig.json is added to the workspace,
            // in which case it becomes a ConfiguredProject (or vice-versa).
            // We need to make sure that the FileWatcher is closed.
            if (!(project instanceof ts$1.server.ConfiguredProject)) {
                return;
            }
            const { host } = project.projectService;
            host.watchFile(project.getConfigFilePath(), (fileName, eventKind) => {
                project.log(`Config file changed: ${fileName}`);
                if (eventKind === ts$1.FileWatcherEventKind.Changed) {
                    this.options = parseNgCompilerOptions(project);
                }
            });
        }
    }
    function parseNgCompilerOptions(project) {
        let config = {};
        if (project instanceof ts$1.server.ConfiguredProject) {
            const configPath = project.getConfigFilePath();
            const result = ts$1.readConfigFile(configPath, path => project.readFile(path));
            if (result.error) {
                project.error(ts$1.flattenDiagnosticMessageText(result.error.messageText, '\n'));
            }
            config = result.config || config;
        }
        const basePath = project.getCurrentDirectory();
        return createNgCompilerOptions(basePath, config, project.getCompilationSettings());
    }
    function createNgCompilerAdapter(project) {
        var _a;
        return {
            entryPoint: null,
            constructionDiagnostics: [],
            ignoreForEmit: new Set(),
            factoryTracker: null,
            unifiedModulesHost: null,
            rootDirs: ((_a = project.getCompilationSettings().rootDirs) === null || _a === void 0 ? void 0 : _a.map(absoluteFrom)) || [],
            isShim,
            fileExists(fileName) {
                return project.fileExists(fileName);
            },
            readFile(fileName) {
                return project.readFile(fileName);
            },
            getCurrentDirectory() {
                return project.getCurrentDirectory();
            },
            getCanonicalFileName(fileName) {
                return project.projectService.toCanonicalFileName(fileName);
            },
        };
    }
    function createTypeCheckingProgramStrategy(project) {
        return {
            supportsInlineOperations: false,
            shimPathForComponent(component) {
                return TypeCheckShimGenerator.shimFor(absoluteFromSourceFile(component.getSourceFile()));
            },
            getProgram() {
                const program = project.getLanguageService().getProgram();
                if (!program) {
                    throw new Error('Language service does not have a program!');
                }
                return program;
            },
            updateFiles(contents) {
                for (const [fileName, newText] of contents) {
                    const scriptInfo = getOrCreateTypeCheckScriptInfo(project, fileName);
                    const snapshot = scriptInfo.getSnapshot();
                    const length = snapshot.getLength();
                    scriptInfo.editContent(0, length, newText);
                }
            },
        };
    }
    function getOrCreateTypeCheckScriptInfo(project, tcf) {
        // First check if there is already a ScriptInfo for the tcf
        const { projectService } = project;
        let scriptInfo = projectService.getScriptInfo(tcf);
        if (!scriptInfo) {
            // ScriptInfo needs to be opened by client to be able to set its user-defined
            // content. We must also provide file content, otherwise the service will
            // attempt to fetch the content from disk and fail.
            scriptInfo = projectService.getOrCreateScriptInfoForNormalizedPath(ts$1.server.toNormalizedPath(tcf), true, // openedByClient
            '', // fileContent
            ts$1.ScriptKind.TS);
            if (!scriptInfo) {
                throw new Error(`Failed to create script info for ${tcf}`);
            }
        }
        // Add ScriptInfo to project if it's missing. A ScriptInfo needs to be part of
        // the project so that it becomes part of the program.
        if (!project.containsScriptInfo(scriptInfo)) {
            project.addRoot(scriptInfo);
        }
        return scriptInfo;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function create(info) {
        const { project, languageService: tsLS, config } = info;
        const angularOnly = (config === null || config === void 0 ? void 0 : config.angularOnly) === true;
        const ngLS = new LanguageService(project, tsLS);
        function getSemanticDiagnostics(fileName) {
            const diagnostics = [];
            if (!angularOnly) {
                diagnostics.push(...tsLS.getSemanticDiagnostics(fileName));
            }
            diagnostics.push(...ngLS.getSemanticDiagnostics(fileName));
            return diagnostics;
        }
        return Object.assign(Object.assign({}, tsLS), { getSemanticDiagnostics });
    }

    exports.create = create;

    Object.defineProperty(exports, '__esModule', { value: true });

});
//# sourceMappingURL=ivy.js.map
